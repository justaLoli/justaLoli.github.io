<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算摄像学 第七讲 光度立体视觉</title>
    <link href="/posts/7606.html"/>
    <url>/posts/7606.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>计算摄像：通过计算获取普通相机拍摄图像之外的信息</p><p>例如：通过相机获取三维形状</p><p>光度法恢复物体形状：主要通过多张图</p><p>光度方法只能获得物体一面的3d信息（背面看不到），但是，可以获得的很精确。</p><p>回顾：BRDF、电光源、平行光源、朗伯反射</p><p>朗伯反射：</p><p>i 像素值 正比于 光强 x 表面反射率 x 表面法向和光源方向的夹角（写成n点乘l）</p><p><strong>光度立体视觉：假设物体表面反射符合朗伯成像模型，给定多张不同平行光光照下的图片（I），以及光源方向（L），求解每个像素的法线方向（N）。</strong></p><p>对于每个像素点：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i1</span> <span class="hljs-operator">=</span> n · l1<br><span class="hljs-attribute">i2</span> <span class="hljs-operator">=</span> n · l2<br><span class="hljs-attribute">i3</span> <span class="hljs-operator">=</span> n · l3<br>...<br><span class="hljs-attribute">iF</span> <span class="hljs-operator">=</span> n · lF<br></code></pre></td></tr></table></figure><p>可以总结为矩阵 <em><strong>I &#x3D; N * L</strong></em> I是图像数据，N是代求每个位置的法向量，L为每张图片的光源方向。用IL求N。</p><p>至少需要三张光线方向不共面的照片，能得到唯一解。当然多了更好</p><p>I可以从图像（经过光度标定的图）直接得到</p><p>L如何得到？利用镜面球进行光源标定（其实最好的是台球）。（利用球面上的亮点）</p><p>接下来，可以进一步求解表面的漫反射率</p><p>问题：</p><ol><li>朗伯反射物体很难找</li><li>平行光很难找（太阳光是不可以的，因为它的轨迹在短时间内在同一平面（见上面第40行</li><li>要求先进行光度标定</li></ol><p>更多的研究方向：</p><ol><li>减少光源数量</li><li>非标定的光源</li><li>非标定的自然光</li><li>含有噪声的观测</li><li>复杂材质</li><li>复杂环境</li></ol><p>数据集：DiLiGenT</p><p>光度立体的精度在某些极限情况可以逼近乃至超过激光扫描。</p>]]></content>
    
    
    <categories>
      
      <category>计算摄像学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算摄像学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数算关键概念一览</title>
    <link href="/posts/11144.html"/>
    <url>/posts/11144.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>话不多说，直入正题</p><h2 id="课上说到的重点"><a href="#课上说到的重点" class="headerlink" title="课上说到的重点"></a>课上说到的重点</h2><p>数据结构按逻辑结构和存储结构的分类</p><p>链表的操作细节</p><p>KMP搜索算法</p><p>循环队列空和满的判断</p><p>树的深度周游（非递归实现）</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul><li>程序</li></ul><p>是使用程序设计语言精确描述的实现模型，它是问题求解的一个可以在计算机上运行的模型。程序中描述的数据用来表示问题中涉及的对象，程序中描述的过程表示了对于数据的处理算法;通过接受实际问题的输入，经过程序的运行，便可以得到实际问题的一个解。</p><ul><li>数据类型 data type</li></ul><p>通常是指在计算机(语言）中可以使用的一个类型，它不但包括这个类型的值的集合，还包括定义在这个类型上的一组操作。例如，整数作为一个数据类型是指在计算机上所能表示的(不是数学意义上任意大小的）所有整数和语言中定义的对于这些整数的全部操作(整数的加、减、乘、除、取余等）。在不会造成误解的上下文中，本书中提到的许多类型（例如整数类型、实数类型等）多数都指数据类型。</p><ul><li>抽象数据类型 ADT</li></ul><p>可以定义为具有一定行为（操作）的抽象(数学）类型。它不关心类型中值的具体表示方式和数据类型中定义的各种操作的具体实现方法，是所有可能的值的具体表示和各种操作的具体实现的抽象。</p><ul><li>数据结构</li></ul><p>通常，可以把数据结构理解为：计算机中表示(存储）的、具有一定逻辑关系和行为特征的一组数据。</p><p>其中的每个数据元素称为这个结构的一个<em><strong>结点</strong></em>。</p><p>本书把 <em><strong>数据结构</strong></em> 理解为 <em><strong>“抽象数据类型的物理实现”</strong></em> 。</p><ul><li><p>需要注意的是，无论从什么观点出发，算法和数据结构在程序设计中的核心地位和作用并没有任何改变。对于数据结构的不同理解，实际上都离不开以下三个要素：</p><ul><li><em><strong>逻辑结构</strong></em>：它定义了数学模型中的基本元素(结点)和元素之间的相互关系。</li><li><em><strong>存储结构</strong></em>：它给出了数学模型的具体表示方式，包括结点的表示和关系的表示。</li><li><em><strong>操作</strong></em>：它给出抽象数据类型关心的各种行为在存储结构上的具体实现算法。</li></ul></li><li><p>数据结构的分类</p><ul><li>逻辑结构<ul><li>重要概念<ul><li><code>B = &lt;K,R&gt;</code></li><li>R <strong>关系</strong> “二元组的集合”</li><li><code>&lt;k,k&#39;&gt;</code> <em><strong>前驱</strong></em>k，<em><strong>后继</strong></em>k’</li><li><em><strong>开始结点</strong></em>：没有前驱的结点，<em><strong>终端结点</strong></em>：没有后继的结点</li></ul></li><li>集合</li><li>线性结构</li><li>树形结构（老师ppt称层状）</li><li>复杂结构（老师ppt称网状）</li><li>包含关系：<code>集合包含线性结构包含树形结构包含复杂结构</code></li></ul></li><li>存储结构<ul><li>顺序表示：用一个连续的空间顺序存放数据结构中的各个结点。</li><li>链接表示：结点的存放位置是任意的,结点之间的关系通过与结点关联的指针(或者引用）方式显式表达出来。</li><li>散列表示：又称为关键码——地址转换法。即选择适当的散列（杂凑）函数，根据关键码的值将结点映射到给定的存储空间(散列表）中。</li><li>索引表示：索引与散列一样，都给出一种从关键码到存储地址的映射方法。不同的是，散列法的映射是通过函数定义，而索引法是通过建立辅助的索引结构解决。</li></ul></li></ul></li><li><p>结点</p></li></ul><p>组成结构的元素抽象成<em><strong>结点</strong></em>。分成<em><strong>初等类型</strong></em>和<em><strong>组合类型</strong></em></p><ul><li>算法</li></ul><p><em><strong>算法</strong></em>是由有穷规则构成的为解决某一类问题的运算序列(方法或过程）。</p><p>算法可以有若干<em><strong>输入</strong></em>，这些输入是在算法开始时给出的初始值或条件;算法通常又有若干个<em><strong>输出</strong></em>，它们是同输入有某种关系的计算结果。</p><p><em><strong>算法的性质</strong></em>如下：<em><strong>有穷性。</strong></em> 一个算法必须在执行了有穷步之后结束。在某些领域也需要研究不终止的算法，但这不属于本书讨论的范畴。<em><strong>确定性。</strong></em> 算法的每一步必须有确切的定义。也就是说，对于每步需要执行的动作必须严格地和清楚地给出规定。<em><strong>可行性。</strong></em> 算法是可行的，意味着算法中的每个动作，原则上都是能够由机器或人准确完成的。整个算法好像是一个解决问题的“工作序列〞，其中的每一步都是我们力所能及的一个动作。</p><p><em><strong>算法正确性：如果一个算法以一组满足初始条件的输入开始，那么该算法的执行一定会终止,并且在终止时得到满足要求的(输出）结果。</strong></em></p><ul><li>算法的设计</li></ul><p>贪心法</p><p>分治法</p><p>回溯法（深度优先</p><p>动态规划法</p><p>分枝界限法（广度优先</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ul><li>线性表</li></ul><p><em><strong>线性表</strong></em>简称为<em><strong>表</strong></em>，是零个或多个元素（也称表目）的有穷序列。</p><p>K中所含元素的个数称为表的<em><strong>长度</strong></em>,长度为零的表称为<em><strong>空表</strong></em>。</p><ul><li>顺序表</li></ul><p>采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个地存储在一片相邻的存储区域中。这种顺序表示的线性表也称为<strong>顺序表</strong>。</p><ul><li>链表</li></ul><p>每个结点就包括两个域：<em><strong>数据域</strong></em>（info)—存放元素本身的信息；<em><strong>指针域</strong></em>(link）——存放其后继结点的存储位置。由于最后一个元素没有后继，它的指针不指向任何结点，称为空指针。空指针图示中用“^”表示，算法中用“NULL”</p><p>假设一个线性表有n个元素，则这几个元素所对应的几个结点就通过指针链接成一个<em><strong>链表</strong></em>。由于这种链表中每个结点只有一个指针城，故又称为<em><strong>单链表</strong></em>。指向链表中第一个结点的指针称为该链表的<em><strong>头指针</strong></em>。</p><p>有时，为了处理方便，可以在单链表的第一个结点之前另加一个结点，称之为<em><strong>头结点</strong></em>。</p><p><em><strong>循环链表</strong></em>，<em><strong>双链表</strong></em>，<em><strong>循环双链表</strong></em></p><ul><li><p>稀疏矩阵的表示方法</p></li><li><p>三元组表示法，伪地址表示法</p></li><li><p>行-列表示法</p></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符串</li></ul><p><em><strong>字符串</strong></em>简称串,是一种特殊的线性表，其特殊性主要在于表中的每个元素是一个字符。</p><ul><li>KMP模式匹配</li></ul><p><em><strong>（书p82）</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">makeNext()&#123;PSeqString p,<span class="hljs-type">int</span> *next&#125;&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">-1</span>;<br>next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt; p-&gt;n<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">while</span>(k&gt;=<span class="hljs-number">0</span> &amp;&amp; p-&gt;c[i]!=p-&gt;c[k])&#123;<br>k = next[k];<br>&#125;<br>i++;k++;<br><span class="hljs-keyword">if</span>(p-&gt;c[i] == p-&gt;c[k])&#123;<br>next[i] = next[k];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>next[i] = k;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进后算法分析算法 3.8 从形式上看是一个二重循环，每重循环最多执行 m次,最大运行时间可能达到0(m^2）。但仔细分析一下可知，因为每执行一次外层循环(第4行),i严格增1(第6行),所以外层循环正好执行m-1 次;另外k 的值从-1 开始（第2行）,执行k +m-1次(第6行),并且只有在这一语句中k 被增值。在内层循环(第5行)中,语句<code>k= next[k]</code>至少使长减少1,所以整个算法中，这个语句的执行次数累计起来不可能超过m-1次(否则k将小于 -1,这是不可能的），所以内层循环总的执行次数最大为m-1。因此算法3.8的执行时间为0(m）。与算法3.6的执行时间合在一起，得到用长度为m的模式串p与长度为n的目标串t进行匹配所需的总计算时间为 O(m +n)。Knuth 等人提出的快速模式匹配算法，当 n≥m时，其优越性是显然的，特别在一个模式被反复使用时，只要花一次0(m）的时间计算 next 数组，以后的每次匹配只要用0(n）的时间;但是，当n与m 接近，并且处理只匹配一次的模式时，朴素的匹配算法所花的时间代价也可能会更为节省。快速匹配的算法意义还在于：算法本身的设计方法具有代表性，它首先建立了next 数组，以此作为匹配过程的工具，从而提高了匹配的速度；另外，算法3.6 和算法3.8 的时间分析方法也是常用的方法之一，希望读者掌握。</p><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><ul><li>栈</li></ul><p><em><strong>栈</strong></em>是一种特殊的线性表，它所有的插入和删除操作都限制在表的同一端进行。表中允许进行插入、删除操作的一端叫做<em><strong>栈顶</strong></em>，另一端则叫做<em><strong>栈底</strong></em>。当栈中没有元素时，称为<em><strong>空栈</strong></em>。</p><p>因此，栈又称为<em><strong>后迸先出</strong></em>(Last in First Out, LIFO)表或<em><strong>下推表</strong></em>。</p><p>由于栈是一种动态结构，而数组是静态结构，因此，当栈中已经有 MAXNUM个元素时，如果再做进栈运算，则会产生溢出，通常称为<em><strong>上溢</strong></em>(overflow）；而对空栈进行出栈运算时也会产生溢出,通常称为<em><strong>下溢</strong></em>(underlow）。为了避免溢出，在对栈进行进栈运算和出栈运算前，应分别检测栈是否已满或是否已空。</p><p><em><strong>中缀表达式的计算，书p100</strong></em></p><ul><li>队列</li></ul><p>队列也是一种特殊的线性表，是一种只允许在表的一端进行插人操作,而在另一端进行删除操作的线性表。允许进行删除的一端称为<em><strong>队头</strong></em>，允许进行插入的一端叫做<em><strong>队尾</strong></em>。当队列中没有任何元素时，称为<em><strong>空队</strong></em>。</p><p>队列的插入操作通常称为<em><strong>入队</strong></em>，队列的删除操作通常称为<em><strong>出队</strong></em>。</p><p>队列同现实生活中等车、买票的排队相仿，新来的成员总是加入到队尾，每次离开队列的总是队头上的，即当前“最老的”成员。因此，队列也称为<em><strong>先进先出</strong></em>(First In First Out, FIFO)表。</p><p>在顺序表示的队列中，同栈一样存在队列溢出问题。即当队列满时，再做入队操作，这种现象称为<em><strong>上溢</strong></em>;而当队空时，做出队操作，这种现象称为<em><strong>下溢</strong></em>。这些现象在运算中都要考虑。</p><p><em><strong>环形队列</strong></em></p><p>为区分空队列与满队列两种情况的环形队列，一般是牺牲队列中的一个结点，当队列中已有 MAXNUM-1 个结点时就称满，再要插入就发生溢出。（p105</p><p>注意形如<code>(k+1)%n</code>的形式</p><p><em><strong>双端队列</strong></em>是一种特殊的线性表，对它所有的插人和删除都限制在表的两瑞进行。它好像一个特别的书架，取书和存书限定在两边进行。</p><p><em><strong>双栈</strong></em>是一种加限制的双端队列，它规定从一端插入的元素只能从同一端删除，它就好像两个底部相连的栈。</p><p><em><strong>超队列</strong></em>是一种输出受限的双端队列，即删除限制在一端进行,而插入仍允许在两端进行。它好像一种特殊的队列,允许有的最新插入的元素最先删除。</p><p><em><strong>超栈</strong></em>是一种输人受限的双端队列，即插入限制在一端进行,而删除仍允许在两端进行。它可以看成对栈溢出时的一种特殊的处理，即当栈溢出时，可将栈中保存最久的元素删除。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li><p>树的存储方式</p></li><li><p>树的遍历（周游</p><ul><li>深度方向</li><li>广度方向</li></ul></li><li><p>深度方向</p><ul><li>先根遍历</li><li>中根遍历</li><li>后根遍历</li></ul></li><li><p>先根遍历</p></li></ul><p>任何结点，先根遍历完后：如有右兄弟，进入右兄弟；否则，进入上一层（父结点）的右兄弟。</p><ul><li>中根遍历</li></ul><p>任何结点，中根遍历完（长子子树也已经遍历完）后：</p><p>1)如有第2颗子树，进入。2）否则（也无其它子树），父结点第2颗和2后的子树，进入前需要保存右兄弟，以便子树遍历完后，进入右兄弟。</p><ul><li>后根遍历</li></ul><p>任何结点，后根遍历完后：如有右兄弟，进入右兄弟；否则，上一层（父结点）</p><ul><li><p>三种深度遍历的非递归实现（重要‼️）看ppt</p></li><li><p>广度方向（层次遍历）</p></li></ul><p>利用队列</p><ul><li>二叉树</li></ul><p><em><strong>二叉树的定义:</strong></em> 结点的有限集合，该集合或者为空集，或者由一个称为根的结点和两颗互不相交的分别称为根的“左子树”和“右子树”的二叉树组成。</p><p>注意：左子树存在，右子树不存在，和左子树不存在，右子树存在是两种不同情况。</p><p>‼️重要：二叉树并不属于树，<em><strong>二叉树不是树的特殊形态</strong></em>。二叉树在只有一棵子树时，也要明确是左子树还是右子树。这和普通的树是完全不同的。</p><p>满二叉树：<em><strong>如果一棵二叉树的任何结点或者是树叶，或者有两棵非空子树，则此二叉树称作“满二叉树”。</strong></em> <em><strong>注意这个定义和普通定义不同。</strong></em></p><p><em><strong>全满二叉树：</strong></em>为普通定义的“满二叉树”。</p><p><em><strong>完全二叉树</strong></em>：如果一棵二叉树至多只有最下面的两层结点度数可以小于2，并且最下面一层的结点都集中在该层<em><strong>最</strong></em>左边的若干位置上，则此二叉树称为“完全二叉树”。</p><p><em><strong>扩充二叉树</strong></em>：把原来二叉树节点中，度小于2的节点都扩充为度为2的节点。注意：在扩充二叉树的过程中，<em><strong>新增加的“外部节点”一定比原来存在的“内部节点”个数多1</strong></em></p><p>假定内部结点数为n，则扩充二叉树中有2n条边，2n+1个结点，因此外部结点数目为:2n+1-n&#x3D;n+1。</p><p><em><strong>外部路径长度E</strong></em>：在扩充的二叉树里从根到每个外部结点的路径长度之和。</p><p><em><strong>内部路径长度I</strong></em>：在扩充的二叉树里从根到每个内部结点的路径长度之和。</p><p><em><strong>E &#x3D; I + 2n</strong></em></p><p><em><strong>二叉树的性质</strong></em>：</p><ol><li>在二叉树的“i层”上至多有 $2^i$ 个结点(i&gt;&#x3D;0)。<ol><li>在二叉树的“第i层”上至多有 $2^{i-1}$ 个结点(i&gt;&#x3D;1)。</li></ol></li><li>深度为k的二叉树至多有2^(k)-1个结点(k&gt;&#x3D;0)。</li><li>对任何一棵二叉树T，如果其叶子结点(度为0的节点)数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</li><li>具有n个结点的<em>完全二叉树</em>的深度k &#x3D; log(n+1)。</li><li>对于有n个节点的<em>完全二叉树</em>，从上到下，从左往右编号（从1开始）<ol><li>i&#x3D;1 i为根</li><li>i &gt; 1，i的父节点为i&#x2F;2</li><li>如果2i &gt; n,i无左子女，否则i的左子女为2i</li><li>如果2i+1 &gt; n,i无右子女，否则i的右子女为2i+1</li></ol></li><li>在<em>扩充二叉树</em>中，外部节点比内部节点多1</li><li><em>扩充二叉树</em>中，外部路径长度E &#x3D; 内部路径长度I + 2 * 内部节点数n</li></ol><p>要掌握性质7的证明</p><p><img src="/posts/11144/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A87%E7%9A%84%E8%AF%81%E6%98%8E.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>数算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算摄像学第十二讲 图像反射消除</title>
    <link href="/posts/63671.html"/>
    <url>/posts/63671.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>（为什么是第十二讲）有一些论文原作者可以来讲，因此调整了一下顺序。</p><p>讲者1 常亚坤</p><p>主要内容：</p><ol><li>背景介绍<ul><li>成像模型、反射特性</li></ul></li><li>经典优化求解</li><li>基准评价数据集</li><li>基于深度学习的方法。</li></ol><h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h3><ol><li>反射的成因（经典物理图像</li><li>反射的特性<ol><li>若反射和背景都在景深内，结果相当于线性叠加</li><li>若反射在景深外，背景在景深内，结果相当于给反射加了模糊的卷积</li><li>若反射镜有厚度，将出现重影</li></ol></li><li>反射的（不利）影响<ol><li>例子：对着玻璃拍容易不美观</li><li>对后期计算造成干扰</li></ol></li><li>反射的消除</li></ol><h3 id="2-传统方法"><a href="#2-传统方法" class="headerlink" title="2. 传统方法"></a>2. 传统方法</h3><ol><li>“人力驱动”，手工标记数据</li></ol><p>它基于了“背景图层和反射图层一定程度上是独立的”的假设。</p><p>主要过程：第一阶段：边缘标记和边缘分类-&gt;第二阶段：反射消除</p><ol start="2"><li>景深引导的反射消除</li></ol><p>主要依据：背景清晰时，反射多半会模糊。在梯度分布中也能看出。如果清晰的图像被模糊，梯度值更聚集于0（图像变化更平滑）；如果原本模糊的图像被模糊，则梯度直方图没有太大变化。</p><ol start="3"><li><p>基于相对平滑性</p></li><li><p>基于多张图像：基于两层图像的位移不一致。</p></li></ol><p>变换相机角度，拍摄多张图像。移动时，背景的边缘移动和反射的边缘移动有不同。</p><h3 id="基准评价数据集"><a href="#基准评价数据集" class="headerlink" title="基准评价数据集"></a>基准评价数据集</h3><p>讲者：万人杰</p><p>量化地评价消除反射的效果。</p><p>SIR2数据集；SIR2+数据集</p><p>（后面还有一下东西，没仔细听了呜呜</p><h3 id="深度学习去反射"><a href="#深度学习去反射" class="headerlink" title="深度学习去反射"></a>深度学习去反射</h3><p>第一篇（CN ACCV 16</p><p>借鉴了传统方法的思路，对深度进行分类，然后进行剔除</p><p>Fan ICCV 17</p><p>通过神经网络学背景层的边缘，辅助去除反射</p><p>借鉴了传统的两步走方法：先提取边缘，分类，再剔除</p><p>Wan CVPR 18 CRRN</p><p>并联的反射消除网络</p><p>Wan TPAMI 19 CoRRN</p><p>“协作式”的神经网络，</p><p>Zhang CVPR 18</p><p>“感知损失函数”辅助去反射</p><p>。。。。</p><p>基于偏振的反射消除</p>]]></content>
    
    
    <categories>
      
      <category>计算摄像学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算摄像学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算摄像学第六讲 光照，反射率与明暗模型</title>
    <link href="/posts/43140.html"/>
    <url>/posts/43140.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>光度模型</p><p>三维建模方法，激光测距扫描？</p><p>多视角图像重建结果（相机几何标定</p><p>对比：</p><p>几何建模：有总体形状，无细节</p><p>光度立体：无形状？，有精细的细节</p><p>利用光强理解物体的形状，计算机如何从图像的强度中理解物体形象？</p><p>光度成像过程：</p><p><code>光照-&gt;表面法线+反射率-&gt;光强</code></p><p>图像是对场景的观测，观测结果收到几何位置（第三讲）和光强的影响（本讲）</p><p>相机辐射响应：由光强和传感器数值的函数关系。</p><p>线性非线性？场景的辐射度和传感器受到的辐照度是线性的。但是传感器对辐射转化为图像亮度的关系是非线性的。</p><p>相机的辐射响应曲线：图像亮度-辐照度的函数关系。低辐照度时，亮度会高于线性值。</p><p>如何反推原本的辐照度值？反函数，逆响应曲线。</p><p>如何得到逆响应曲线？</p><ul><li>标定法：已知反射率的灰度色块序列（如果认为相机的RGB三个辐射响应曲线相同（这是目前的常见情况）可以单纯用灰度色块标定；而更复杂的情况需要各种颜色的色块做标定。</li><li>没色卡怎么办！多曝光序列的自标定(Mitsunaga, CVPR 99) 用已知<code>曝光时间比</code>的内容一致的图像序列进行标定。利用静态场景不同曝光时间拍摄的一组照片进行标定。<ul><li>待求解的函数：辐照度E &#x3D; g(M)，M为光强，</li><li>将g用k次多项式拟合，k为？4-5阶</li><li>已知曝光时间的比值</li><li><strong>曝光时间比值等于场景辐照度的比值</strong>。</li><li>带入，待定系数，形成一个待优化的目标函数</li><li>利用端点(g(0)&#x3D;0;g(1)&#x3D;1)减少一个系数</li><li>用单调性约束</li><li>最小二乘法</li></ul></li></ul><ul><li>不用线性拟合？<ul><li>Grossberg CVPR 03</li><li>分析许多相机的辐射响应曲线，得到一个“主成分”分析</li><li>将主成分函数按不同比例结合，可以用很少的参数高精度地拟合辐射响应曲线</li></ul></li></ul><p>已经得到了线性的辐照度，如何拿来重建环境的光度？</p><ul><li>反射模型：漫反射、镜面反射</li><li>BRDF：双向反射率分布函数，值为给定入射光方向和反射光方向（一个方向用两个数据，故函数为4元），输出反射能量与入射能量的比值。</li><li>优化：在各向同性（具有旋转对称性），BRDF可简化为三元函数。</li></ul><p>一些难办的光传播现象：这些都不管了！</p><ul><li>折射</li><li>相互反射（光线的多次反射</li><li>次表面反射（树叶半透明</li></ul><p>理想漫反射：朗伯反射：BRDF为常数，反射率为常数。</p><p>光源？</p><ul><li>点光源：向所有方向发出同等强度光。</li><li>平行光源：</li><li>聚光灯：在锥内有光</li></ul><p>表面法线。</p><p>光度成像模型的定量描述：</p><p>L(w_r) &#x3D; 积分（环境光照 * BRDF * 表面法线) dw_i</p><p>简化：朗伯反射模型的平行光反射：好像是一个单项式，挺简单的。</p><p>学术前沿：</p><p>老师梳理了好几篇这方面的文章，主要关于重建场景的光照。并把这个光照信息应用于AR物品的光照渲染。</p>]]></content>
    
    
    <categories>
      
      <category>计算摄像学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算摄像学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算摄像学 第五讲 焦点堆栈与光场摄像</title>
    <link href="/posts/37162.html"/>
    <url>/posts/37162.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Focal Stack and Light Field</p><p>上节课的虚拟大光圈是基于“算法”的。直接得到的深度信息很有限。</p><p>本节课将介绍“物理”地方法，从场景中更直接地得到更多深度信息。</p><p>镜头成像：只有一个平面可以聚焦。</p><ul><li><p>如何得到各个深度都清晰的成像？</p><ul><li>快速拍多个不同聚焦平面的照片-&gt;焦点堆栈（Focal Stack Imaging）。</li><li>再得到一张全部对焦的图片（算法加工）（all-in-focus）</li></ul></li><li><p>如何捕获焦点堆栈照片？需要固定哪些参数，更改什么参数？</p><ul><li>更改镜头到传感器的距离S’！（Focal distence）</li><li>也可以更改镜头到物体的距离S</li></ul></li><li><p>如何得到最清晰的部分？（合成）</p><ol><li>图像对齐（Alignment&amp;registration）<ul><li>调整Focal distence时，视场FoV会有些微变化（参见第四讲），要进行一定地缩放调整。</li></ul></li><li>权重分配<ul><li>如何测量每个像素的清晰程度？<strong>这也是相机自动对焦的工作原理</strong></li><li>每个图像，清晰的地方给高权重</li></ul></li><li>加权平均<ul><li>对每个图像每个像素点进行加权平均。</li></ul></li></ol></li><li><p>注：相机自动对焦（主要通过提取边缘）</p><ul><li>做拉普拉斯算子（是一种差分）（可以起到提取边缘的作用）（也有其它提取边缘的方式）</li><li>再做高斯模糊（拉普拉斯算子对噪声比较敏感，模糊起到平滑作用，降噪）</li><li>还有主动对焦方式：比如ToF传感器</li></ul></li><li><p>在焦点堆栈过程中，我们事实上得到了一些深度信息。但是这个信息比较模糊。</p></li><li><p>学术前沿：利用对焦距离和光圈调整估计表面深度（高精度）</p><ul><li>不仅改变焦点距离、同时改变光圈</li><li>利用光圈和对焦距离两个信息得到尽可能真实的深度。</li></ul></li></ul><p>光场不同子集不同角度拍，得到真实光线的，可以还原场景光线的所有光线。</p><p>光场：所有光线的集合</p><p>光场表示方法: L(u,v,s,t)，uv表示光在透镜平面穿过的位置、st表示光在传感器平面穿过的位置。用uvst可以得到透镜到传感器之间的所有光线。</p><p>如何得到光场数据？</p><p>用相机阵列进行光场摄像 or 用一个相机移动进行拍摄</p><p>如何单次相机单次拍摄？</p><p>光场摄像。不让传感器精确聚焦，而是让聚焦的光重新散开（利用一个微透镜阵列），传感器可以得到更丰富的信息。</p><p>学术前沿：深度学习生成光场</p><p>学术前沿：神经辐射场NeRF</p>]]></content>
    
    
    <categories>
      
      <category>计算摄像学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算摄像学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象编程经验1——概论、模版类、构造函数、析构函数.</title>
    <link href="/posts/38043.html"/>
    <url>/posts/38043.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p><strong>警告⚠️本文章逻辑略混乱，请谨慎阅读。</strong></p></blockquote><p>如<a href="https://justaloli.cn/posts/46200.html">上一篇文章</a>所言, 接下来我将以我的双向链表为案例, 分享一些在C++进行类封装及面向对象编程时积累的经验. 本文主要涉及概论、构造函数和析构函数.</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>对象可以理解为现实世界的各个实体. 现实中的实体, 往往具有一些属性(比如物理属性、几何属性等等属性), 也往往具有一些操作或行为(比如猫会叫). </p><p>在面向对象编程时, 所有操作都是针对<strong>对象</strong>进行的. 可以和面向过程编程做出一些比较. 面向对象编程的主体是对象, 即实体; 面向过程编程的主体是过程, 即操作本身.</p><p>以猫猫叫这件事情为例. 面向对象关注的是对象, 即猫. 在面向对象编程中, 猫叫被形容为</p><p><code>猫-&gt;叫</code>, <code>Cat.meow()</code>, 表示是猫这个对象做出了某种行为, 重点在猫.</p><p>而在面向过程编程中, 猫叫被形容为</p><p><code>叫:猫</code>, <code>meow(Cat)</code>, 表示叫这个行为被执行了, 重点在叫这个动作.</p><p>可以看出, 面向对象的描述方式更符合人类的直观.</p><p>实体之间有相互关系. 最重要的关系是, 实体可以分类. 一<strong>类</strong>实体往往具有相似甚至相同的属性, 并且具备一些相同的行为. 比如所有的猫可以归为一<strong>类</strong>猫. </p><p>描述一类事物应当具有哪些属性和行为(更准确的说法是方法)的过程称作类的定义. 根据类的定义, 创建一个具体的对象的过程叫类的实例化. 类是抽象概念, 对象是具体概念. 这很符合人们的常识.</p><p>类之间也有相互关系, 比如包含(更准确的说法是继承), 引用等等. </p><p>类的属性和方法有权限之分. 有些属性和方法可以外人访问和调用, 而有些属性和方法只能内部访问和调用.</p><p>定义一个类有多种方式. 我们当然可以用自然语言定义类:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">手机<br>具有的属性:<br>长、宽、高<br>型号、品牌、……<br>具有的操作:<br>开机、拨号、上网、打开程序……<br></code></pre></td></tr></table></figure><p>类的定义在C++语言中可以描述为这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> height;<br><span class="hljs-comment">//...etc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//...etc</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模版类"><a href="#模版类" class="headerlink" title="模版类."></a>模版类.</h2><blockquote><p>注意:从下文开始, 笔者假定读者有基本的C++编程基础. 并且明白双向链表的工作原理.</p></blockquote><p>模版是C++的一个语法特性. 利用模版, 我们可以创建一个含有未定数据类型的成员的类. 从代码上讲, 一个双向链表的节点可以这样定义.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>T data<br>Node&lt;T&gt;* next;<br>Node&lt;T&gt;* prev;<br>&#125;<br><span class="hljs-comment">//到这里为止,是template &lt;typename T&gt;</span><br><span class="hljs-comment">//的作用范围.在这个作用范围内,T就指代了一个数据类型.</span><br><span class="hljs-comment">//这个数据类型在实例化Node类时才被明确.</span><br></code></pre></td></tr></table></figure><p>实例化Node类时,就需要明确模版T对应的具体类型,如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node&lt;<span class="hljs-type">int</span>&gt; n;<span class="hljs-comment">//创建对象</span><br></code></pre></td></tr></table></figure><p>由于双向链表内部需要创建Node,因此双向链表的list类也需要笼罩在一个模版下.故list的定义需要:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>...<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>Node&lt;T&gt;* head;<br>Node&lt;T&gt;* tail;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的,实例化list需要明确模版T对应的类型.如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; li;<br></code></pre></td></tr></table></figure><p><strong>Remark:</strong> 类也是类型.因此这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; li;<br></code></pre></td></tr></table></figure><p>是合法的.你不过是创建了一个类型T为<code>list&lt;int&gt;</code>的列表. </p><p>不过需要注意, <strong>应当确保传入的类型具有你对类型T进行的运算</strong>. 比如你在对类型T进行了加减法, 你就需要确保你传入的类型具有加减法. </p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数."></a>构造函数和析构函数.</h2><p>在对象创建时, 将执行构造函数; 在对象销毁时, 将执行析构函数.</p><p>对于普通的情况, 程序将生成默认的构造函数和析构函数. 不过有时候, 我们需要在创建和删除类的时候进行复杂的操作, 这时就不能依靠默认的构造和析构函数了. 我们要自己写.</p><p>构造函数是一个名称和类名称相同,不填写返回值的函数.析构函数是一个波浪线<code>~</code>+类名称,不填写返回值的函数. 它们的定义方式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>Node&lt;T&gt;* head;<br>Node&lt;T&gt;* tail;<br><span class="hljs-type">int</span> _size;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义构造函数.</span><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义析构函数.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数的实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//填写构造函数的具体内容</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;<br>head = <span class="hljs-keyword">new</span> node&lt;T&gt;;<br>tail = <span class="hljs-keyword">new</span> node&lt;T&gt;;<br><br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里, <code>list&lt;T&gt;::</code>代表这是list这个类的函数(方法). 描述类方法的方式有两种: 在类内部定义,在类外部定义. 个人喜欢外部定义. 在外部定义时,需要<code>list&lt;T&gt;::</code>以明确这是list类的方法.同时需要加上<code>template &lt;typename T&gt;</code></p><p>在构造函数中, 我们创建了head和tail两个节点, 并让head和tail首尾相接. 这之后,我们让存储链表长度的变量_size设置为0. 这样, 在实例化一个list时,这些指令会被执行,从而完成链表的初始化.</p><p>一般我们不需要重写析构函数.系统会自动释放类里面的所有内存.但是这是链表,还有许多节点零散地分配在内存空间中,你不能保证系统知道它们是相连地,然后帮你释放它们.所以我们要自己实现析构函数.</p><p>析构函数的实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br>node&lt;T&gt; *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先删除链表里的所有元素,最后删除头和尾. 由于在使用中, 我们偶尔也想清空链表,因此可以把清空链表的部分拿出来,单独作为一个函数(方法).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>...<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义构造函数.</span><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义析构函数.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//定义方法</span><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;...&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br>node&lt;T&gt; *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;temp = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>数算</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现一个尽可能优雅的双向链表</title>
    <link href="/posts/46200.html"/>
    <url>/posts/46200.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是「数据结构与算法」课程的一部分. 在这门课中, 我们将接触各种常见的数据结构, 并了解它们各种基本操作的实现方式.</p><p>这门课的第一章为顺序表, 其中包括一种数据结构“链表”. 我产生了一种想法, 为什么不借助C++强大的类封装能力, 实现一个自己的链表呢?</p><p>我的目标是想让这个链表尽可能的“优雅”. 这要求在使用这个链表时, 各种操作应尽可能的简洁直观. 我的目标是做的比C++ STL模版库的链表易用(虽然性能可能略低), 并且尽可能靠近python的列表.</p><blockquote><p>注意: STL模版库的list是双向链表,但python的list, 据资料, 是基于变长顺序表. 这里说的靠近不是利用python list的底层逻辑, 而是实现和python list尽可能相似的调用方式.</p></blockquote><h2 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h2><p>话不多说, 先看使用例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 本程序需要引用的外部库仅iostream */</span><br><br><span class="hljs-comment">/* 例子1 简单的添加数据、打印数据 */</span><br>list&lt;<span class="hljs-type">int</span>&gt; list1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>list1.<span class="hljs-built_in">append</span>(i);<br>&#125;<br>cout &lt;&lt; list1 &lt;&lt; endl;<br><br><span class="hljs-comment">/* 例子2 列表嵌套 */</span><br>list&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; list2;<br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt; templist;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j,++num)<br>&#123;<br>templist.<span class="hljs-built_in">append</span>(num);<br>&#125;<br>list2.<span class="hljs-built_in">append</span>(templist);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; list2[i].<span class="hljs-built_in">size</span>(); ++j)<br>&#123;<br>cout &lt;&lt; list2[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>1 <br>2 3 <br>4 5 6 <br>7 8 9 10 <br>11 12 13 14 15 <br>16 17 18 19 20 21 <br>22 23 24 25 26 27 28 <br>29 30 31 32 33 34 35 36 <br>37 38 39 40 41 42 43 44 45 <br>46 47 48 49 50 51 52 53 54 55 <br>程序执行完成, 用时63微秒.<br></code></pre></td></tr></table></figure><p>使用过python的人, 应该能看出我对python列表的借鉴(比如append()); 使用过C++ STL模版库的list的人, 应该能看出它比STL list在使用(尤其是遍历)上要简单一些.</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>列表的UML类图如下:</p><pre><code class=" mermaid">classDiagram class node&#123;+T data+node* next+node* prev&#125;class list&#123;-node* head-node* tail-int _size-node* temp-int tempindex+copy() list+slice(i1,i2,i3) list+size() int+append(data) int+insert(index,data) void+swap(i1,i2) void+pop(i=-1) T+remove(data) void+clear() void+operator[](index) T+operator=(data) list+operator+(data) list+operator+=(data) list#get(index) node*#swap(node,node) void&#125;</code></pre><p>用c++描述的类定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">node</span>()&#123;&#125;<br><span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> T&amp; dta)&#123;data = dta;&#125;<br>T data;<br>node* next=<span class="hljs-literal">nullptr</span>;<br>node* prev=<span class="hljs-literal">nullptr</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>node&lt;T&gt;* head;<br>node&lt;T&gt;* tail;<br><span class="hljs-type">int</span> _size;<br>node&lt;T&gt;* temp;<br><span class="hljs-type">int</span> tempindex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">list</span>();<span class="hljs-comment">/* 构造函数 */</span><br><span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 拷贝重载 */</span><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">/* 析构函数 */</span><br><span class="hljs-function">list&lt;T&gt; <span class="hljs-title">copy</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/* 复制 */</span><br><span class="hljs-function"><span class="hljs-type">const</span> list&lt;T&gt; <span class="hljs-title">slice</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">/* 切片 */</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> _size;&#125;<span class="hljs-comment">/* 得到长度 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> T)</span></span>;<span class="hljs-comment">/* 追加 */</span><br><span class="hljs-function">list&lt;T&gt;&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> T)</span></span>;<span class="hljs-comment">/* 插入 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">/* 交换 */</span><br><span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i=<span class="hljs-number">-1</span>)</span></span>;<span class="hljs-comment">/* 弹出并删除 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>;<span class="hljs-comment">/* 删除所有和参数相同的元素 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/* 清空 */</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span>);<span class="hljs-comment">/* 索引[]运算 */</span><br>list&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 赋值=运算 */</span><br>list&lt;T&gt; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 加+运算 */</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(list&lt;T&gt;&amp;);<span class="hljs-comment">/* 自增+=运算 */</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> T);<span class="hljs-comment">/* 自增+=运算 */</span><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-type">const</span> node&lt;T&gt;* <span class="hljs-title">gethead</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> head;&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> node&lt;T&gt;* <span class="hljs-title">gettail</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> tail;&#125;<br><span class="hljs-function">node&lt;T&gt;* <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<span class="hljs-comment">/* 索引，得到节点指针 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(node&lt;T&gt;*,node&lt;T&gt;*)</span></span>;<span class="hljs-comment">/* 交换 */</span><br><span class="hljs-function">node&lt;T&gt;* <span class="hljs-title">getFromHead</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">node&lt;T&gt;* <span class="hljs-title">getFromTail</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">node&lt;T&gt;* <span class="hljs-title">getFromTemp</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resetTemp</span><span class="hljs-params">()</span></span>&#123;temp=head;tempindex = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 重置temp指针保证它指向链中的某个项。 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;=b?a-b:b-a;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在完善这个数据类型的过程中, 遇到了很多有趣的问题, 也学习到了很多C++语法特性, 比如模版类、析构函数、运算符重载、引用符<code>&amp;</code>等等. 之后也许会慢慢整理遇到的各种问题以及经验.</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>这里只是放上完整代码. 之后有机会新建帖子进行相关的解释.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out,list&lt;T&gt;&amp; L)&#123;<br><span class="hljs-comment">/* 运算符：重载cout输出 */</span><br>out &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;out &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>&lt;&lt;L[i];&#125;<br><span class="hljs-keyword">else</span>&#123;out &lt;&lt; L[i];&#125;<br>&#125;<br>out &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T&amp; list&lt;T&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)&#123;<br><span class="hljs-comment">/* 运算符：索引 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(i)-&gt;data;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;&amp; list&lt;T&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> list&lt;T&gt; &amp;li)&#123;<br><span class="hljs-comment">/* 运算符：赋值 */</span><br><span class="hljs-built_in">clear</span>();<br>node&lt;T&gt;* t = li.head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=li.tail)&#123;<br><span class="hljs-built_in">append</span>(t-&gt;data);<br>t = t-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt; list&lt;T&gt;::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> list&lt;T&gt;&amp; li)&#123;<br><span class="hljs-keyword">auto</span> rl = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">copy</span>();<br><br>node&lt;T&gt;* t = li.head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=li.tail)&#123;<br>rl.<span class="hljs-built_in">append</span>(t-&gt;data);<br>t = t-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> rl;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-keyword">operator</span>+=(list&lt;T&gt;&amp; li)&#123;<br><span class="hljs-keyword">if</span>(&amp;li == <span class="hljs-keyword">this</span>)&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;ERROR: self += detected. plz use + instead.&quot;</span>;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* O1,但是引用的li会清空 */</span><br><span class="hljs-comment">/* 把中间接上 */</span><br>tail-&gt;prev-&gt;next = li.head-&gt;next;<br>li.head-&gt;next-&gt;prev = tail-&gt;prev;<br><span class="hljs-comment">/* 把结尾接上 */</span><br>tail-&gt;prev = li.tail-&gt;prev;<br>tail-&gt;prev-&gt;next = tail;<br><span class="hljs-comment">/* 更新size */</span><br>_size+=li.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">/* 让li首尾相接置空,但是不删除里面的元素(里面的元素归this了.) */</span><br>li.head-&gt;next = li.tail;<br>li.tail-&gt;prev = li.head;<br>li._size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> T dta)&#123;<br><span class="hljs-built_in">append</span>(dta);<br>&#125;<br><span class="hljs-comment">// list&lt;T&gt; list&lt;T&gt;::operator()(const int,const int,con s)&#123;&#125;</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt; list&lt;T&gt;::<span class="hljs-built_in">copy</span>()&#123;<br>list&lt;T&gt; returnlist;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _size; ++i)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br><span class="hljs-keyword">return</span> returnlist;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> list&lt;T&gt; list&lt;T&gt;::<span class="hljs-built_in">slice</span>(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> p3)&#123;<br>list&lt;T&gt; returnlist;<br><span class="hljs-keyword">if</span>(p3&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p1; i &lt; p2; i+=p3)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p3&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p1; i &gt; p2; i+=p3)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> returnlist;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;list() called&quot;&lt;&lt;endl;</span><br>head = <span class="hljs-keyword">new</span> node&lt;T&gt;;<br>tail = <span class="hljs-keyword">new</span> node&lt;T&gt;;<br><br><span class="hljs-built_in">resetTemp</span>();<br><br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list&lt;T&gt;&amp; li):<span class="hljs-built_in">list</span>()&#123;<br>(*<span class="hljs-keyword">this</span>) = li;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br>node&lt;T&gt; *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br><span class="hljs-built_in">resetTemp</span>();<br>_size=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;~list called for:&quot;&lt;&lt;*this&lt;&lt;endl;</span><br><span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;temp = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> list&lt;T&gt;::<span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> T dta)&#123;<br>temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>&lt;T&gt;(dta);<br>tempindex = _size;<br><br>tail-&gt;prev-&gt;next = temp;<br>temp-&gt;prev = tail-&gt;prev;<br>temp-&gt;next = tail;<br>tail-&gt;prev = temp;<br>_size++;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>node&lt;T&gt;* list&lt;T&gt;::<span class="hljs-built_in">get</span>(<span class="hljs-type">int</span> i)&#123;<br><span class="hljs-keyword">if</span>(i&gt;=_size||i&lt;-_size)&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;index out range&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//这是个无效值</span><br>&#125;<br><span class="hljs-type">int</span> mindis = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">int</span> minway = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i,<span class="hljs-number">0</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, <span class="hljs-number">0</span>);minway = <span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, -_size)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, -_size);minway = <span class="hljs-number">2</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, _size<span class="hljs-number">-1</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, _size<span class="hljs-number">-1</span>);minway = <span class="hljs-number">3</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, <span class="hljs-number">-1</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, <span class="hljs-number">-1</span>);minway = <span class="hljs-number">4</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i,tempindex)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i,tempindex);minway = <span class="hljs-number">5</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i+_size,tempindex)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i,tempindex);minway = <span class="hljs-number">6</span>;&#125;<br><span class="hljs-keyword">switch</span> (minway) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromHead</span>(i);<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromHead</span>(i+_size);<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTail</span>(i-_size);<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTail</span>(i);<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTemp</span>(i);<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTemp</span>(i+_size);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>node&lt;T&gt;* list&lt;T&gt;::<span class="hljs-built_in">getFromHead</span>(<span class="hljs-type">int</span> targeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFH called\n&quot;);</span><br>temp = head-&gt;next;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i!=targeti)&#123;<br>temp = temp-&gt;next;<br>i++;<br>&#125;<br>tempindex = targeti;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>node&lt;T&gt;* list&lt;T&gt;::<span class="hljs-built_in">getFromTail</span>(<span class="hljs-type">int</span> negativeTargeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFT called\n&quot;);</span><br>temp = tail-&gt;prev;<br><span class="hljs-type">int</span> i=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i!=negativeTargeti)&#123;<br>temp = temp-&gt;prev;<br>i--;<br>&#125;<br>tempindex = negativeTargeti+_size;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>node&lt;T&gt;* list&lt;T&gt;::<span class="hljs-built_in">getFromTemp</span>(<span class="hljs-type">int</span> targeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFTMP called\n&quot;);</span><br><span class="hljs-keyword">while</span>(targeti&gt;tempindex)<br>&#123;<br>temp = temp-&gt;next;<br>tempindex++;<br>&#125;<br><span class="hljs-keyword">while</span>(targeti&lt;tempindex)&#123;<br>temp = temp-&gt;prev;<br>tempindex--;<br>&#125;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">swap</span>(<span class="hljs-type">int</span> ia,<span class="hljs-type">int</span> ib)&#123;<br>node&lt;T&gt;* a = <span class="hljs-built_in">get</span>(ia);<br>node&lt;T&gt;* b = <span class="hljs-built_in">get</span>(ib);<br><span class="hljs-built_in">swap</span>(a,b);<br>tempindex = ia;<span class="hljs-comment">//temp指向b,b的下标变为了ia.</span><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">swap</span>(node&lt;T&gt; *a,node&lt;T&gt; *b)&#123;<br>node&lt;T&gt; *anext = a-&gt;next;<br>node&lt;T&gt; *bnext = b-&gt;next;<br>node&lt;T&gt; *aprev = a-&gt;prev;<br>node&lt;T&gt; *bprev = b-&gt;prev;<br><span class="hljs-keyword">if</span>(a-&gt;next==b)&#123;<br>b-&gt;prev = aprev;<br>a-&gt;next = bnext;<br>b-&gt;next = a;<br>a-&gt;prev = b;<br>bnext-&gt;prev = a;<br>aprev-&gt;next = b;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a-&gt;prev==b)&#123;<br>b-&gt;next = anext;<br>a-&gt;prev = bprev;<br>a-&gt;next = b;<br>b-&gt;prev = a;<br>anext-&gt;prev = b;<br>bprev-&gt;next = a;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>a-&gt;next = bnext;<br>b-&gt;next = anext;<br>a-&gt;prev = bprev;<br>b-&gt;prev = aprev;<br>anext-&gt;prev = b;<br>aprev-&gt;next = b;<br>bnext-&gt;prev = a;<br>bprev-&gt;next = a;<br>&#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;&amp; list&lt;T&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> T value)&#123;<br>node&lt;T&gt; *t;<br><span class="hljs-keyword">if</span>(i&gt;=_size)&#123;<br><span class="hljs-comment">//如果用户做了这样的输入，多半是想插入到末尾，而不是在最后一个位置的前面插入。故直接调用append</span><br><span class="hljs-built_in">append</span>(value);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(i&lt;-_size)&#123;<br>i = <span class="hljs-number">0</span>;<br>&#125;<br>t = <span class="hljs-built_in">get</span>(i);<br><span class="hljs-keyword">if</span>(!t)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>&lt;T&gt;(value);<br>t-&gt;prev-&gt;next = temp;<br>temp-&gt;prev = t-&gt;prev;<br>temp-&gt;next = t;<br>t-&gt;prev = temp;<br>_size++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T list&lt;T&gt;::<span class="hljs-built_in">pop</span>(<span class="hljs-type">int</span> i)&#123;<br>node&lt;T&gt; *t = <span class="hljs-built_in">get</span>(i);<br>t-&gt;prev-&gt;next = t-&gt;next;<br>t-&gt;next-&gt;prev = t-&gt;prev;<br><br>T dta = t-&gt;data;<br><br>temp = t-&gt;next;<span class="hljs-comment">//删除元素时，要把那个指向链表中间的temp指针指到一个在链上的节点。</span><br>_size--;<br><span class="hljs-keyword">delete</span> t;<br><span class="hljs-keyword">return</span> dta;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> T&amp; target)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _size;)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(i)-&gt;data==target)&#123;<br><span class="hljs-built_in">pop</span>(i);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>i++;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>数算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算摄像学 第四讲 镜头 曝光 对焦</title>
    <link href="/posts/29774.html"/>
    <url>/posts/29774.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><p>上节课复习：相机几何模型：场景和光学镜头之间的计算。</p></li><li><p>本节课：</p></li></ul><p>我能看多远（长焦、焦距）？我能看多广（广角、视场）？我能清晰地看多深（大光圈、大景深）？</p><ul><li>薄透镜成像</li></ul><p>注意：只有某个平面上的光会被清晰对焦。其它深度的物体处于失焦状态。光源将形成一个模糊圈（一个模糊的圆形）</p><p><strong>理想薄透镜不存在。现实上使用多个透镜的透镜组近似薄透镜的性质，而不是用单独的凸透镜成像。</strong></p><ul><li><p>像差：真实成像和理想的薄透镜成像的差距。比如：色差；单色像差（也称散光）</p></li><li><p>视场：通过镜头能观察到的高度、宽度（FoV）</p></li></ul><p>可以用薄透镜成像模型，通过相似三角形原理计算视场角。和焦距、传感器大小有关，呈arctan的变化。</p><ol><li><p>视场和对焦距离有关：降低对焦距离，视场减小</p></li><li><p>视场和焦距的关系：增加焦距，视场减小。</p></li></ol><p>Remark: 注意区分对焦距离（focus distence，改变镜头组到传感器的距离）和焦距(focal lens，改变镜片的光学性质)！</p><p><em>增加焦距的效果和画面裁切有类似。</em> 但是二者有区别！透视投影关系不同。</p><ol start="3"><li>视场和传感器大小的关系：画幅越大视场越大。</li></ol><p>全画幅（35mm）、中画幅（中画幅比全画幅大，中画幅是全画幅出现之前的标准44x33mm）、APS、……</p><p>fun fact：哈勃望远镜的焦距57.6m</p><ul><li>定焦镜头&amp;变焦镜头？</li></ul><p>定&amp;变的是焦距(focal lens)，对焦距离（focus distence）都能变。</p><ul><li>其它镜头：微距镜头，消除色差镜头，非球面镜，……</li></ul><h2 id="曝光Exposure"><a href="#曝光Exposure" class="headerlink" title="曝光Exposure"></a>曝光Exposure</h2><ul><li>快门速度(Shutter Speed)</li></ul><p>慢快门会让快速运动的物体变模糊(motion blur，动态模糊)。有一些去除动态模糊的算法。</p><p>快门的效果也可以利用：如拍摄星轨、延时摄影。</p><ul><li>光圈(Aperture)</li></ul><p>f-number 是焦距&#x2F;光圈口径的比值。数值越小，光圈越大。</p><p>例：50mm的镜头，光圈1.4, 光圈口径为50&#x2F;1.4 &#x3D; 36mm.</p><p>此外，可以用相似原理得到，模糊圈大小和光圈口径有关。光圈</p><p>大光圈会带来景深（Depth of Field, DoF）效果。大光圈，景深变浅。景深：图片看起来清晰的范围。</p><p>大光圈、浅景深带来虚化(bokeh,日语词)效果。</p><p>fun fact: 模糊圈和光圈形状有关。可以改变开口形状达到独特效果。</p><ul><li>镜头“速度”</li></ul><p>它指代了镜头的最大光圈。光圈大，快门快的时候也能得到足够进光的图像。因此认为镜头的“速度”快。它是(最大)光圈大小的描述。</p><ul><li>感光度(ISO)</li></ul><p>参见第二讲的内容。模拟前端的放大器将模拟电压进行放大，放大倍数就是iso！</p><h2 id="相机模式"><a href="#相机模式" class="headerlink" title="相机模式"></a>相机模式</h2><p>Auto、A、S、M、</p><h2 id="产业应用、学术前沿"><a href="#产业应用、学术前沿" class="headerlink" title="产业应用、学术前沿"></a>产业应用、学术前沿</h2><p>估计场景深度-&gt;加模糊效果</p><p>准确的算出深度是一件困难的事情。曾经，手机的双摄被用来估计场景深度；也有一些“双像素”技术，用于把前景扣出来。</p><ul><li>双像素技术：</li></ul><p>将一部分像素一分为二，配置独立的光电二极管用于成像。相当于两个间距极小的镜头拍摄的照片，可以用来得到深度信息。</p><p>现在还有用神经网络渲染大光圈的效果，不用传统的方式加模糊。</p><ul><li><p>神经网络的图像去模糊-&gt;重新再模糊，实现后期重对焦。</p></li><li><p>双像素去模糊</p></li><li><p>无镜头成像</p></li></ul><p>场景-&gt;某种调制膜mask-&gt;传感器得到图片-&gt;算法重建</p><p>mask可以对入射光进行光学上的编码，让传感器得到的数据可以被解码分析。</p><ul><li>不可见到可见</li></ul><p>拍一个墙，通过计算让墙成为“镜子”，得到一般看不到的物体。</p>]]></content>
    
    
    <categories>
      
      <category>计算摄像学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算摄像学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算摄像学 第三讲 相机几何模型</title>
    <link href="/posts/62008.html"/>
    <url>/posts/62008.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>回顾计算摄像</p><p>计算摄像：通过计算从照片中获取更多信息。</p><p>在多个环节可以引入计算：</p><ol><li>场景和光学镜头之间的计算</li><li>传感器上对光信号的计算</li><li>传感器到图像之间的计算</li></ol><h2 id="引言：相机想知道的东西"><a href="#引言：相机想知道的东西" class="headerlink" title="引言：相机想知道的东西"></a>引言：相机想知道的东西</h2><ol><li>我在哪里——相机的空间位置</li><li>我看到的世界——相机看到的物体的空间位置</li></ol><h2 id="裸传感器成像"><a href="#裸传感器成像" class="headerlink" title="裸传感器成像"></a>裸传感器成像</h2><p>空间每个点的漫反射光都被传感器每个像素点接收——几乎无法成像。</p><h2 id="针孔相机成像"><a href="#针孔相机成像" class="headerlink" title="针孔相机成像"></a>针孔相机成像</h2><p>针孔对光线路径做出了选择，可以得到一个倒像。</p><p>相机术语：</p><ul><li>投影中心：即小孔位置</li><li>光圈：即小孔</li><li>焦距（遮光板到传感器的距离）</li></ul><p>改变焦距，传感器上的成像大小会改变。</p><p>针孔相机的问题：孔大导致模糊；孔小导致光强小，且带来衍射问题。</p><p>进光效率：孔直径大，进光大；焦距短，接收光的效果好</p><p>档：（f值）：焦距除以针孔直径。</p><p><strong>针孔相机的成像模型可以帮助理解现代相机。</strong></p><h2 id="相机矩阵：三维到二维的坐标变换"><a href="#相机矩阵：三维到二维的坐标变换" class="headerlink" title="相机矩阵：三维到二维的坐标变换"></a>相机矩阵：三维到二维的坐标变换</h2><p>用于解释开头的两个问题。</p><p>一些数学</p><p><img src="/posts/62008/%E7%9B%B8%E6%9C%BA%E7%9F%A9%E9%98%B5.png" alt="相机将三维世界的坐标（大X）通过线性变换转化为二维大图像坐标（小x的前两个分量）"></p><p>x &#x3D; f X&#x2F;Z; y &#x3D; f Y&#x2F;Z</p><p>P &#x3D; K[R|t]X, P(x,y,z)’ 为相机上的图像坐标，K(3 * 3)为内参矩阵，R(3 * 3)为相机在世界坐标系的旋转，t(3 * 1)为相机坐标系在世界坐标系中的平移，X为物体在世界的坐标(X,Y,Z,1)’ </p><p><strong>外参矩阵蕴含了相机在空间的平移和旋转；内参矩阵蕴含了相机将外界投影到照片的方式。二者分别回答“我在哪里”和“我眼中的世界”的问题</strong></p><h3 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h3><p>让景物变大：增加焦距？减小物体到针孔的距离？效果不同！</p><p>应用：“眩晕效果（滑动变焦）”，固定前景的大小，同时改变焦距和物体距离，制造景深的变化。</p><p>极端情况：正交投影：超级超级超级长焦，深度对大小不影响。（常见于游戏。</p><h2 id="相机几何标定"><a href="#相机几何标定" class="headerlink" title="相机几何标定"></a>相机几何标定</h2><h3 id="三维匹配点标定法"><a href="#三维匹配点标定法" class="headerlink" title="三维匹配点标定法"></a>三维匹配点标定法</h3><p>利用一些已知的三维空间点-相机图像坐标的对应关系，推知整个相机矩阵。</p><p>再利用算出的矩阵分析焦距、中心点等参数（得到一个上三角矩阵和正交矩阵，分别是相机的内部参数和外部坐标旋转）。</p><h3 id="非线性优化算法，处理类似畸变问题"><a href="#非线性优化算法，处理类似畸变问题" class="headerlink" title="非线性优化算法，处理类似畸变问题"></a>非线性优化算法，处理类似畸变问题</h3><h3 id="多图棋盘格标定法"><a href="#多图棋盘格标定法" class="headerlink" title="多图棋盘格标定法"></a>多图棋盘格标定法</h3><p>已经很成熟。</p><h2 id="学术前沿"><a href="#学术前沿" class="headerlink" title="学术前沿"></a>学术前沿</h2><ol><li>大规模的相机几何标定</li><li>利用深度学习进行相机几何标定</li><li>利用图像的“消失点”“消失线”进行几何标定</li><li>从镜面反射进行几何标定</li><li>……</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算摄像学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算摄像学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日无用英语——杂货铺的正确翻译</title>
    <link href="/posts/14140.html"/>
    <url>/posts/14140.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>背单词软件常常将<em>grocery</em>翻译为杂货铺，以至于我很长时间认为杂货铺的翻译是<em>grocery</em>。</p><p>但深究杂货铺和<em>grocery</em>的含义，这种翻译大概是错误的。且看二者的词典释义：</p><blockquote><p>杂货（zá huò）（杂货铺词条在我的大辞海上找不到）<strong>各种日用</strong>的<strong>零星货物</strong>。如:杂货铺; 日用杂货。《醒世恒言·卖油郎独占花魁》: “一应麦豆茶酒油盐杂货, 无所不备。”<br>出处：语词卷</p></blockquote><blockquote><p>grocery &#x2F;ˈɡrəʊsəri; NAmE ˈɡroʊsəri’&#x2F;NOUN ( plural groceries )1.(especially BrE)(NAmE usually ˈgrocery store’) [countable] a shop&#x2F;store that sells <strong>food and other things</strong> used in the home. In American English ‘grocery store’is often used to mean <strong>‘supermarket’</strong>. <strong>食品</strong>杂货店（在美式英语中 grocery store 常用以指 supermarket）2.groceries [plural] <strong>food and other goods</strong> sold by a groceror at a supermarket食品杂货</p></blockquote><p>可以注意到grocery明确有“食品“的含义，而中文语境中的杂货铺，大概很少和食物联系上。此外，中文语境中的杂货铺大概是贩卖“小零碎”的低调存在，而反观grocery store，在美国甚至指supermarket，是一种高调的存在。</p><p>更直观的说，这是“杂货铺”的百度图片搜索结果：</p><p><img src="/posts/14140/%E6%9D%82%E8%B4%A7%E9%93%BA%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87.jpeg" alt="能看到几乎与食品无关，且店面偏小"></p><p>而这是grocery的Google图片搜索结果：</p><p><img src="/posts/14140/grocerygooglephoto.jpeg" alt="能看到几乎与完全是食品，且店面类似超市"></p><p>故二者词义差距很大，将杂货铺译成grocery是很不当的。</p><h2 id="杂货铺的良好翻译？"><a href="#杂货铺的良好翻译？" class="headerlink" title="杂货铺的良好翻译？"></a>杂货铺的良好翻译？</h2><p><strong>junk store</strong> 可能是杂货铺的一个较为良好的翻译。junk store直译是旧货店，而旧货店和杂货铺可能有一些重合的区域。</p><p>至少，junk store和杂货铺的重合范围一定比grocery和杂货铺的重合范围大。</p><p>这一点也可以从图片搜索结果中体现：</p><p><img src="/posts/14140/junkstoregooglephoto.jpeg" alt="junk store的google搜索结果。至少有了中文“杂货铺”的意境"></p><p><em><strong>因此在翻译“杂货铺”时，可以尝试翻译为junk store。</strong></em></p><p>这篇文章就到这里～</p>]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>英语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地图着色问题</title>
    <link href="/posts/32813.html"/>
    <url>/posts/32813.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题：地图着色问题"><a href="#问题：地图着色问题" class="headerlink" title="问题：地图着色问题"></a>问题：地图着色问题</h2><p>问题简介：将一个图分成几部分，使得对于每一个部分，其中的节点互相不连接。</p><p>问题理解：这种问题往往有多种划分方式，即有多个解。可以采用贪心法找到其中的某一个解，或者使用回溯法遍历所有的可能解。</p><h2 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h2><ul><li><p>程序实现的数据结构：图（用于存储节点之间的网状关系），集合（用于存储划分中的每个部分），由集合构成的顺序表（用于存储划分），字符串，字符串构成的顺序表（用于存储节点的名字）。</p></li><li><p>各数据结构的UML图：</p></li></ul><pre><code class=" mermaid">classDiagram    class string&#123;    -char* str        +fprint(FILE*) Void        +operator=(char*) Void        +operator==(string) Bool    &#125;    class graph&#123;    -int nodeCount    +initgraph() Void    +islinked(int,int) Bool    &#125;    class set&#123;    -int size    -bool* setarray    +add() Void    +remove() Void    +isempty() Bool    +begin() iterator    +end() iterator    &#125;    class iterator&#123;    &lt;&lt;enumeration&gt;&gt;    -int pos    -set* fatherset    +operator*(): Int    +operator++()    +next(): iterator    &#125;</code></pre><ul><li><p>算法：实现了贪心法 <strong>及</strong> 回溯法。仅上交回溯法的代码。</p></li><li><p>环境：g++ -std&#x3D;c++11; MacOS，arm64</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>收获：回顾了计算概论的内容。学习了图在计算机中的存储。复习了c++中类的写法。</p><p>问题与解决办法：</p><ul><li>问题：集合中元素的遍历。由于集合元素的存储方式，元素的存储位置在内存中可能是分立的，给集合的遍历带来困难。</li><li>查阅资料，实现了一个集合的迭代器，封装了集合的遍历过程。</li></ul><p>不足：搜索效率不高。</p><h2 id="输入输出："><a href="#输入输出：" class="headerlink" title="输入输出："></a>输入输出：</h2><p>输入为<code>filei.txt</code>，包含：</p><p>一个整数N，代表节点个数；N个字符串，代表每个节点的名字；一个N * N的矩阵，每个数是0或1。<code>a[i][j]=1</code>代表节点i和j相连。</p><p>输出为<code>fileo.txt</code>，包含：</p><p>所有可能的分划，以及可能的分划总数，以及最少的分划数。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 地图着色问题 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 20</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-comment">/* 类定义：字符串 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-type">char</span> str[MAXLEN] = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：打印字符串 */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,str);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fprint</span><span class="hljs-params">(FILE *fp)</span></span>&#123;<br><span class="hljs-comment">/* 操作：打印字符串 */</span><br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;%s &quot;</span>,str);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> s[])&#123;<br><span class="hljs-comment">/* 操作：字符串赋值 */</span><br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &lt; s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; i&lt;MAXLEN ; ++i)<br>&#123;<br>str[i] = s[i];<br>&#125;<br>str[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> string s)&#123;<br><span class="hljs-comment">/* 操作：字符串比较是否相等 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXLEN; ++i)<br>&#123;<br><span class="hljs-keyword">if</span>(str[i]!=s.str[i])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> <span class="hljs-type">char</span> s[])&#123;<br>string ts;ts = s;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>==ts;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span>&#123;<br><span class="hljs-comment">/* 类定义：图 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-comment">/* 逻辑关系：网状结构 */</span><br><span class="hljs-type">int</span> grapharr[MAXLEN][MAXLEN]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/* 构造函数，填入图的节点数 */</span><br><span class="hljs-built_in">graph</span>(<span class="hljs-type">int</span> nn)&#123;n=nn;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initgraph</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 初始化函数，读入图的数据 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;grapharr[i][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initgraph</span><span class="hljs-params">(FILE *fp)</span></span>&#123;<br><span class="hljs-comment">/* 初始化函数，读入图的数据 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>&#123;<br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%d&quot;</span>,&amp;grapharr[i][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/* 操作：判断两个节点是否连接上 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">islinked</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> grapharr[a][b];&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">set</span>&#123;<br><span class="hljs-comment">/* 类定义：集合 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 逻辑关系：集合；但是在内部实现时，利用了元素的线性结构 */</span><br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> setarray[MAXLEN] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：添加元素 */</span><br><span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;MAXLEN &amp;&amp; <span class="hljs-keyword">not</span> <span class="hljs-built_in">isexist</span>(i))&#123;<br>setarray[i] = <span class="hljs-literal">true</span>;<br>size++;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：删除元素 */</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isexist</span>(i))&#123;<br>setarray[i] = <span class="hljs-literal">false</span>;<br>size--;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> !size;&#125;<span class="hljs-comment">/* 判断集合是否为空 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isexist</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 判断元素是否存在 */</span><br><span class="hljs-keyword">return</span> i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;MAXLEN &amp;&amp; setarray[i];<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span>&#123;<br><span class="hljs-comment">/* 类定义：集合的迭代器，用于遍历集合的所有元素 */</span><br><span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<br>set* fatherset = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">iterator</span>(set* ptr,<span class="hljs-type">int</span> n)&#123;<br><span class="hljs-comment">/* 构造函数：给定一个指定位置 */</span><br>pos = n<span class="hljs-number">-1</span>;<br>fatherset = ptr;<br>(*<span class="hljs-keyword">this</span>)++;<br>&#125;<br><span class="hljs-built_in">iterator</span>(set* ptr)&#123;<br><span class="hljs-comment">/* 构造函数：定在初始位置 */</span><br>pos = <span class="hljs-number">-1</span>;<br>fatherset = ptr;<br>(*<span class="hljs-keyword">this</span>)++;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++()&#123;<br><span class="hljs-comment">/* 操作：自增 */</span><br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">while</span>(fatherset-&gt;setarray[pos]==<span class="hljs-number">0</span>)&#123;<br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> k)&#123;<br><span class="hljs-comment">/* 操作：自增 */</span><br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">while</span>(fatherset-&gt;setarray[pos]==<span class="hljs-number">0</span>)&#123;<br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>*()<span class="hljs-type">const</span>&#123;<br><span class="hljs-comment">/* 操作：取值 */</span><br><span class="hljs-keyword">return</span> pos;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; it)&#123;<br><span class="hljs-comment">/* 运算：是否不等 */</span><br><span class="hljs-keyword">return</span> it.pos!=pos;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> iterator&amp; it)&#123;<br><span class="hljs-comment">/* 运算：是否相等 */</span><br><span class="hljs-keyword">return</span> it.pos==pos;<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(fatherset,pos+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向首个元素的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向首个元素的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向末尾的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>,MAXLEN);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isunrelated</span><span class="hljs-params">(set targetset,graph g,<span class="hljs-type">int</span> node)</span></span>&#123;<br><span class="hljs-comment">/* 判断图 g 上的 node 节点是否与 targetset 里面的所有节点都不相连 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = targetset.<span class="hljs-built_in">begin</span>();i!=targetset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span>(g.<span class="hljs-built_in">islinked</span>(*i, node))&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printtempset</span><span class="hljs-params">(set tset,string i2s[MAXLEN])</span></span>&#123;<br><span class="hljs-comment">/* 将tset里面的元素对应的string全部打印。元素和字符串的对应关系存储在i2s[]中 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = tset.<span class="hljs-built_in">begin</span>();i!=tset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br>i2s[*i].<span class="hljs-built_in">print</span>();<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fprinttempset</span><span class="hljs-params">(FILE *fp,set tset,string i2s[MAXLEN])</span></span>&#123;<br><span class="hljs-comment">/* 将tset里面的元素对应的string全部打印。元素和字符串的对应关系存储在i2s[]中 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = tset.<span class="hljs-built_in">begin</span>();i!=tset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br>i2s[*i].<span class="hljs-built_in">fprint</span>(fp);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 节点数 */</span><br><span class="hljs-type">int</span> N=<span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 用一个顺序表存储所有数字元素对应的节点名称 */</span><br>string indexToString[MAXLEN];<br>graph *mygraph;<br>set leftset;<br>set groupsets[<span class="hljs-number">20</span>];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">loaddatafromfile</span><span class="hljs-params">(<span class="hljs-type">char</span> fpath[])</span></span>&#123;<br>FILE *fp;<br>fp = <span class="hljs-built_in">fopen</span>(fpath,<span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span>(fp==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br><span class="hljs-comment">/* 录入节点数 */</span><br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br><span class="hljs-comment">/* 录入所有名称 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>&#123;<br><span class="hljs-type">char</span> ts[MAXLEN]=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%s&quot;</span>,ts);<br>indexToString[i] = ts;<br>&#125;<br><span class="hljs-comment">/* 实例化、初始化图 */</span><br>mygraph = <span class="hljs-keyword">new</span> <span class="hljs-built_in">graph</span>(N);<br>mygraph-&gt;<span class="hljs-built_in">initgraph</span>(fp);<br><br><span class="hljs-built_in">fclose</span>(fp);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = groupsets[i].<span class="hljs-built_in">begin</span>(); j != groupsets[i].<span class="hljs-built_in">end</span>(); j++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> <span class="hljs-built_in">isunrelated</span>(groupsets[i],*mygraph,*j))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> shortestgroupnum = MAXLEN;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(FILE *fp,<span class="hljs-type">int</span> currentgroupnum, set::iterator currentanalyzenode)</span></span>&#123;<br><span class="hljs-comment">/* fp:写入结果的文件指针，currentgroupnum：目前有的分划数，</span><br><span class="hljs-comment">currentanalyzenode：目前要处理的节点 */</span><br><span class="hljs-keyword">if</span>(currentgroupnum&gt;<span class="hljs-number">4</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(currentanalyzenode == leftset.<span class="hljs-built_in">end</span>())&#123;<br><span class="hljs-comment">/* 完成了一次分划，输出分划结果 */</span><br><span class="hljs-keyword">if</span>(currentgroupnum &lt; shortestgroupnum)&#123;<br>shortestgroupnum = currentgroupnum;<br>&#125;<br>count++;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;第%d个结果:\n&quot;</span>,count);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentgroupnum; i++)<br>&#123;<br><span class="hljs-built_in">fprinttempset</span>(fp,groupsets[i],indexToString);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;校验结果：%s\n&quot;</span>,<span class="hljs-built_in">check</span>()?<span class="hljs-string">&quot;正确&quot;</span>:<span class="hljs-string">&quot;错误&quot;</span>);<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 带回溯的将当前节点放置到所有可能的分划中，包括已有的分划和放入一个新分划 */</span><br>set::iterator i = currentanalyzenode;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;currentgroupnum;j++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isunrelated</span>(groupsets[j],*mygraph , *i))&#123;<br>groupsets[j].<span class="hljs-built_in">add</span>(*i);<br>leftset.<span class="hljs-built_in">remove</span>(*i);<br><span class="hljs-comment">/* 放入已有的分划，向下搜索 */</span><br><span class="hljs-built_in">search</span>(fp,currentgroupnum,i.<span class="hljs-built_in">next</span>());<br><span class="hljs-comment">/* 回溯 */</span><br>groupsets[j].<span class="hljs-built_in">remove</span>(*i);<br>leftset.<span class="hljs-built_in">add</span>(*i);<br>&#125;<br>&#125;<br>groupsets[currentgroupnum].<span class="hljs-built_in">add</span>(*i);<br>leftset.<span class="hljs-built_in">remove</span>(*i);<br><span class="hljs-comment">/* 放入一个新分划，向下搜索 */</span><br><span class="hljs-built_in">search</span>(fp,currentgroupnum+<span class="hljs-number">1</span>,i.<span class="hljs-built_in">next</span>());<br><span class="hljs-comment">/* 回溯 */</span><br>groupsets[currentgroupnum].<span class="hljs-built_in">remove</span>(*i);<br>leftset.<span class="hljs-built_in">add</span>(*i);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mymain</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 实例化、初始化集合 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>&#123;<br>leftset.<span class="hljs-built_in">add</span>(i);<br>&#125;<br><br>FILE *fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;fileo.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-keyword">if</span>(fp==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><span class="hljs-comment">/* 搜索 */</span><br><span class="hljs-built_in">search</span>(fp,<span class="hljs-number">0</span>,leftset.<span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">/* 结果 */</span><br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;搜索完成，共%d个结果\n&quot;</span>, count);<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;最少分划个数为：%d&quot;</span>, shortestgroupnum);<br><br><span class="hljs-built_in">fclose</span>(fp);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">char</span> path[] = <span class="hljs-string">&quot;filei.txt&quot;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">loaddatafromfile</span>(path))<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">mymain</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算摄像学 第二讲 数字摄像流程</title>
    <link href="/posts/23312.html"/>
    <url>/posts/23312.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="第二讲-数字摄像流程（Digital-Photography-Pipeline"><a href="#第二讲-数字摄像流程（Digital-Photography-Pipeline" class="headerlink" title="第二讲 数字摄像流程（Digital Photography Pipeline"></a>第二讲 数字摄像流程（Digital Photography Pipeline</h2><!-- ISP --><p>参考书：</p><ol><li><a href="http://szeliski.org/book">http://szeliski.org/book</a> 《Computer Vision: Algorithms and Applications, 2nd ed.》</li><li><a href="https://imagingtext.github.io/">https://imagingtext.github.io</a> 《Computational Imaging》</li><li><a href="https://link.springer.com/referencework/10.1007/978-3-030-63416-2">https://link.springer.com/referencework/10.1007/978-3-030-63416-2</a> 第二版</li></ol><p>计算摄像的三个处理位置：成像之前，成像，成像之后</p><p>本课内容：</p><ul><li>图像传感器</li><li>模拟前端</li><li>颜色滤波</li><li>-&gt;</li><li>相机内部的图像处理（ISP</li></ul><!-- 视频：手机和相机的拍照对比，好机友姜唯。 --><h3 id="图像传感器-Imaging-Sensor"><a href="#图像传感器-Imaging-Sensor" class="headerlink" title="图像传感器 Imaging Sensor"></a>图像传感器 Imaging Sensor</h3><p>拍照：快门打开-&gt;传感器接收光子、储存光子-&gt;快门关闭，曝光结束-&gt;将光子转化成数字信号处理。</p><p>核心的感光组件：光电二极管（产生电子）、势井（存储电子）。</p><p>衡量光电二极管的一个指标：QE &#x3D; 光子量&#x2F;电子量</p><p>过曝：光子过多，势井饱和；欠曝：光子过少，随机性太高。除此以外的情况，电子数基本上<strong>线性的反映光子数</strong>。</p><p>两种图像传感器的芯片：CCD &amp; CMOS</p><table><thead><tr><th>CCD</th><th>CMOS</th></tr></thead><tbody><tr><td>更高感光度</td><td>更快读出</td></tr><tr><td>更低噪声</td><td>更低成本</td></tr></tbody></table><p>目前CMOS已经能达到接近CCD的性能。</p><h3 id="模拟前端"><a href="#模拟前端" class="headerlink" title="模拟前端"></a>模拟前端</h3><p>将传感器得到的光子（电压，模拟信号）转化为数字信号</p><p>电压-&gt;「模拟放大器」-&gt;模拟电压-&gt;「模数转换器」-&gt;数字信号-&gt;「编码」-&gt;数字信号</p><blockquote><p>fun fact: ISO调整的是「模拟放大器」的强度。</p></blockquote><h3 id="颜色滤波器"><a href="#颜色滤波器" class="headerlink" title="颜色滤波器"></a>颜色滤波器</h3><p>可见光：400-700nm波长</p><p>大多数光源含有不止一种波长的光。</p><p>不同的光谱频率分布可以产生类似或者相同的颜色感知。</p><p>色温。</p><p>感光器的响应值受到光源的频谱和传感器对不同频率的接收能力影响。</p><p>人眼细胞分别对RGB三个颜色的接收能力最强。颜色滤波器在设计时参考了人眼。</p><p>滤波器在传感器上的分布？拜耳阵列（RGGB</p><p>为什么要更多绿色？简而言之，研究认为人眼对绿色更敏感。</p><p>颜色滤波没有标准答案。滤波会带来颜色风格的细微差异。</p><h3 id="相机内部对图像的处理（ISP"><a href="#相机内部对图像的处理（ISP" class="headerlink" title="相机内部对图像的处理（ISP"></a>相机内部对图像的处理（ISP</h3><p>ISP: Image Singal Processor: 广义的指将原始图像转换为“正常”图像的一系列图像处理操作。</p><p>白平衡；去马赛克；降噪；色调再现；压缩；etc。</p><h4 id="白平衡-White-Balance-WB"><a href="#白平衡-White-Balance-WB" class="headerlink" title="白平衡 White Balance WB"></a>白平衡 White Balance WB</h4><ul><li>人眼可以在不同光照环境下正确感知“白色是白色”。</li></ul><p>白平衡：不管在任何光源下，都能将白色物体还原成白色，用于校准色温的偏差。</p><p>方法：</p><ol><li>手动白平衡：手动确定某个点，某个物体是白色。</li><li>预设白平衡：预设一些光源条件下的色温</li></ol><p>经典的自动白平衡算法：</p><p>利用白平衡的特性：全局偏差，让全局RGB分别的统计值变成相同的，就白了。</p><ul><li>灰色世界假设<ul><li>逐通道计算RGB<strong>平均值</strong></li><li>逐通道利用<strong>平均值</strong>归一化</li><li>乘以“绿色通道的<strong>平均值</strong>”作为增益</li></ul></li><li>白色世界假设<ul><li>逐通道计算RGB<strong>最大值</strong></li><li>逐通道利用<strong>最大值</strong>归一化</li><li>乘以“绿色通道的<strong>最大值</strong>”作为增益</li></ul></li></ul><h4 id="去马赛克"><a href="#去马赛克" class="headerlink" title="去马赛克"></a>去马赛克</h4><p>拜耳阵列中，每个像素感受到不同颜色光，产生“马赛克效果”，需要去除。</p><p>用相邻的其它颜色像素取平均，得到当前像素的其它颜色值。</p><h4 id="降噪-Denoising"><a href="#降噪-Denoising" class="headerlink" title="降噪 Denoising"></a>降噪 Denoising</h4><p>噪声在低光照时尤为明显。</p><p>噪声的来源比较复杂：</p><ul><li>散粒噪声：光子到达服从泊松分布</li><li>暗电流：电路热效应产生一些电子</li><li>读出噪声：传感器和模拟前端电路的噪声</li></ul><p>简单降噪算法：平均滤波（卷积，利用周围像素），中值滤波</p><p>更复杂的降噪算法</p><h4 id="（色彩空间转化）"><a href="#（色彩空间转化）" class="headerlink" title="（色彩空间转化）"></a>（色彩空间转化）</h4><p>相机内部可能会把RGB色彩空间转化成HSV色彩空间。</p><p>这件事的意义：将RGB分离成更加独立的变量，方便研究。</p><h4 id="色调再现（伽马矫正"><a href="#色调再现（伽马矫正" class="headerlink" title="色调再现（伽马矫正"></a>色调再现（伽马矫正</h4><p>最初是因为CRT显示器对颜色的现实是非线性的。</p><p>目前伽马矫正与CRT无关。</p><p>人眼对低亮度更敏感，因此将相机的线性感光修正为适合人眼的非线性感光。</p><h4 id="（图像压缩）"><a href="#（图像压缩）" class="headerlink" title="（图像压缩）"></a>（图像压缩）</h4><p>略</p><h4 id="补充：RAW图像格式的意义：线性！"><a href="#补充：RAW图像格式的意义：线性！" class="headerlink" title="补充：RAW图像格式的意义：线性！"></a>补充：RAW图像格式的意义：线性！</h4><p>ISP处理后的图像和原始光强是非线性的。这不利于研究。</p><p>RAW图像仍然保持了和环境光强的良好的线性性。对计算机视觉而言非常有用:D</p><p>对一般人：保存更多信息，后期空间。</p><p>RAW的坏处：噪声，无压缩，降低连拍速度</p><p>注：RAW可能也经过了一些与处理，比如去马赛克。</p><p>将jpeg还原为RAW是一件非常困难的事情。</p><h3 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h3><p>ISP深入理解： <a href="https://www.eecs.yorku.ca/~mbrown/ICCV2019_Brown.html">https://www.eecs.yorku.ca/~mbrown/ICCV2019_Brown.html</a></p><p>更好的看paper的方法：two minute papers youtube</p><p>用卷积神经网络进行超暗照片的增强 Learning to see in the dark. ChenChen UIUC等 2018；</p><p>Day-to-Night image Synthesis for Training Nighttime Neural ISPs</p>]]></content>
    
    
    <categories>
      
      <category>计算摄像学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算摄像学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胡椒厨房——现在的人，没有精力再DIY</title>
    <link href="/posts/52048.html"/>
    <url>/posts/52048.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>儿时的回忆往往是碎片的，除了某些闪光点，其它的经历往往都变得模糊。这是我的其中一个碎片。</p><p>那可能是我很小的时候，在万达的一家餐厅。这是父母第一次带我走进这家餐厅。我记得，当我期待美食的时候，店员端上来一个呲呲作响的铁盘。我看着铁板上沸腾的神色的酱汁，血红的生肉，感到多么的新奇又不知所措。</p><p>我记得，在父母的指导下，我如何手忙脚乱地翻动盘中的食材，如何尝试把鸡蛋和米饭拌匀，如何小心翼翼地不让食材洒出来，如何用勺子用力把粘锅的食材刮下来，如何看着牛肉奇迹般地在我眼前变成我熟悉的颜色……</p><p>我记得，迫不及待品尝时，我如何被金属勺子轻轻烫到，在把握温度后如何大快朵颐，到最后，如何不舍地从盘底的沟槽中挖出最后一颗饭粒。饭粒在铁板的加热下，变得焦黄而且微微透明。</p><p>那是我小时候，去过的最好吃的餐厅之一。事实上，这可能是我第一次认识了什么是胡椒。（同样获此荣誉的，还有某次姥姥带我吃的老上海城隍庙。那次体验在我心里完全定义了什么是小笼包。）</p><p>当然，它获此荣誉，还有一个不得不提的原因：这之后的某个时候，它就被拆掉了，在我家附近再也找不到胡椒厨房这家店。这一次美好体验，就在我心里成为了抹不掉的念想。</p><p>之后，在离家较远的一个商城又看到了它。这之后，我偶尔会专程跑到这个很远的地方，专程吃一次这家店，在享用的同时重温当时的美妙回忆。我不会经常想到它。但是一旦想到，我几乎内心就不会再冒出其它选择。</p><p>然后，这天我又突发奇想去吃了一餐。却发现，这家店的名字从“胡椒厨房”变成了“铁板厨房”。虽然菜品没变，但店名的变化，总让人产生一些不安的情绪。事实上，从我家附近的胡椒厨房倒闭这件事就能看出，这个品牌的处境可能并不太好。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>胡椒厨房和普通的餐饮店有所区别。胡椒厨房的菜品主要包含米饭和肉（主要是牛肉），顾客也可以选择添加鸡蛋和蔬菜。在出餐时，店员端出的是放在高温铁盘上的生食。拿到餐品后，需要顾客自己对食材进行翻炒，直到菜品变熟后食用。也因此，胡椒厨房将自己定义为一家“DIY餐厅”。菜品口味方面，如「胡椒厨房」的店名，菜品中胡椒是重要调料，形成类似BBQ的烧烤风味。除了胡椒，顾客可以按照喜好，添加诸如「蒜香汁」等调料。</p><p>抛开童年回忆的光环，平心而论，胡椒厨房的菜品绝对是能分到「好吃」一类的。BBQ的风味显然具有很大的吸引力。此外，胡椒、蒜香的调料也可以带来独特的味觉享受。</p><p>更重要的是，DIY的特色使得胡椒厨房相比其它餐饮店具有一个巨大优势：<strong>它的饭菜一直是热的。</strong> 事实上，人对热的食物往往没有抵抗力。加热的铁盘，让食物可以长时间地保持在最适合的温度。</p><p>或许“石锅拌饭”之类的饭馆也有类似的特征，但请注意：胡椒厨房是铁盘而不是铁碗。在进食时，绝大部分的食材都能充分得到加热和保温。</p><p>要说菜品口味的不足，首先，它可能以咸口为主，对咸口不感冒的人可能不太喜欢；其次，它的菜品可能偏油腻。除此两点，它的口味大抵是令人满意的。</p><p>但是，味道好并不代表餐厅能活得好。我认为，至少有以下几点原因，让胡椒厨房变成现在这种局面。</p><p><strong>首先，也是最重要的，是价格问题。</strong> 胡椒厨房的人均50+，一言以蔽之，太贵了。一份「胡椒牛肉饭」需要49，还没鸡蛋，加个鸡蛋变成52。先不说一个鸡蛋三块钱的这个离谱问题，49，就一碗饭，一些牛肉还有一点胡椒，这个价格确实太贵了。</p><p>49，在呷哺呷哺我能买一整盘牛肉，再来个蔬菜双拼再点个锅底。这个量显然要比胡椒厨房足的多。有可能胡椒厨房的牛肉的来源更高级。但是，一言以蔽之，一般人吃不出来，<del>“感知不强”</del>。定价过高，注定了它不会受到太多欢迎。</p><p><strong>其次，胡椒厨房的定价引申出了第二个问题，就是品牌的定位不明。</strong> 笔者粗略地把线下餐饮业分成快餐和饭馆两种。从菜品上分析，胡椒厨房明显属于前者。胡椒厨房是一人一盘的一人食餐厅，这是几乎所有快餐店具有的共同特征。但是，人们对快餐的要求往往是廉价、快速。如果作为快餐店，它明显地太贵了。而且，它DIY的特性，也导致它并没有那么的“快速”。</p><p>但是，把胡椒厨房归类为“饭馆”又明显是不合适的。一人一盘的特点，让胡椒厨房不具备饭馆应有的社交功能。打个比方，如果约亲友聚会，胡椒厨房肯定不是备选项。此外，DIY的特性让它的进食过程显得有些紧张和狼狈，这不是饭馆应该有的。<em>（火锅店、烤肉店大概也具有DIY性质，但是首先，你不把食材放进去它就不会加热，所以至少还有喘息的机会；其次，它具有社交属性。）</em></p><p>它不甘于做廉价的快餐，它尝试做高端，它做50多的主食，做一百多的牛排；但是，它又没有高端餐饮应该具有的优雅和社交功能。不论从哪个角度看，胡椒厨房都是不合格的。</p><p><strong>此外，随着互联网的兴起，胡椒厨房DIY的性质又给它自身带来了第三重打击：无法外带</strong>。互联网改变了人们的饮食方式。现在，如果要吃快餐，人们往往会选择手机定外卖。因此，那些传统的“快餐店”，包括一些餐品不够高端的饭馆，都努力地做起了外卖的生意。但就在这样的时代，胡椒厨房无法外带，这就类似于宣告了自己的死亡。</p><p>目前这个时代，在繁忙的工作之余，人们大多靠定外卖草率解决；在周末休息的时候，人们大概会找一家优雅的餐馆给自己身心的享受。在这个时代，谁会专程出去吃一家看起来不那么高档，还需要自己忙活的DIY的餐厅呢？</p><p>现在的人，恐怕已经没有精力DIY了。</p><p>我祝愿我生活圈内的这唯一一家胡椒厨房还能长青。人们都时不时地希望自己能重温童年，我也希望能重温在我童年留下深刻印象的味道。我不希望当我脑海中闪过这种希望时，接踵而来的是无法释怀的空虚，即便这种希望可能与时代潮流相悖。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算概论A-不围棋</title>
    <link href="/posts/300.html"/>
    <url>/posts/300.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>PDF文稿: <a href="/assets/pdf/%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E4%B8%8D%E5%9B%B4%E6%A3%8B%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0.pdf">基于C++的不围棋游戏程序的实现.pdf</a></p><p>在下面嵌一个iframe以供浏览。不过手机端可能不支持这个功能。</p><iframe src="/assets/pdf/基于C++的不围棋游戏程序的实现.pdf" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="700px"> </iframe>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>计算概论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流浪地球2一周目简评</title>
    <link href="/posts/52568.html"/>
    <url>/posts/52568.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>看了流浪地球2. 电影总体的观感是很优秀的。接近三个小时的片长，对于这个内容的体量而言比较合适，不会让人觉得乏味。我特地看的IMAX版本，视听效果足够震撼。这部片子，完全对得起它目前在网络上获得的高分评价。</p><p>下面总结一下我一周目后想到的一些内容。</p><h2 id="相比第一部的优点"><a href="#相比第一部的优点" class="headerlink" title="相比第一部的优点"></a>相比第一部的优点</h2><h3 id="移除了“春节”元素"><a href="#移除了“春节”元素" class="headerlink" title="移除了“春节”元素"></a>移除了“春节”元素</h3><p>我不喜欢融入大量档期元素的特定档期电影。这种电影给人的印象是：它只为特定档期服务，只能靠着“蹭”特定档期的“流量”来获得票房，进而给人的印象是这种电影的质量不高。</p><p>优秀的导演和编剧应该有一种自信：我的电影不应该局限在某个特定的档期或者特定的上映时间。应该有一种自信：我拍的电影在全年任何一个时间上映，都将是一部优秀的电影。</p><p>显然，郭帆拍流浪地球1的时候没有这种自信；2的时候有了。</p><h3 id="角色身份的“提升”"><a href="#角色身份的“提升”" class="headerlink" title="角色身份的“提升”"></a>角色身份的“提升”</h3><p>（我流浪地球1也是一周目，记忆不太深刻）总的来说，流浪地球1是以一对兄妹的视角叙述的。这一对兄妹在玩闹似地跑出地下城后，偶遇了某个救援队，并展开了故事。这种视角，严厉的说，让人感觉当时的危机和救援宛如小孩子的儿戏。</p><p>流浪地球2的主要角色：李雪健饰演的高级政客；吴京饰演的军人；刘德华饰演的工程师。他们有专业的身份，肩负重大的责任。以他们的视角代入事件，更能体现危机之危，救援之难，也更匹配流浪地球系列的宏大叙事。</p><p>比起让两个无业小孩支招拯救世界，让真正的专业人士拯救世界大概更好一些。</p><h2 id="二的优点"><a href="#二的优点" class="headerlink" title="二的优点"></a>二的优点</h2><h3 id="“前传”式的剧情设计"><a href="#“前传”式的剧情设计" class="headerlink" title="“前传”式的剧情设计"></a>“前传”式的剧情设计</h3><p>流浪地球2选择在1的时间线之前做文章，是一个十分高明的决定。至少有以下几个好处：</p><ol><li>设定交代。</li></ol><p>2中丰富了许多关于“数字生命”和机器生命“MOSS&#x2F;550W”的设定，并且完善了流浪地球时代联合政府（UEG）的国际政治制度和物资配给制的经济制度。</p><p>这些内容很重要。</p><p>关于MOSS的设定让MOSS的重要性大幅度提升。事实上，流浪地球1中，MOSS是一个可有可无的存在。事实上，把1中的MOSS换成一个不太智能的，Siri一样的角色，甚至换成一个没有智能、纯机械的程序，整体的故事不会发生太大改变，可以正常推进。但是，有了2中的背景交代，MOSS一跃而成为重要势力。相当于通过“前传”的交代，让配角一跃成为主角。</p><p>对流浪地球时代政治经济的交代，让人们对这个时代的大局有了基本的把握。1可以说是以兄妹的“点”的视角描述这个时代，2是以“面”的视角描述这个时代。12相映，让人们对当时的整个世界已经建立了基本的感知。这有利于更多的故事在这个世界下展开。</p><ol start="2"><li>大量伏笔埋设</li></ol><p>流浪地球2选择“前传”叙事，为故事创造了大量未解开的谜团。无须多言。</p><ol start="3"><li>给续作留足空间</li></ol><p>前两点的好处，归根结底都是这一点。</p><p>我觉得流浪地球1没有给续作流出足够空间。想象一下，如果没有2，直接在流浪地球1的结尾之后做文章，能写的故事似乎不多。但是有了2，续作能写的内容一下子就丰富了：</p><ul><li>MOSS一跃成为主角，MOSS和图恒宇成为主线（而且，由于是数字生命，这条主线不会因为角色的衰老死亡而停止，有机会一直延续），有很多故事可以基于它展开</li><li>留下大量谜团，解开这些包袱基本就足够撑起一个续作了</li><li>介绍了这个时代的大观，如果要翻拍原著的剧情也会相对容易。</li></ul><h3 id="内涵丰富，有深度，有主旨"><a href="#内涵丰富，有深度，有主旨" class="headerlink" title="内涵丰富，有深度，有主旨"></a>内涵丰富，有深度，有主旨</h3><p>上文提到，相比于1，角色的身份有了“提升”。高阶层的人物角色更配合2的宏大主题。因此，2中设计的内涵也更加丰富。不论是强调“危难当前唯有责任”的责任感，还是歌颂敢于牺牲自我的英雄，还是强调人类团结所能迸发的巨大力量，电影中都有足够的内容来撑起这些主题。</p><p>此外，还有一些关于亲情、关于使命在一代代人间的传承，关于数字生命、生死概念的讨论等等话题可以从电影中引申。总之，丰富的情节和内涵让这部片可以从多个角度分析。</p><p><del>不过我是一周目，我暂且还不能仔细分析。</del></p><h3 id="（相对）中庸的政治立场"><a href="#（相对）中庸的政治立场" class="headerlink" title="（相对）中庸的政治立场"></a>（相对）中庸的政治立场</h3><p>价值导向应该中国优先还是世界优先的问题上，电影一方面强调了中国在计划中的重要作用，另一方面又时刻强调，这是全人类——各国——共同奋斗的结果，很中庸地回答了这个问题。</p><p>危难由少数英雄解决还是多数集体解决的问题上，一方面有吴京、刘德华这种个人英雄角色，一方面电影也时刻强调了团结、合作的重要性，很中庸地回答了这个问题。</p><p>总之，基本上不会让观众在电影的政治立场上产生反感。 <strong>这在一个国民普遍政治神经紧绷的时代，是很难得的。</strong></p><h2 id="我觉得不好的地方"><a href="#我觉得不好的地方" class="headerlink" title="我觉得不好的地方"></a>我觉得不好的地方</h2><h3 id="“老套”的剧情"><a href="#“老套”的剧情" class="headerlink" title="“老套”的剧情"></a>“老套”的剧情</h3><p>不得不说，电影很多地方体现了灾难片的典型套路。概括地说，电影无非是 <code>somehow出现危机 -&gt; 人类团结！！！黄金精神！！！ -&gt; somehow解决危机</code> 这个流程它甚至演了两次。</p><p>这样抽象的看，剧情是很无聊的（当然，抽象到这个程度，基本绝大多数电影都是无聊的）</p><p>还有啊，后面恢复全球互联网的时候，经典的“要卡到最后一秒才能解决问题”，说实话这种剧情很无聊诶 <code>-_-</code></p><h3 id="过于强调“刺激”“紧张”"><a href="#过于强调“刺激”“紧张”" class="headerlink" title="过于强调“刺激”“紧张”"></a>过于强调“刺激”“紧张”</h3><p>这点其实是我的个人看法。</p><p>流浪地球的故事设定，它本可以有更沉静，更压抑的表现手段。面对灭世的灾难，人类集体的背井离乡，牺牲人类社会原有的一切，压制享乐，压制文化艺术，步入集权和配给制，倾尽全力拯救危机只为苟且为生，走在茫然无光的漫漫长路上。</p><p>这种氛围，不仅是一种“危”，更是一种“悲”。除了拯救危机体现出的紧张、刺激的情节外，更应该有一种浓厚的悲凉。很遗憾，这种悲凉似乎没有得到很好的体现。</p><p>结尾的 <em>Goodbye, solar system[多语种]</em> 可以算是这种悲的一个体现。只能说，有，但是不多。</p><p>这局限了作品的深度。全片过于强调危难和应对，紧张刺激的大场面首尾相接，相当于不断地给观众打鸡血，让观众兴奋，而无法让观众静下来感受这种“悲”。</p><p>我觉得这是比较遗憾的。</p><h3 id="关于BGM的一些事"><a href="#关于BGM的一些事" class="headerlink" title="关于BGM的一些事"></a>关于BGM的一些事</h3><p>本片主要的氛围都是紧张的。紧张的部分，本片的BGM做的相当不错。</p><p>不过，就像上一部分所说的，片子的“悲”的部分有些少。仅有的那些“悲”的部分，我觉得BGM做的不够好。就以最后 <em>Goodbye, solar system[多语种]</em> 的部分为例。就我个人的理解，我觉得BGM应该体现出宇宙的空灵和肃杀。但是，此时的BGM，事实上只能起到“宏大”的感受，而无法体现出“空灵”的感受。这种BGM不太能体现宇宙的感觉。</p><p>总之，紧张部分的BGM很优秀；但是沉静部分的BGM，我觉得本片缺少一个类似 <em>Interstellar</em> 中 <em>Day One</em> 那样的优秀作品。</p><p>类似我在上一部分的观点，我觉得片尾曲不应该是那种紧张感十足的电音，而应该归于沉静，类似<em>Interstellar</em> 中的 <em>Day One</em>。尤其是到了片尾，我觉得更应该让观众的内心从紧张归于沉静，给观众时间反思这整个经历，而不是靠片尾曲尝试把情绪推向又一个高潮。</p><p>总之，我认为紧张和沉静应该是交替的，流浪地球2在这方面做的不够好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>足够优秀，并且写了一些我的想法。</p><p>就到这里。</p>]]></content>
    
    
    
    <tags>
      
      <tag>流浪地球</tag>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客更新日志</title>
    <link href="/posts/51354.html"/>
    <url>/posts/51354.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="2023-03-01"><a href="#2023-03-01" class="headerlink" title="2023-03-01"></a>2023-03-01</h2><p>将domain换成了 <code>justaloli.cn</code> 。原有域名，如果可能，将重定向到这个域名。</p><h2 id="2023-02-26"><a href="#2023-02-26" class="headerlink" title="2023-02-26"></a>2023-02-26</h2><p>一定程度上修复了音乐播放器，换回了Aplayer。但是由于没有PJAX，依旧只将播放器放在了杂货的一个页面中。</p><h2 id="2023-02-25"><a href="#2023-02-25" class="headerlink" title="2023-02-25"></a>2023-02-25</h2><p>新增RSS。入口在杂货。</p><h2 id="2023-02-07"><a href="#2023-02-07" class="headerlink" title="2023-02-07"></a>2023-02-07</h2><p>发现文章页面底部的「引用」板块显示的链接还是旧的<code>justaloli.github.io</code>。修改了一下。</p><h2 id="2023-01-18"><a href="#2023-01-18" class="headerlink" title="2023-01-18"></a>2023-01-18</h2><p>尝试了很多，最终增加了一个<code>Aplayer</code>音乐播放器。</p><p><strong>issue</strong>：很遗憾，由于Fluid主题不支持Pjax，音乐在页面跳转时将暂停。为此我只能求其次，只在某几个页面显示音乐播放器。</p><p>让Fluid支持Pjax，或者让Aplayer不被重新加载，目前都不在我的能力范围内。后续会持续学习。</p><p><strong>追加issue</strong> 玩脱了，整个播放器都没有了。完全不知道出了什么问题 无语。</p><p>做了很多好像什么都没有做。暂时搁置。</p><h2 id="2023-01-17"><a href="#2023-01-17" class="headerlink" title="2023-01-17"></a>2023-01-17</h2><p>对站点进行了萌ICP备案</p><p>给网页增加了一个<code>sakana🐟～</code>小组件，好玩！</p><h2 id="2023-01-16"><a href="#2023-01-16" class="headerlink" title="2023-01-16"></a>2023-01-16</h2><p>对 <code>fluid</code> 主题源码进行了一些修改，调整了「友链」（在这个博客下叫做杂货铺！）的布局和写作方式。</p><p>不过这些改变不是通过注入自己的代码实现的，而是直接修改fluid主题源码实现的，有一些不优雅。不过我比较满意。梦想是做成瀑布流，不过对我而言太困难。</p><h2 id="2023-01-15"><a href="#2023-01-15" class="headerlink" title="2023-01-15"></a>2023-01-15</h2><p>更换了网站头图，并彻底调整了网页配色。</p><h2 id="2023-01-13"><a href="#2023-01-13" class="headerlink" title="2023-01-13"></a>2023-01-13</h2><p>注册了新域名 <code>justaloli.site</code>，做了域名解析和cloudflare的CDN加速</p><h2 id="2023-01-12"><a href="#2023-01-12" class="headerlink" title="2023-01-12"></a>2023-01-12</h2><p>建站第一天。部署在Github Page<code>justaloli.github.io</code>。确定了博客框架<code>hexo</code>，确定了主题<code>fluid</code>，确定了网站名<code>Loli的杂货铺</code>。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本博客的搭建流程-续</title>
    <link href="/posts/19711.html"/>
    <url>/posts/19711.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本博客的搭建，离不开我的一位高中同学兼好友的指路： <a href="https://mug-chen.github.io/posts/23043.html">https://mug-chen.github.io/posts/23043.html</a> 。他的文章简明且直击要害，为这个博客的搭建起到了灯塔一般的作用。</p><p>不过，由于过于简明，初阅他的文章有一定难度。本文主要在这篇文章的基础上，补充一些知识点。</p><h2 id="1-什么是hexo？为什么用hexo而不用wordpress之类的？"><a href="#1-什么是hexo？为什么用hexo而不用wordpress之类的？" class="headerlink" title="1. 什么是hexo？为什么用hexo而不用wordpress之类的？"></a>1. 什么是hexo？为什么用hexo而不用wordpress之类的？</h2><p>在这之前，我们先要明确一个网站的基本构成。</p><p>十分粗略的说，一个网页（的前端）包含三个部分：HTML，CSS，JS。直观的说，HTML负责告诉浏览器：网页上需要显示哪些内容；CSS负责告诉浏览器：这些内容以何种样式（例如：字体大小和颜色）显示；JS负责告诉浏览器：网页将如何反馈用户的操作。再形象一些，如果将网页比作人体，HTML是骨架，CSS是皮肤，JS是肌肉（人的动作）。</p><p>因此，如果要建立一个网页，至少需要熟悉上述三个部分以及它们之间的相互作用，这无疑非常困难。好在，这世上不乏现成的工具，我们只需要对这些工具进行简单的操作，它们就能帮我们生成所需的HTML，CSS，JS，以及一系列网页所需的文件。</p><p><strong>hexo</strong> 就是这样的一个工具。<code>hexo</code>是一个专门的博客框架。有了它，我们只需要埋头撰写博文，无需在意HTML、CSS、JS一流，它会自动由我们的博文生成精美的网页。</p><p>虽然世上还有<code>wordpress</code>等博客框架，但是选择<code>hexo</code>几乎是一个必然。我和我朋友的博客是利用 <code>Github Page</code> 呈现的。 <code>Github Page</code> 的优势是免费，劣势是其显示的网页必须是 <strong>静态</strong> 的。<code>wordpress</code>是动态的，必须建立在服务器上。这意味着，建立一个<code>wordpress</code>博客需要租服务器，并掏钱。而<code>hexo</code>生成的正好是静态网页。</p><p><del>你做静态网页的时候很爽，你部署之后不断刷新网页的样子也很狼狈（这句话的意思：静态网页导致整个网页都能被缓存，而由于缓存的存在，上传的更改无法被及时体现在网页上），大概要延后几分钟</del></p><blockquote><p>关于为什么使用<code>hexo</code>，更多内容可以参阅：</p><p><a href="https://blog.csdn.net/xinghaikongmeng/article/details/107399643">https://blog.csdn.net/xinghaikongmeng/article/details/107399643</a></p></blockquote><h2 id="2-后续内容：一些自定义和美化经验"><a href="#2-后续内容：一些自定义和美化经验" class="headerlink" title="2. 后续内容：一些自定义和美化经验"></a>2. 后续内容：一些自定义和美化经验</h2><h3 id="1-配置-config-yml"><a href="#1-配置-config-yml" class="headerlink" title="1. 配置_config.yml"></a>1. 配置<code>_config.yml</code></h3><p>里面包含博客的诸多基本设置，可以自行设置更改。其中各项栏目的作用可以参见：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/127786638">https://zhuanlan.zhihu.com/p/127786638</a></p></blockquote><h3 id="2-自定义主题"><a href="#2-自定义主题" class="headerlink" title="2. 自定义主题"></a>2. 自定义主题</h3><p>最好的做法是自行检索，推荐的关键词“hexo”“主题”。最好是：先看看主题推荐的文章，确定自己想使用的主题 -&gt; 直接搜索主题名称，按照官网的提示和文档进行设置。</p><p>主题设置在 <code>_config.主题名称.yml</code> 中，需要按照主题给出的官方文档进行修改。</p><p>在我看来，美化博客好比装修自己的家，繁琐但有趣。希望你享受这个过程:D</p><h3 id="3-一些使用小组件"><a href="#3-一些使用小组件" class="headerlink" title="3. 一些使用小组件"></a>3. 一些使用小组件</h3><ol><li>不在url中使用中文的组件：abbrlink</li><li>方便管理图片的组件：asset-image</li></ol><blockquote><p>参阅：</p><p><a href="https://blog.csdn.net/qq_42780289/article/details/102662091">https://blog.csdn.net/qq_42780289/article/details/102662091</a></p><p><a href="https://www.cnblogs.com/QianBoy/p/8721529.html">https://www.cnblogs.com/QianBoy/p/8721529.html</a></p></blockquote><h3 id="4-cdn加速"><a href="#4-cdn加速" class="headerlink" title="4. cdn加速"></a>4. cdn加速</h3><ul><li>提前说：这个部分 <strong>要花钱，且要持续花钱（域名基本只租不卖）</strong></li></ul><h4 id="为什么需要cdn加速？"><a href="#为什么需要cdn加速？" class="headerlink" title="为什么需要cdn加速？"></a>为什么需要cdn加速？</h4><p>因为众所周知的原因，<code>Github Page</code> 打开，太慢了。</p><h4 id="什么是cdn加速？"><a href="#什么是cdn加速？" class="headerlink" title="什么是cdn加速？"></a>什么是cdn加速？</h4><p>一个简单的理解是，cdn是一些缓存服务器，将你网页的资源存放在距离用户更近的服务器中。这样，可以加速内容的访问，同时缓解主服务器的压力。</p><h4 id="配置cdn加速"><a href="#配置cdn加速" class="headerlink" title="配置cdn加速"></a>配置cdn加速</h4><p>这里选择cloudflare提供的cdn服务（注：主要的原因是匿名且免费。cloudflare虽然不在中国，但访问速度比github快不少）。</p><p><strong>不过，要注意，在cdn加速前我们需要先拥有一个域名</strong>，而这常常是花钱的。</p><p>这里以腾讯云为例。</p><h5 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h5><p>直接到腾讯云域名购买，输入想要的域名，对应价格购买就行了。不同顶级域的价格会有差距。像这个 <a href="https://justaloli.site/">justaloli.site</a> ,  第一年仅需8元，童叟无欺。</p><p><img src="/posts/19711/%E8%B4%AD%E4%B9%B0%E5%9F%9F%E5%90%8D.jpeg"></p><p>注意：国内的域名购买<strong>需要实名</strong>；需要等待一段时间审核域名才能正式使用。</p><div style="width:30%;margin:auto"><p><img src="/posts/19711/%E4%BA%92%E8%81%94%E7%BD%91%E5%B9%B6%E9%9D%9E%E6%B3%95%E5%A4%96%E4%B9%8B%E5%9C%B0.jpg" alt="互联网并非法外之地！"></p></div><h5 id="2-注册cloudflare"><a href="#2-注册cloudflare" class="headerlink" title="2. 注册cloudflare"></a>2. 注册cloudflare</h5><p>注册后点击“添加站点”，输入刚刚购买的域名 <a href="https://justaloli.site/">justaloli.site</a>，下一步选择免费计划，然后继续。</p><p><img src="/posts/19711/%E9%80%89%E6%8B%A9%E8%AE%A1%E5%88%92.jpeg"></p><h5 id="3-向cloudflare给出dns记录。"><a href="#3-向cloudflare给出dns记录。" class="headerlink" title="3. 向cloudflare给出dns记录。"></a>3. 向cloudflare给出dns记录。</h5><p>这一步紧随第二步，就是网站的下一页。在这里我们要手动指出 <a href="https://justaloli.site/">justaloli.site</a> 要指向哪个ip地址。</p><p><strong>首先：</strong> 我们要明确我们网页的ip地址。博客目前的域名仍然是<code>justaloli.github.io</code>，我们在命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Windows</span><br>ping justaloli.github.io<br><span class="hljs-comment">#MacOS或Linux</span><br>dig justaloli.github.io<br></code></pre></td></tr></table></figure><p>在输出中可以找到服务器的ip地址。我们只需要从这些ipv4地址中选一个就可以了。</p><p><img src="/posts/19711/%E7%A1%AE%E5%AE%9Aip.jpeg"></p><p><strong>其次：</strong> 在cloudflare上手动添加dns记录。每条记录主要有三项：类型、名称、地址。我们至少需要两条。</p><ul><li>第一条：类型填<code>A</code>，名称填<code>@</code>，地址填上文找到的ip；</li><li>第二条：类型填<code>A</code>，名称填<code>www</code>，地址填上文找到的ip。</li></ul><p>这个操作是在指示cloudflare，将<code>justaloli.site</code>和<code>www.justaloli.site</code>的域名解析到我们网站的ip。</p><p><img src="/posts/19711/%E6%B7%BB%E5%8A%A0dns%E8%AE%B0%E5%BD%95.jpeg"></p><p>你可能会注意到记录左侧有橙色小三角。无需理会，继续。</p><p><strong>最后：</strong> 将我们注册的<code>justaloli.site</code>的域名服务器改成cloudflare的服务器。</p><p><img src="/posts/19711/cloudflare%E6%8F%90%E7%A4%BA%E4%BF%AE%E6%94%B9dns%E6%9C%8D%E5%8A%A1%E5%99%A8.jpeg" alt="cloudflare网站上的指示"></p><p>打开腾讯云的控制台，进入域名的 <code>概况</code> 页面，左下角 <code>DNS解析</code>，进行修改，将腾讯云内置的DNS服务器改成cloudflare网页上给出的服务器。</p><p><img src="/posts/19711/%E4%BF%AE%E6%94%B9dns.jpeg"></p><p><strong>完成后回到cloudflare。后续还有一些选项，建议开启HTTPS，并且将SSL策略设置为<code>完全</code> (这很重要)</strong></p><h5 id="4-把-Github-Page-的域名调整为-justaloli-site"><a href="#4-把-Github-Page-的域名调整为-justaloli-site" class="headerlink" title="4. 把 Github Page 的域名调整为 justaloli.site"></a>4. 把 <code>Github Page</code> 的域名调整为 <a href="https://justaloli.site/">justaloli.site</a></h5><p>在项目的<code>Settings-Pages</code>中，在下方的 <code>Custom domain</code> 位置填写 <a href="https://justaloli.site/">justaloli.site</a>。并保存。这时，如果前面一切顺利，github将自动完成DNS检测。</p><p><img src="/posts/19711/github%E7%9A%84dns%E6%A3%80%E6%B5%8B.jpeg"></p><p>完成后，建议勾选下面的强制HTTPS。</p><h5 id="5-同步我们本地的项目"><a href="#5-同步我们本地的项目" class="headerlink" title="5. 同步我们本地的项目"></a>5. 同步我们本地的项目</h5><p>完成后，回到Github项目主页，会发现多了一个<code>CNAME</code>文件。</p><p><img src="/posts/19711/%E9%A1%B9%E7%9B%AE.jpeg"></p><p>这个文件内容只有一行，就是我们的自定义域名 <a href="https://justaloli.site/">justaloli.site</a>。</p><p>这时，我们要在我们本地项目的 <code>/source/</code> 目录下创建一个一模一样的 <code>CNAME</code> 文件，填入我们的自定义域名。</p><p><strong>这很重要！否则我们在本地 <code>hexo d</code> 后，<code>Github</code> 上的 <code>CNAME</code> 文件会消失，自定义域名的设置会随之消失。</strong></p><p>一系列步骤完成后，就可以使用自定义的<a href="https://justaloli.site/">justaloli.site</a>访问博客了。</p><p><strong>Remark：</strong>如果中途出现哪一步有问题，不要着急，可以先等一小会，服务器更新需要时间。</p><blockquote><p>cdn部分可以参见：</p><p><a href="https://www.cnblogs.com/yuelblog/p/15829774.html">https://www.cnblogs.com/yuelblog/p/15829774.html</a></p><p><a href="https://www.zhihu.com/question/28814437">https://www.zhihu.com/question/28814437</a></p></blockquote><h2 id="附：Mac-amp-linux部署hexo博客的方式（比windows简单很多！）和一些截图"><a href="#附：Mac-amp-linux部署hexo博客的方式（比windows简单很多！）和一些截图" class="headerlink" title="附：Mac&amp;linux部署hexo博客的方式（比windows简单很多！）和一些截图"></a>附：Mac&amp;linux部署hexo博客的方式（比windows简单很多！）和一些截图</h2><p>以Mac为例。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol><li>确保安装了homebrew，并确保homebrew使用了国内镜像</li><li>确保安装了git，并确保git可以通过代理等方式正确访问github</li></ol><p>上两条测试方式：在终端运行brew、再运行git，看是否有输出。</p><blockquote><p>关于终端的git如何使用代理，可以参阅：</p><p><a href="https://zhuanlan.zhihu.com/p/481574024">https://zhuanlan.zhihu.com/p/481574024</a></p></blockquote><h3 id="第一步：安装-node-js-和-hexo"><a href="#第一步：安装-node-js-和-hexo" class="headerlink" title="第一步：安装 node.js 和 hexo"></a>第一步：安装 node.js 和 hexo</h3><ol><li>node.js安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install node<br></code></pre></td></tr></table></figure><p><img src="/posts/19711/%E5%AE%89%E8%A3%85nodejs.jpeg" alt="安装node.js"></p><ol start="2"><li>hexo 安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p><img src="/posts/19711/%E5%AE%89%E8%A3%85hexo.jpeg" alt="安装hexo"></p><h3 id="第二步：创建项目，初始化hexo"><a href="#第二步：创建项目，初始化hexo" class="headerlink" title="第二步：创建项目，初始化hexo"></a>第二步：创建项目，初始化hexo</h3><ol><li>在某个位置，创建一个 <strong>空的</strong> 文件夹。</li><li>初始化hexo</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#先cd到创建的目录</span><br>hexo init<br></code></pre></td></tr></table></figure><p><img src="/posts/19711/%E5%88%9D%E5%A7%8B%E5%8C%96hexo.jpeg" alt="初始化hexo"></p><p>注意：如果报错，请确认git配置了代理。</p><ol start="3"><li>在localhost运行hexo</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#s是sever的简称</span><br>hexo s<br></code></pre></td></tr></table></figure><p><img src="/posts/19711/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8Chexo%E6%9C%8D%E5%8A%A1.jpeg" alt="hexo s"></p><h3 id="第三步：将项目上传到Github，建立Github-Page"><a href="#第三步：将项目上传到Github，建立Github-Page" class="headerlink" title="第三步：将项目上传到Github，建立Github Page"></a>第三步：将项目上传到Github，建立Github Page</h3><ol><li>创建github项目</li></ol><blockquote><p>可以参阅：</p><p><a href="https://zhuanlan.zhihu.com/p/28321740">https://zhuanlan.zhihu.com/p/28321740</a></p></blockquote><p>看到 <em>2.开始搭建博客</em> 的前一点部分就好了。</p><ol start="2"><li>配置本地的hexo项目</li></ol><p>这部分直接参阅友链的<a href="https://mug-chen.github.io/posts/23043.html">文章</a>就好啦！</p><p>关于Git命令，文章里提供的是SSH连接策略，这里再提供有关HTTPS连接策略的内容：</p><blockquote><p><a href="https://blog.csdn.net/qq_38800316/article/details/120679506">https://blog.csdn.net/qq_38800316/article/details/120679506</a></p></blockquote><p>总之就是，如果HTTPS登录时提示 <code>Support for password authentication was removed on August 13,2021.</code> ，就按照文中做法，将“密码”一栏改成在Github上创建的token即可。</p><ol start="3"><li>将本地的hexo项目“部署”到Github上</li></ol><p>还有很多近义词如“同步”“上传”“push”方便理解这项操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#这是安装hexo的一个组件，hexo将用这个组建调用git</span><br>npm install hexo-deployer-git --save<br><span class="hljs-comment">#g是generate的简称</span><br>hexo g <br><span class="hljs-comment">#d是deploy的简称</span><br>hexo d <br></code></pre></td></tr></table></figure><h3 id="第四步：撰写博文"><a href="#第四步：撰写博文" class="headerlink" title="第四步：撰写博文"></a>第四步：撰写博文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post 你的博文名字<br>hexo s<br><span class="hljs-comment">#用你喜欢的方式打开 /source/_posts/你的博文名字.md 并撰写，保存。</span><br></code></pre></td></tr></table></figure><p><strong>Remark：</strong> 撰写时，可以保持<code>hexo s</code>始终运行。这样，在你保存md文件后，刷新<code>localhost</code>，就能立刻看到效果。</p><p>上传修改到<code>Github Page</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo d<br></code></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>文中引用的各类文章很多，不再一一列出。再次对 <code>MUG-chen</code> 以及文内所有引用源的作者表示感谢！</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎光临杂货铺</title>
    <link href="/posts/1439.html"/>
    <url>/posts/1439.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>……</p><p>我就描述一下我对它的想象吧</p><p>这个杂货铺，它可能……处在一个相对繁忙的地段，周围都是匆匆走过的人和川流不息的车。</p><p>但是在杂货铺周围，人会少很多。它也许在一个巷子的内侧，也许在一条不是主干道的街边。</p><p>远远地能听见繁忙城市的底噪，反而更显此处的清净。</p><p>它就这样开着。它的店面很小，简单的招牌。没有大张旗鼓的卖力揽客，在一个大厦林立的城市中很不起眼</p><p>在城市的底噪之外，宁静地等待探寻到这里的客人</p><p>这是一家杂货铺，但每件杂物都只有一两份。似乎把杂物卖了赚钱并不是这个杂货铺的目的。更多的意义可能是……陈列</p><p>这大多是一些精致的、独特的小物件，可能很多都是在这个繁忙的城市中很难找到的。由这些性质推测，它的东西，大概有不少是旧物。</p><p>也因此，整个店的装潢都有一种古朴的气氛。</p><p>但并不破败。店主一直在细心地照料、布置这个地方。这里的每一件物品，可能都是他的收藏。每当有顾客走进这里，拿起一件杂物，店主都愿意和客人分享它背后的故事。</p><p>窗边有一张小桌子，店主可以和客人坐下聊天。当然，它是空的。</p><p>夕阳，斜射的阳光洒在室内，一片暖色。杂货铺就这样，静静等待有心人的到来。</p><p>门上的铃铛响了。有客人来了……</p><p>……</p></blockquote><p>是为序。</p><h2 id="社交媒体的尽头"><a href="#社交媒体的尽头" class="headerlink" title="社交媒体的尽头"></a>社交媒体的尽头</h2><p>为什么要做博客？</p><p>我并不是一个擅长分享或是写作的人。近几年，从创建微信公众号以来，前前后后搞了不少社交媒体，最大的感受是：能分享东西的平台越多，想分享的愿望、以及能分享的东西似乎越少了。</p><p>所以，当我有建博客的冲动的时候，我一般会首先让自己冷静下来：我没有必要再创建一个社交媒体。其次告诉自己，这是一个技术上超出我能力的事情。</p><p>不过，当陈做出一个博客的时候，我才意识到，建立一个博客在技术上是可行的。我和陈是高中同学。至少在半年前，我和他（大概）在网页上的知识都基本没有。如果他能够做出一个精美的博客，那我也一定可以。更棒的是，他专门写了一篇博文来介绍他的搭建过程。</p><p>所以，那种建立博客的欲望又萌生了。不过内心的另一个自己仍然在提醒我：我没有必要再创建一个社交媒体。但是这种欲望相比以往是那么强烈，挥之不去。我便在Tg的channel上问了问频道关注者的看法。有人回复：「 <em>去建吧，社交媒体不属于你的；可博客是</em> 」</p><p>所以我就“去建”了。最开始只是抱着试试的态度，却在一天内，几个小时，突然地做出来了。输入自己的域名，看到我的网页出现在我眼前的时候，我的心情很难以描述。就像是一直以来都认为不可能的事情，突然就做到了，还明晃晃的在眼前做到了。</p><p>那天晚上很激动，睡的很不好。</p><p>当然，建的同时我也一直在问自己，我到底建它干什么。这几天我也更频繁地翻看其他人的各种博客，不断思考“博客”相比微信公众号一类的社交网络平台的不同之处。</p><p>想明白了一点：博客不是良好的「推广平台」。</p><p>我对「推广平台」的理解是，一种可以比较轻松的让文章得到大范围的推广，使文章获得大量点击，并且（如果可能）可以让作者从流量中盈利的平台。</p><p>这个年代了，不论是微信公众号、微博、或者什么CSDN或者简书或者，whatever，各种平台，有着庞大的用户基数，先进的推荐算法，是当之无愧的「推广平台」。一个人，如果想让自己的文章广为人知，最好的做法便是注册其中一个甚至多个账号，摸清大数据和推荐算法的规律，写出博人眼球的文章，打尽可能多的tag，然后尽可能的转发并呼吁转发。</p><p>做博客显然，它就不是这样的心情。想要推广自己的人不会大费周章地，买一个没人能找到的域名，建立一个鲜有人光顾的网站。就像想要盈利的店铺不会选择开在寂寥的地方。</p><p>如果有人这么做了，只能说明一件事：意不在此。</p><p>如果建博客不是为了给别人看的，那答案只有一个了：这是给自己看的。或者说，这是一种纯粹的不为流量。我有一个很小的公众号，公众号给我的感觉是，如果我不更新，我会有隐隐的焦虑；如果观看数很少，我会产生一种消极情绪；如果我的公众号形成了某种风格，在想写另一个风格内容的时候，我会感到犹豫。</p><p>总之，似乎是社交媒体给人带来的一种压力。也许它是假的，可能是我比较敏感，因此只有我感到了这种压力。</p><p>但是在这里，似乎不会再有这种压力了。这里一切都是我的。我只管写我想写的就好了，没有人会看。有人看了我也不知道。</p><p>是的，这个网站目前不打算做任何和读者相关的互动。什么点赞评论转发，乃至文章阅读数，网站访问量，你看不到，我也看不到。</p><p>那为什么要建博客？一个本地的记事本不就好了吗？我想，这可能是人人都会有的一种分享欲。有的时候，遇到一些事情，终究还是想说出来，不论有没有人听。就像喊山。</p><p>就让「有人看」成为一个美好的幻想，而不是一个kpi吧。</p><p>当然，如果你有想写给我的内容，我有联系方式写在「关于」页面。我想表达的是，我不想让“想让人看到”在我心里成为一项必须达成的任务，成为一种压力。</p><p>抱着这种心态，我继续着博客的搭建和完善。</p><p>于是有了网站的名字：杂货铺。</p><h2 id="为什么是Loli"><a href="#为什么是Loli" class="headerlink" title="为什么是Loli"></a>为什么是Loli</h2><p>其实Loli（萝莉）是自称。当初起网名的时候，想给自己找一个“一眼看就知道这不是真的”的设定。所以就取名萝莉。</p><p>对，我，九岁萝莉（头头是道</p><p>至于取名Loli的其它原因，我广泛的喜欢一切可爱的东西。萝莉是一个代表。</p><p>当然，我已经很久没有刻意地去维护我“萝莉”的赛博形象了。所以用Loli这个词，可能是习惯使然。</p><p>用作网页标题，也是想增加一点活跃的气氛。就我对这个杂货铺的描述，可能氛围上有点太冷清了。其实我是个情绪变化比较极端的人，我有很活泼的一面的！所以也想有一些活跃的概念在网页里。</p><p>对了，一定要注明：<em><strong>本站所有萝莉为二次元概念。</strong></em></p><hr><p>最后，还是让我再次说出那句话吧：</p><p><em>欢迎光临杂货铺:D</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

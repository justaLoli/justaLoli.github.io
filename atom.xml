<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loli的杂货铺</title>
  
  <subtitle>欢迎光临:D</subtitle>
  <link href="https://justaloli.cn/atom.xml" rel="self"/>
  
  <link href="https://justaloli.cn/"/>
  <updated>2023-06-07T13:52:09.119Z</updated>
  <id>https://justaloli.cn/</id>
  
  <author>
    <name>justaLoli</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>地震概论内容整理</title>
    <link href="https://justaloli.cn/posts/15552.html"/>
    <id>https://justaloli.cn/posts/15552.html</id>
    <published>2023-05-26T12:21:35.000Z</published>
    <updated>2023-06-07T13:52:09.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h1><h2 id="地震"><a href="#地震" class="headerlink" title="地震"></a>地震</h2><p>上世纪200万人死于地震，21世纪将有约1500万人死于地震；</p><p>全球有记录以来死亡人数超过20万人的地震有6次，中国占4次；</p><h2 id="什么是地震学"><a href="#什么是地震学" class="headerlink" title="什么是地震学"></a>什么是地震学</h2><p>地震学是关于地震的科学；</p><p>地震学的研究范围：宏观地震学、地震波的传播理论，测震学。</p><h2 id="地震分类"><a href="#地震分类" class="headerlink" title="地震分类"></a>地震分类</h2><p>地震按震源深度分：</p><p>浅源地震：震源&lt;60km；</p><p>深源地震：震源&gt;300km；</p><p>中源地震：震源60-300km。</p><p>按震中距分：</p><p>近震：震中距&lt;1000km；</p><p>远震：震中距&gt;1000km；</p><p>地方震：震中距&lt;100km。</p><h2 id="古代对地震的认识"><a href="#古代对地震的认识" class="headerlink" title="古代对地震的认识"></a>古代对地震的认识</h2><p>古代地震成因推测：古希腊—气动说，日本—地下鲶鱼，中国—天戒论，高山族—地牛，印第安人—乌龟；</p><p>1755年里斯本大地震 大大使地震学从神学禁锢解脱</p><h2 id="地震学简史"><a href="#地震学简史" class="headerlink" title="地震学简史"></a>地震学简史</h2><p>1900年奥尔德姆地震图上识别P、S和面波，</p><p>1906年发现地核 (奥尔德姆空区)</p><p>1909年南斯拉夫莫霍洛维奇发现地壳和地壳下物质分界面 (莫霍面&#x2F;M界面)</p><p>1914年德国古登堡发现核慢界面 (古登堡面&#x2F;G界面)</p><p>1936年莱曼发现固体内核及内外核分界面 (L界面) –杰弗里斯和布伦公布了震相走时表</p><h2 id="中国的地震学"><a href="#中国的地震学" class="headerlink" title="中国的地震学"></a>中国的地震学</h2><p>1966年邢台大地震</p><p>1971年 国家地震局成立（中国是唯一一个设立了国家机构来统一开展预测和预防工作的）</p><h2 id="地震学的基本名词和概念（了解）"><a href="#地震学的基本名词和概念（了解）" class="headerlink" title="地震学的基本名词和概念（了解）"></a>地震学的基本名词和概念（了解）</h2><ul><li>震源：地球内部发生地震的地方称为震源(或称震源区)。</li></ul><p>震源深度：将震源看做一个点，此点到地面的垂直距离称为震源深度，一般用字母h表示。</p><ul><li><p>震中：震源在地面上的投影点称为震中(或称震中区)。同时,地面上受破坏最严重的地区叫极震区,理论上震中区和极震区是相同的,实上由于地表局部地质条件的影响,极震区不一定是震中区。</p></li><li><p>震中距离:在地面上,从震中到任一点沿大圆弧测量的距离称为震中距离用△表示。</p></li><li><p>发震时刻:发生地震的时刻，一般用字母 O或 T。来表示。我国以北京时间，比格林威治时间早 8 小时。</p></li><li><p>地震波:发生于震源并在地球表面和内部传播的弹性波称为地震波。波传播经的路径称为地震射线。</p></li></ul><p><img src="/posts/15552/1-1.png" alt="示意图"></p><h1 id="第二章-地震波"><a href="#第二章-地震波" class="headerlink" title="第二章 地震波"></a>第二章 地震波</h1><h2 id="第一节-机械波"><a href="#第一节-机械波" class="headerlink" title="第一节 机械波"></a>第一节 机械波</h2><h3 id="机械波产生的条件"><a href="#机械波产生的条件" class="headerlink" title="机械波产生的条件"></a>机械波产生的条件</h3><ol><li><p>波源：产生机械振动的振源</p></li><li><p>弹性介质：传播机械振动的介质</p></li></ol><h3 id="波动的基本关系"><a href="#波动的基本关系" class="headerlink" title="波动的基本关系"></a>波动的基本关系</h3><p>$$v &#x3D; \frac\lambda T &#x3D; \lambda f$$</p><h2 id="第二节-地震波"><a href="#第二节-地震波" class="headerlink" title="第二节 地震波"></a>第二节 地震波</h2><h2 id="泊松比-横向长度相对变化率与纵向长度相对变化率之比"><a href="#泊松比-横向长度相对变化率与纵向长度相对变化率之比" class="headerlink" title="泊松比:横向长度相对变化率与纵向长度相对变化率之比"></a>泊松比:横向长度相对变化率与纵向长度相对变化率之比</h2><p>地球介质地幔为1&#x2F;4，外核为1&#x2F;2</p><h2 id="横波和纵波："><a href="#横波和纵波：" class="headerlink" title="横波和纵波："></a>横波和纵波：</h2><ul><li><p>横波（P波）：质点的振动方向和波的传播方向垂直。（对应体变）</p></li><li><p>纵波（S波）：质点的振动方向和波的传播方向平行。（对应切变）</p></li></ul><p>在固体中可以传播横波或纵波，在液体、气体中只能传播纵波。</p><p>纵波速度比横波速度大（P波约为S波速度的 $\sqrt3$ 倍)</p><p>因此地震记录上P波先到达。</p><h2 id="第三节-地震波的类型"><a href="#第三节-地震波的类型" class="headerlink" title="第三节 地震波的类型"></a>第三节 地震波的类型</h2><h3 id="体波"><a href="#体波" class="headerlink" title="体波"></a>体波</h3><h4 id="S波的分解"><a href="#S波的分解" class="headerlink" title="S波的分解"></a>S波的分解</h4><p>分解为SH波(平行于界面的分量)</p><p>SV波(在入射线和界面法线构成的平面（称为入射面）上的分量)</p><h4 id="P波和S波的差异"><a href="#P波和S波的差异" class="headerlink" title="P波和S波的差异"></a>P波和S波的差异</h4><ol><li>P波和S波的质点振动方向相互垂直</li><li>一般情况下，P波的垂直传播，S波的水平传播，P波和S波质点振动方向互相垂直。</li><li>S波的低频成分更丰富</li><li>S波的振幅大于P波</li><li>P波通过时体积变化，不转动，无旋波</li><li>S波通过时无体积变化，有转动，无散等容波</li></ol><h3 id="面波：沿地球表面传播，在于界面垂直的方向上振幅急剧衰减。"><a href="#面波：沿地球表面传播，在于界面垂直的方向上振幅急剧衰减。" class="headerlink" title="面波：沿地球表面传播，在于界面垂直的方向上振幅急剧衰减。"></a>面波：沿地球表面传播，在于界面垂直的方向上振幅急剧衰减。</h3><p>性质：能量分布；频散特征。</p><p>主要分类：洛夫波和瑞利波</p><p>主要区别：介质质点振动方式不同</p><ul><li>洛夫波只有水平方向振动</li><li>瑞利波既有水平又有垂直振动</li></ul><p>主要特点：</p><ul><li>振幅比体波大</li><li>离开震源一定距离 (震中距较大)，面波在地震记录上比较显著</li><li>面波虽震中距增大衰减的速度比体波慢。</li><li>面波的能量被捕获在表面才能沿着或近地表传播（在伦敦的圣保罗大教堂 “耳语长廊”或中国天坛回音壁的墙面上捕获的声波就是面波。）</li><li>在地震记录上，面波的振幅一般比体波大。</li><li>速度小于P波，等于或小于S波</li><li>不同周期的面波，渗透深度不同–周期越小，渗透深度越浅。</li><li>洛夫波虽然无垂直震动，但是可能破坏性最大（因为其振幅最大且施加剪切力）</li></ul><p><img src="/posts/15552/2-%E9%9D%A2%E6%B3%A2.png" alt="面波的震动图像"></p><h2 id="第四节-波序"><a href="#第四节-波序" class="headerlink" title="第四节 波序"></a>第四节 波序</h2><p>地震波的波序: P-S-洛夫波-瑞利波-地震尾波</p><p>P波破坏性最小，产生上下颠动;S波、洛夫波带来左右摇晃;瑞利波导致滚动</p><p>离震源远的地方，感知最强的是面波。</p><h1 id="第三章-地震波的传播理论"><a href="#第三章-地震波的传播理论" class="headerlink" title="第三章 地震波的传播理论"></a>第三章 地震波的传播理论</h1><ol><li><p>地震波是地下传播的振动，必然与岩石的弹性有关，一般假定岩石是一种完全弹性体。一般计算中，地球介质可以作为各向同性的完全弹性体来对待。</p></li><li><p>首波（侧面波、折射波、衍射波、行走反射波，等等）大于一定临界距离时，首波比直达波先到达，所以地震勘测就是使用首波。p和s都有首波但是一般s观察不到。首波能量很小.</p></li><li><p>地震波随时间、随空间都指数衰减。</p></li><li><p>震中距：震中（震源在地表的垂直投影）到观测台的距离，单位km。一度震中距大约110km</p></li></ol><h2 id="地震波传播基本理论：射线理论（地震学中成立条件：高频情况。）"><a href="#地震波传播基本理论：射线理论（地震学中成立条件：高频情况。）" class="headerlink" title="地震波传播基本理论：射线理论（地震学中成立条件：高频情况。）"></a>地震波传播基本理论：射线理论（地震学中成立条件：高频情况。）</h2><ul><li>费马原理：最短路径。</li></ul><p>在地球非均匀介质中，地震射线总是向上弯曲，因此一定到达地表</p><ul><li>斯涅尔定律：</li></ul><p>$$\frac{sin\theta}{v} &#x3D; Const$$</p><p>射线理论的缺陷：只适用于高频，对于长周期或者陡的速度梯度的介质行不通。对于非几何效应的问题也不容易处理。</p><p>一般情况下随深度的增加，传播速度增加。</p><h2 id="折射、反射和转换"><a href="#折射、反射和转换" class="headerlink" title="折射、反射和转换"></a>折射、反射和转换</h2><ul><li><p>近震</p><ol><li>p波会发生反射、折射和转换，形成反射p波、折射p波和反射转换sv波、折射转换sv波</li><li>sv波与p波类似</li><li>sh波只能产生反射sh和折射sh</li><li>莫霍面的首波是pn</li><li>射线参数 $p &#x3D; \frac{sin\theta}{v}$</li></ol></li><li><p>远震（地球曲率不能忽略）</p></li></ul><p>球对称介质的折射定律</p><p>$$\frac{rsin[i(r)]}{v(r)} &#x3D; p(射线参数)$$</p><h2 id="地震波的走时方程"><a href="#地震波的走时方程" class="headerlink" title="地震波的走时方程"></a>地震波的走时方程</h2><h3 id="水平单层层状介质"><a href="#水平单层层状介质" class="headerlink" title="水平单层层状介质"></a>水平单层层状介质</h3><p><img src="/posts/15552/3-%E6%B0%B4%E5%B9%B3%E5%8D%95%E5%B1%82%E5%B1%82%E7%8A%B6%E4%BB%8B%E8%B4%A8.png" alt="水平单层层状介质"></p><h3 id="直达波"><a href="#直达波" class="headerlink" title="直达波"></a>直达波</h3><p>勾股定理，X&gt;&gt;h成立</p><p><img src="/posts/15552/3-%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86.png" alt="直达波"></p><p><img src="/posts/15552/3-%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86%E7%9A%84%E8%A7%A3.png" alt="直达波"></p><h3 id="反射波"><a href="#反射波" class="headerlink" title="反射波"></a>反射波</h3><p><img src="/posts/15552/3-%E5%8F%8D%E5%B0%84%E6%B3%A2.png" alt="反射波"></p><p>当震中距较大，反射波走时曲线更趋近于直达波的走时方程</p><h3 id="首波"><a href="#首波" class="headerlink" title="首波"></a>首波</h3><p><img src="/posts/15552/3-%E9%A6%96%E6%B3%A2.png" alt="首波"></p><h3 id="第一临界震中距"><a href="#第一临界震中距" class="headerlink" title="第一临界震中距"></a>第一临界震中距</h3><p><img src="/posts/15552/3-%E7%AC%AC%E4%B8%80%E4%B8%B4%E7%95%8C%E9%9C%87%E4%B8%AD%E8%B7%9D.png"></p><h3 id="第二临界震中距"><a href="#第二临界震中距" class="headerlink" title="第二临界震中距"></a>第二临界震中距</h3><p><img src="/posts/15552/3-%E7%AC%AC%E4%BA%8C%E4%B8%B4%E7%95%8C%E9%9C%87%E4%B8%AD%E8%B7%9D.png"></p><p>我们认为第二临界震中距约等于211km</p><h2 id="高速区和低速区的影响"><a href="#高速区和低速区的影响" class="headerlink" title="高速区和低速区的影响"></a>高速区和低速区的影响</h2><ul><li><p>我们一般认为随着深度增加，速度变大，但是有一些例外</p></li><li><p>如果存在低速区，走时图出现空白</p></li><li><p>如果存在高速区，走时图出现回折</p></li></ul><h2 id="体波各种震相和走时表"><a href="#体波各种震相和走时表" class="headerlink" title="体波各种震相和走时表"></a>体波各种震相和走时表</h2><ul><li><p>近震体波震相：直达波Pg、Sg，反射波PmP、PmS、SmP、SmS，经莫霍面的首波Pn、Sn。</p></li><li><p>远震体波震相</p><ul><li>震相基本写法<ol><li>P：地幔中，震源发出，向下传播的P波</li><li>S：地幔中，震源发出，向下传播的S波</li><li>p：地幔中，由震源发出，直接向地表传播的P波</li><li>s：地幔中，由震源发出，直接向地表传播的S波</li><li>K：外核中的一段P波（外核为液体，没有S波）</li><li>I：内核中的一段纵波</li><li>J：内核中的一段横波</li><li>c：核幔边界上的外反射</li><li>i：内核边界上的外反射（反射是发生在该边界靠外的一</li><li>. 发生在地球表面的反射：用反射前后的波形连续表示即可</li><li>发生在核幔边界内部的反射：用KK表示即可</li><li>发生在内核边界内部的反射：用I、J连续表示反射前后</li></ol></li></ul><ul><li>PP、SS（地面反射波）：这两个震相在震中距超过20度开始与P或S分离。</li><li>pP、sS常用与P、S的到时差用于确定震源深度。</li></ul></li><li><p>地震走时表</p><ul><li>地震波在不同震中距上传播的时间表</li><li>体波走时曲线的斜率随震中距的加大而减小，表明地球深处体波速度更大</li><li>洛夫波和瑞利波走时曲线为直线，说明速度不随震中距改变而改变，说明在地球表面传播。</li><li>S和P走时差主要依赖距离，PP和P的走时差主要依赖深度，所以用前者计算震中距，后者计算震源深度。</li></ul></li></ul><h1 id="第四章-地球内部的结构"><a href="#第四章-地球内部的结构" class="headerlink" title="第四章 地球内部的结构"></a>第四章 地球内部的结构</h1><h2 id="第一节-地球内部的结构的发现"><a href="#第一节-地球内部的结构的发现" class="headerlink" title="第一节 地球内部的结构的发现"></a>第一节 地球内部的结构的发现</h2><h3 id="一-探索的历史"><a href="#一-探索的历史" class="headerlink" title="一 探索的历史"></a>一 探索的历史</h3><p>1522年，麦哲伦船队完成了环球航行。</p><p>卡文迪许计算得到地球的平均密度为 $5.45g&#x2F;cm^3$ 说明地球内部非常致密。</p><p>一个说明地球内部不是液体的逻辑：如果地球内部是液体，在月球引力作用下，地表和海洋一样有潮汐涨落，因此将看不到海洋的潮汐现象。</p><h3 id="二-地壳的探究"><a href="#二-地壳的探究" class="headerlink" title="二 地壳的探究"></a>二 地壳的探究</h3><h4 id="1-一个误区"><a href="#1-一个误区" class="headerlink" title="1. 一个误区"></a>1. 一个误区</h4><p>地壳很薄很脆，地球内部比地壳硬。</p><h4 id="2-地壳底部的发现"><a href="#2-地壳底部的发现" class="headerlink" title="2. 地壳底部的发现"></a>2. 地壳底部的发现</h4><h5 id="莫霍面是地壳和地幔的分界"><a href="#莫霍面是地壳和地幔的分界" class="headerlink" title="莫霍面是地壳和地幔的分界"></a>莫霍面是地壳和地幔的分界</h5><p>1909年，莫霍罗维奇研究地震波，并推断存在一个界面（即莫霍面）。</p><p>莫霍面的发现是通过分析首波得到的。</p><h5 id="地壳的厚度"><a href="#地壳的厚度" class="headerlink" title="地壳的厚度"></a>地壳的厚度</h5><p>大陆地区平均厚度 $35km$ ，山高的地方会厚一些；海洋地壳的厚度只有 $5-8km$ 。</p><h4 id="3-海洋和大陆地壳的区别"><a href="#3-海洋和大陆地壳的区别" class="headerlink" title="3. 海洋和大陆地壳的区别"></a>3. 海洋和大陆地壳的区别</h4><h5 id="研究的方法"><a href="#研究的方法" class="headerlink" title="研究的方法"></a>研究的方法</h5><p>通过研究面波。不能用体波！（体波主要携带地球内部信息）</p><h5 id="面波的主要不同"><a href="#面波的主要不同" class="headerlink" title="面波的主要不同"></a>面波的主要不同</h5><ol><li>沿大洋途径传播的瑞利波扩散成的波列可以以15秒为周期持续许多分钟；而沿大陆途径传播同等距离的瑞利波记录则不出现这种长而单调的波列。</li><li>各种周期的大洋勒夫波几乎以同样速度传播，它们同时到达，产生突出的 G脉动；相反的，大陆勒夫波的速度随周期逐渐变化，使之频散。</li></ol><h5 id="研究的结论"><a href="#研究的结论" class="headerlink" title="研究的结论"></a>研究的结论</h5><p>海洋地壳的厚度在 $5-8km$ 。</p><p>用于分析海洋和大陆地壳的地质成分，并发现大陆和海洋的地质不同。这在一个关键问题上支持了大陆漂移的观点。</p><h3 id="三-地幔结构"><a href="#三-地幔结构" class="headerlink" title="三 地幔结构"></a>三 地幔结构</h3><p>存在410km和670km的两个二级速度间断面。</p><p>进一步被分为上地幔，过渡层，下地幔。</p><p>上地幔中存在软流层和“低速层”。但是软流层和地震研究中的“低速层”不是一个概念。</p><p>全球地震活动图像显示，在700公里以下，地球内部没有发现地震活动。因此下地幔被认为是板块俯冲深度的终结层。下地幔的速度梯度较小，速度的变化也较为均匀。</p><p>由于地幔可以传播S（剪切）波，地震学中通常视地幔为固体。</p><h3 id="四-液体地核的发现"><a href="#四-液体地核的发现" class="headerlink" title="四 液体地核的发现"></a>四 液体地核的发现</h3><p>奥尔德姆在1906年通过研究地震波的走时判断了地核的存在。</p><p>1914年，古登堡准确的估计地核深度为2900km（真实值2891km）。</p><h3 id="五-地球内核的发现"><a href="#五-地球内核的发现" class="headerlink" title="五 地球内核的发现"></a>五 地球内核的发现</h3><p>1926年，英格·莱曼（女）</p><p>莱曼面（L面）</p><h2 id="第二节-地球内部的圈层结构"><a href="#第二节-地球内部的圈层结构" class="headerlink" title="第二节 地球内部的圈层结构"></a>第二节 地球内部的圈层结构</h2><ol><li>壳幔界面</li></ol><p>在地下30—60km深度处,纵波速度从6-7km&#x2F;s,跳到8km&#x2F;s以上,它是地壳与地幔的分界面。这个界面是莫霍洛维奇在1909年研究Pn震相时提出来的,因此, 该界面又称为莫霍面(M面)。</p><ol start="2"><li>幔核界面</li></ol><p>在地幔内,速度随深度而增加。在大约2900km处,P波速度突然从13km&#x2F;s下降到8km&#x2F;s左右,出现地球内部第二大间断面。这是古登堡在1914年首先较精确地计算出其深度的,因此该界面又称为古登堡面(G面)。</p><ol start="3"><li>内外核分界面</li></ol><p>从2900km以下进入地核,纵波速度逐渐回升,横波速度因横波不能通过而恒为零,直到大约5000km,横波才出现,纵波速度也有明显跳跃,成为地球内部的第三大间断面。这是莱曼在1936年首先发现的,可记为L面。</p><ol start="4"><li>上下地幔的过渡层</li></ol><p>从1956年开始,布伦对地幔做了进一步分层的研究,认为地幔由上地幔(与20º走时曲线的间断相联系)、过渡层(速度变化不均匀)和下地幔(速度变化均匀)组成。</p><h3 id="布伦模型"><a href="#布伦模型" class="headerlink" title="布伦模型"></a>布伦模型</h3><p>图：A(地壳),B(上地幔),C(过渡层),D(下地幔),E(外核),F(间断面), G(内核)。</p><p><img src="/posts/15552/4-%E5%9C%B0%E7%90%83%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg" alt="地球分层"></p><p>注意莫霍面和古登堡面的深度</p><h3 id="初步地球参考模型PREM"><a href="#初步地球参考模型PREM" class="headerlink" title="初步地球参考模型PREM"></a>初步地球参考模型PREM</h3><p>（不太重要）</p><h2 id="第三节-反演问题"><a href="#第三节-反演问题" class="headerlink" title="第三节 反演问题"></a>第三节 反演问题</h2><p>正演：知道地球结构，求波速，走时；</p><p>反演：知道波速，走时，求地球结构。</p><p>地震学的任务之一就是分析、解释各种震相的起因和物理意义，并利用各种震相走时曲线推测地球内部的速度结构。</p><p>这种方法和光学或声学中的反演方法相似。</p><h2 id="第四节-地球层析成像，地球内部三维结构"><a href="#第四节-地球层析成像，地球内部三维结构" class="headerlink" title="第四节 地球层析成像，地球内部三维结构"></a>第四节 地球层析成像，地球内部三维结构</h2><p>没有什么内容。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>英格·莱曼发现地球内核的思路</li></ol><p>“正演问题”，提出可能的模型，并计算、预测理论走时，将预测结果同实际结果相比较。</p><ol start="2"><li>为什么地震学中把地幔视为固体</li></ol><p>因为可以传递横波（S波），能够承载剪切力。</p><h1 id="第五章-地震机制"><a href="#第五章-地震机制" class="headerlink" title="第五章  地震机制"></a>第五章  地震机制</h1><h2 id="第一节-断层"><a href="#第一节-断层" class="headerlink" title="第一节 断层"></a>第一节 断层</h2><p>断层（fault）是沿破裂面两侧岩块发生显著相对位移的断裂构造。</p><p>受力状态下，岩石发生变形。</p><p>冷的脆性岩石容易发生脆性破裂（断层），从而导致天然地震。</p><p>地球深部的岩石由于温度较高，在受力状态下岩石容易发生弯曲或流动。</p><p>一般情况下, 处于应力状态的岩石或者流动或者发生破裂，主要取决于温度。</p><p>处于弹性状态时，岩石在破裂前能够承受一定程度的应变（应变能）.</p><p>当应力撤销时，岩石又恢复到原先的状态.</p><p>这时岩石的表现叫弹性体。</p><p>断层的几何术语：</p><ul><li><p>断层上盘、下盘</p></li><li><p>走向：站在断层的地表面上，上盘在正右方，面对的方向是走向方向。断层面和地表交线的走向方向与正北的顺时针夹角叫断层的走向</p></li><li><p>倾角：和水平地面的夹角</p></li><li><p>滑移：上盘相对于下盘的滑动方向。</p></li></ul><p>断层类型：</p><ul><li><p>正断层：上盘往下滑（正常就是向下滑）。</p></li><li><p>逆断层：上盘往上滑。</p></li><li><p>（左&#x2F;右旋）走滑断层：站在右面看左边，左边往左是左旋，左边往右是右旋。</p></li><li><p>斜滑断层</p></li></ul><p><img src="/posts/15552/5-%E6%96%AD%E5%B1%82.png" alt="断层"></p><p>应力</p><ul><li><p>断层面上的应力超过其摩擦力时断层发生滑动。</p></li><li><p>我们用三种应力来描述地球内部的应力状况，两个水平的一个垂直的.</p></li><li><p>三种主应力作用在断层上，两个水平的一个垂直的。</p><ul><li>如果垂直压应力：<ul><li>最大－正断层</li><li>最小－ 逆断层</li><li>中等－走滑断层</li></ul></li></ul></li></ul><p><img src="/posts/15552/5-%E5%BA%94%E5%8A%9B-1.png" alt="断层"><img src="/posts/15552/5-%E5%BA%94%E5%8A%9B-2.png" alt="断层"><img src="/posts/15552/5-%E5%BA%94%E5%8A%9B-3.png" alt="断层"></p><h2 id="第二节-弹性回跳原理"><a href="#第二节-弹性回跳原理" class="headerlink" title="第二节 弹性回跳原理"></a>第二节 弹性回跳原理</h2><p>地震时发生的唯一物质移动是破裂面两边的物质向减少弹性应变的方向突然发生弹性回跳。这种移动随着破裂面的距离增大逐渐衰减，通常延伸仅数千米</p><p>弹性回跳理论的主要论点</p><ol><li><p>造成构造地震的岩石体破裂是由于岩石体周围地壳的相对位移产生的应变超过岩石强度的结果；</p></li><li><p>这种相对位移不是在破裂时突然产生的，而是在一个比较长的时期内逐渐达到其最大值的；</p></li><li><p>地震时发生的唯一物质移动是破裂面两边的物质向减少弹性应变的方向突然发生弹性回跳。这种移动随着破裂面的距离增大而逐渐衰减，通常延伸仅数千米；</p></li><li><p>地震引起的振动源于破裂面。破裂起始的表面开始很小，很快扩展得非常大，但是其扩展速率不会超过岩石中P波的传播速度；</p></li><li><p>地震时释放的能量在岩石破裂前是以弹性应变能的形式储存在岩石中的。</p></li></ol><p>地震能</p><p>地震发生时，大部分应变能转化为热能(克服擦力而消耗掉了)，只有百分之几的应变能转为地震波。</p><p>地震能&#x3D;克服摩擦力消耗的热能+地震波能量</p><p>地震效率&#x3D;地震波能量 &#x2F;地震能，在7.5%~15%之间，小于20%</p><h2 id="第三节-震源机制解"><a href="#第三节-震源机制解" class="headerlink" title="第三节 震源机制解"></a>第三节 震源机制解</h2><p>震源辐射图案，黑色代表挤压，白色代表拉伸</p><p><img src="/posts/15552/5-%E9%9C%87%E6%BA%90%E8%BE%90%E5%B0%84%E5%9B%BE%E6%A1%88.jpg" alt="辐射图案"></p><p>初动：地震到来如果向上则为挤压</p><p>震源机制解</p><p>正断层比较陡，逆断层比较缓</p><p>断层识别：正断层</p><p><img src="/posts/15552/5-%E6%AD%A3%E6%96%AD%E5%B1%82.png" alt="正断层"></p><p>哪个是断层面？</p><p>逆断层</p><p><img src="/posts/15552/5-%E9%80%86%E6%96%AD%E5%B1%82.png" alt="逆断层"></p><p>哪个是断层面？</p><h2 id="第四节-板块构造学说"><a href="#第四节-板块构造学说" class="headerlink" title="第四节 板块构造学说"></a>第四节 板块构造学说</h2><p>板块构造学说发展的三个阶段：大陆漂移、海底扩张、板块构造</p><p>板块—刚性（或半刚性的）固态的巨大板状岩石块体。</p><p>板块构造—地球的最外层由若干个大小不等的板块组成，他们飘浮在相对较软的流动的热物质上作相互运动。</p><p>大陆漂移：1915年，由Wegner提出大陆象一副巨型七巧板拼在一起成为一个超级大陆Pangaea</p><p>大陆漂移的证据：形状复杂的板块拟合、化石、岩石、山脉、古气候数据</p><p>海底扩张：1959年，美国普林斯顿大学地质学教授Harry Hammond Hess 发出了未经正式出版的手稿，阐述了海底扩张的基本思想。</p><p>板块构造</p><p>地球内部主要由三层构成：地壳、地幔、地核</p><p>七大板块：印度-澳大利亚板块、太平洋板块、北美板块、南美板块、欧亚板块、非洲板块、南极板块</p><p>版块边界类型：</p><p>扩散边界—新的地壳在此产生。</p><p>汇聚边界—地壳在此消失（消减带）。</p><p>转换边界—由于扩散边界的扩散速度差异而产生的走滑断层，板块之间在此作相互水平运动。</p><p>板块边界区域—有一定宽度的带，没有清晰的板块边界，相互作用不清楚。</p><p>板块理论的补充－地幔热柱：绝大多数地震和火山都发生在板块边界上，但也有一些地震和火山发生在板块的内部。</p><p>断层作用反映了板块运动。</p><p>扩散边界 &#x3D; 正断层</p><p>汇聚边界 &#x3D; 逆断层</p><p>走滑边界 &#x3D; 走滑断层</p><p>海底扩张在板块构造的重要意义：</p><p>海底扩张阐明了大陆漂移的物理机制：大陆随着海洋地壳一起漂移，海洋地壳在洋中脊处产生，在海沟处消亡。</p><p>板块 &#x3D; 地壳 + 地幔上层比较坚硬的岩石部分</p><h2 id="第五节-全球地震活动概况"><a href="#第五节-全球地震活动概况" class="headerlink" title="第五节  全球地震活动概况"></a>第五节  全球地震活动概况</h2><p>全球性的地震带有三个：环太平洋地震带、阿尔卑斯—喜马拉雅地震带(即欧亚地震带)和海岭（大洋中脊）地震带。</p><p>大约全球百分之八十的浅震、百分之九十的中源地震以及全部深震都集中在环太平洋地震带上。</p><p>中国<strong>不</strong>是地震最强烈的国家</p><h2 id="第六节-不同类型的地震"><a href="#第六节-不同类型的地震" class="headerlink" title="第六节  不同类型的地震"></a>第六节  不同类型的地震</h2><p>不同类型的地震：天然地震（构造&#x2F;断层地震、火山地震、陷落地震&#x3D;90：7：3）、非天然地震</p><p>92%的地震发生在地壳中， 其余的发生在地幔上部</p><p>鉴别地下核试验的地震学方法：</p><p>震中位置和震源深度</p><p>波形复杂性</p><p>初动解</p><p>P波与S波振幅比</p><p>地震波频谱</p><p>震级比（mb:Ms）</p><p>地下核爆炸引起的地震的效率小于千分之一</p><h1 id="第六章-地震仪及地震基本参数的测定"><a href="#第六章-地震仪及地震基本参数的测定" class="headerlink" title="第六章 地震仪及地震基本参数的测定"></a>第六章 地震仪及地震基本参数的测定</h1><p>录播：4.14后半截+4.21前半截</p><p>第一节  张衡的候风地动仪</p><p>第二节  现代地震仪</p><p>第三节  地震台与地震观测台网</p><p>第四节  地震定位</p><p>第五节  震级测定</p><ul><li><p>地震观测推动了地震学的诞生和发展，地震观测是地震学的基础，它对地震学乃至整个地球科学的发展起着极其重要的作用。</p></li><li><p>地震仪(seismograph)是一种可以接收地面振动，并将其以某种方式记录下来的装置。</p></li><li><p>仅记录地震波到达时间的仪器只能叫验震器。</p></li><li><p>由于地震动的振幅和频率变化大，地震记录仪器是很恨复杂的。真正可以有效记录地震细节的地震仪价值不菲。</p></li></ul><h2 id="第一节-张衡的候风地动仪"><a href="#第一节-张衡的候风地动仪" class="headerlink" title="第一节  张衡的候风地动仪"></a>第一节  张衡的候风地动仪</h2><ul><li><p>候风地动仪是中国古代观测地震的仪器，是<em><strong>东汉张衡于公元132年创制的</strong></em>。【板书标红】</p></li><li><p>候风地动仪是利用惯性原理，在仪器内底部中央，立有一根都柱，即倒立的惯性振摆。围绕都柱设有八条滑道。滑道上面，装有八组“牙机”，即传动杠杆，其外端呈曲尺形，穿有枢轴，通出仪器外面与龙头上颌接合。</p></li><li><p>候风地动仪的灵敏度很高，据史料记载，候风地动仪曾接收到震中在陇西、而洛阳人未曾感觉到的地震所引起的地面振动。</p></li><li><p>随着自然科学和社会科学的发展，张衡的这项发明引起国内外高度的重视和深入的研究。（扯淡，是外国人先发现）</p></li></ul><p><em><strong>张衡地震仪是验震器，不是地震仪&#x2F;地震预警仪器&#x2F;地震预报仪。【板书】</strong></em></p><h3 id="复原研究的三个里程碑"><a href="#复原研究的三个里程碑" class="headerlink" title="复原研究的三个里程碑"></a>复原研究的三个里程碑</h3><ul><li>1875年，日本人服部一三，文字变猜想图形</li><li>1951年，王振铎，变成展览模型</li><li>2008年，科学复原，变成科学仪器，具有了科学生命</li></ul><hr><ul><li><p>王振铎经过对历史资料的整理和研究，并总结了一些地震学家的研究成果，于1959年又将张衡的候风地动仪重新复原，陈列在中国历史博物馆内。</p></li><li><p>以中国地震局地球物理研究所冯锐研究员为首的候风地动仪课题组，希望研制出和原先一样的候风地动仪</p></li></ul><p>地动仪是验震器——不是地震它不动，只有地震它才晃</p><p>报警器——只要地动，我就动</p><ul><li><p>限于工艺，张衡的地动仪不会是非常精致的。</p></li><li><p>从近代科学意义上看，候风地动仪不应该算作地震仪，只能是验震器，除了功能不如近代地震仪，主要原因是它没有时间记录。</p></li><li><p>即使地面震动晃动地动仪内的摆，摆的方向也不一定能惟一地显示出震源方向。</p></li><li><p>遗憾的是，这精巧的仪器失传了，而且，详细的内部机制也没有被记录流传下来。（仪器生产肯定是因为不好、没用了…）</p></li><li><p>直到很久以后，才发明了能真实测量地动整个过程的地震仪。</p></li><li><p>现代地震仪和地动仪一样，利用的是摆的惯性原理。肯定地说，地动仪是现代地震仪的先驱。国外一千多年后才出现类似的仪器。</p></li></ul><p>但还是科学瑰宝：知道是惯性问题</p><h2 id="第二节-现代地震仪"><a href="#第二节-现代地震仪" class="headerlink" title="第二节  现代地震仪"></a>第二节  现代地震仪</h2><h3 id="一、现代地震仪的诞生"><a href="#一、现代地震仪的诞生" class="headerlink" title="一、现代地震仪的诞生"></a>一、现代地震仪的诞生</h3><p>18世纪早期，在欧洲才出现记录地震的仪器，当时是用摆显示地动。然而，地震仪的发展是缓慢的，早期的验震器不能记录地震波到达的时间，也不能给出地震动的永久记录。</p><p>1880至1890，访日的英国人约翰·米尔恩、詹姆斯·尤因和托马斯·格雷，在日本研制出记录地震动随时间变化的第一架具有科学意义而且较为实用的地震仪。</p><p>二战后，地震仪的放大倍数提高到数万倍甚至数百万倍，同时也展宽了观测频率范围。新的仪器不断出现，运用计算机快速处理和储存地震资料，使地震学的发展步入了一个崭新的阶段。</p><h3 id="二、现代地震仪工作原理"><a href="#二、现代地震仪工作原理" class="headerlink" title="二、现代地震仪工作原理"></a>二、现代地震仪工作原理</h3><p>虽然现代地震仪比米尔恩的地震仪复杂得多，但是所依据的基本原理是一样的，原理就是惯性。</p><p>地震时，地面同时在三个方向上运动：上下、东西和南北。地面运动可以是位移、速度或加速度，它们是随时间变化的三维矢量，为了研究完整的地面运动，一定要将这三个分量都记录下来。</p><p>地面振动幅度的大小在很大一个量级范围内变化。</p><p>记录不同频段地震波的长周期、短周期、中长周期及宽频带等具有不同频率响应特性的地震仪。</p><p>基本原理：地震仪是建造在以一套弹簧—摆为拾震器的基础上，即俗称的摆式地震仪。</p><p>现代地震仪(Seismometer)：意大利地质学家帕尔米里于1856年制造的电磁地震记录仪，它已能记录地震到达当地的时间</p><p>现代化的野外地震仪</p><p>地震图(Seismograms)</p><p>第一个远震记录：在德国Potsdam记录到的日本发生的地震</p><p>1906年旧金山地震时，加利福尼亚大学里克观测台尤因地震仪在旋转圆盘上记录了地面南北方向和东西方向上的地震波动</p><p>1983-4-3哥斯达黎加地震在德国贝尔恩台记录的运动垂直分量 P波在地表反射一次或两次后分别为PP和PPP波，如在最后一次反射后 转换为S波，则得到PS和PPS波，S波在地表反射可产生SS和SSS波。 记录中最明显的是通过大洋路径传播过来的瑞利波</p><p>常见的地震仪一般由拾震器、放大器（换能器）及记录系统三个部分组成。</p><p>拾震器是接收地面运动的一种传感器，它主要有一个摆锤，通过弹簧拴在一个能与地面一起运动的固定支架上。</p><p>地震仪的放大技术是逐渐发展的。最早采用的是机械放大和光杠杆放大，将摆的运动通过杠杆放大，直接在熏烟纸上记录或由摆反射的光写在相纸上。这种早期地震仪的放大倍数到千倍级已经很有难度了。现代地震仪基本采用电子放大器以提高地震仪的灵敏度。<em><strong>此时就必须采用换能装置，先将地面运动的机械信号转换成电信号。</strong></em></p><p>由于模拟记录图上的地震震相到时及地震波振幅大小只能靠人工用刻度尺读取，存在较大误差；如要借用计算机进行波形分析，还需要将地震波形记录进行数字化处理；此外，模拟记录的保存及传输、交换均不方便。</p><p>随着数字电路技术的高速发展和普及，传统的模拟记录正逐步被数字记录所取代。</p><h2 id="第三节-地震台与地震观测台网"><a href="#第三节-地震台与地震观测台网" class="headerlink" title="第三节  地震台与地震观测台网"></a>第三节  地震台与地震观测台网</h2><h3 id="一、地震台"><a href="#一、地震台" class="headerlink" title="一、地震台"></a>一、地震台</h3><p>地震台（seismic station）是指利用各种地震仪器进行地震观测的观测点，是开展地震观测和地震科学研究的基层机构。</p><p>很久以前的地震台多是建在天文台附近，因为可以获得准确的时间。</p><p>米尔恩1895年从日本回到英国，在怀特岛的赛德建立了地震台，后来该台成为著名的地震研究中心。不到几年时间，他就组建了第一个全球地震台网，10个台在大不列颠，30个台在国外。</p><p>随着在赛德的记录积累，他开始系统地分析地震类型。地震台的数目稳步增加，到1957年国际地震概要（International Seismological Summary）列入了大约600个地震台。国际地震概要是由米尔恩的赛德台的继承者在英国操作的一个国际组织。</p><p><em><strong>由于米尔恩对地震观测的贡献，他被称为现代地震学的奠基人。</strong></em></p><p>北京国家地球观象台（简称北京台）的前身是鹫峰地震台．鹫峰地震台是我国自己创建的最早的地震台，1930年开始记录，1937年因日军大举侵略中国而被迫停止运行．1955年，地震台改建在北京西郊白家疃，1957年恢复地震观测，同时增加地磁观测项目．1982年年底在台站南侧约2千米处修建了长202米的大型山洞，为开展高灵敏度地球物理观测和仪器研制、运行试验提供了良好的环境。1983年5月北京台被国家地震局（现中国地震局）确定为<em><strong>中美合作中国数字地震台网（CDSN)的示范性数字地震观站</strong></em></p><h3 id="二、地震观测台网"><a href="#二、地震观测台网" class="headerlink" title="二、地震观测台网"></a>二、地震观测台网</h3><p>地震台网（seismologic network）是由各级地震台、 站所构成的观测网络。按其控制震级的大小分为微震台网和强震台网；按监视范围分为全球地震台网、国家地震台网和区域地震台网；按台站仪器设置分为长周期地震台网和短周期地震台网；按信息记录方式还可分为模拟地震台网和数字地震台网等。</p><p>地震台网内观测数据由各台站定时发往地震数据处理及分析预报中心，中心负责数据的收集、整理、编辑和储存以及对数据的综合分析研究。</p><p>为记录不同震级和距离的地震一般要设置短、中长和长周期地震仪；相应的记录器也要有大、中、小的振幅类型 才能获得适合于分析用的真实的记录。</p><ul><li>全球地震台网GSN (Global Seismic Network)</li></ul><p>由128个超宽频带数字式观测台组成</p><p>为研究地球构造与地震而设立的极高质量的标准地震台</p><h2 id="第四节-地震定位"><a href="#第四节-地震定位" class="headerlink" title="第四节  地震定位"></a>第四节  地震定位</h2><p>地震定位是地震学中最经典、最基本的问题之一，提高定位精度也一直是地震学应用研究的重要课题之一。</p><p>地震学家们在建立地震台（网）后的首要任务就是找一种方法精确地确定震中。如果可能的话，也确定每次记录到的地震的震源。</p><p>1879年之前，没有地震仪，通常把地震破坏罪严重的地方定为震中，也叫宏观震中。</p><p>利用仪器记录进行震源定位始于欧洲和日本，最初使用方位角法，随后是几何作图法和地球投影法。</p><p>20世纪60年代后，计算机开始应用于地震定位，目前作图定位法已被计算机定位法代替。</p><p>为了直观认识地震定位的基本原理，本节介绍一种最简单的方法，即<em><strong>三角测量法</strong></em>：通过直接的三角测量发现震中的位置。</p><p>最简单的方法是通过直接的三角测量发现震中的位置。根据从其他地区地震或者爆破研究收集的时间资料，可以画出曲线来显示P波或S波从震源传播不同距离所需的平均时间。这些地震传播时间曲线（时-距曲线）是确定地震仪到震源距离的最基本工具。</p><p>假设在二维平面上，而且震源在地表（震源即震中），又假定有3个地震台，每一台记录到的都是同一个地震，而且各台位于震源的不同方向上。这3个台站的观测人员能够读到P波和S波的到达时间。</p><p>因为P波传播速度比S波快，所以这两种波传播得越远，它们的波前间隔的时间就越长。如果有了P波和S波到达的时间，从这两种波型的抵达某台时间间隔将可以直接求得震源到该地震台的距离。</p><p>画3个圆，每个圆以一个地震台为圆心，计算得到的距离（震中距）为半径。这3个圆将会相交于所要求的震中点。</p><p>这3个数据最好是来自距震中为不同方向和不同距离的3个地震台。如果还要估算震源深度，需要第四个测量数据。</p><p><img src="/posts/15552/6-%E8%AE%A1%E7%AE%97%E5%AE%9E%E4%BE%8B-1.png" alt="计算实例"></p><p><img src="/posts/15552/6-%E8%AE%A1%E7%AE%97%E5%AE%9E%E4%BE%8B-2.png" alt="计算实例"></p><p>通过计算机程序应用复杂的统计方法，分析许多台站P波和S波记录，并且确定发生在世界任何地方地震的震源位置。</p><p>为保证精度，地震台站必须合理地均匀地围绕着震中布设，而且应该有近台A和远台的均匀分布。</p><p>通过对在同一地区已知位置地震的先前记录的校对计算，可以更精确地定位震源。</p><p>今天在世界的多数地区，<em><strong>震中定位的精度大约为10千米，震源深度的精度更差，大约为20千米。【红字板书】</strong></em></p><h2 id="第五节-震级测定"><a href="#第五节-震级测定" class="headerlink" title="第五节  震级测定"></a>第五节  震级测定</h2><p>震级是表示地震大小的等级。依据释放能量多少，地震分为不同震级，震级越高，释放能量越多，破坏力越大。</p><p>世界上常用“里氏震级”标准区分地震震级。</p><p>“里氏震级”最初由地震学家查尔斯·里克特（Charles Ricer）（下页图）1935年在美国加州理工学院发明的。里克特提出按照地震仪器探测到的地震波的振幅将地震分级。</p><p>这种分级系统最初只用于衡量南加州当地的地震的大小，<em><strong>现在全世界地震的研究都使用这种分级系统。</strong></em></p><p>因为地震的大小变化范围很大，所以用对数来压缩测量到的地震波振幅是很方便的。</p><p>精确的定义是：里氏震级ML是最大地震波振幅（以微米为单位）以10为底的对数。</p><p>$$M_L &#x3D; lg(A)$$</p><p><em><strong>(板书)</strong></em></p><p>一种被称之为伍德-安德森（Wood-Anderson）的特殊地震仪记录到的振幅测量精度达到1‰毫米。里克特没有指定特殊的波型，因此最大振幅可以从有最高振幅的任何波形上取得。</p><p><em><strong>由于一般振幅随着距离增大而减少，里克特选择距震中100千米的距离为标准。</strong></em></p><p>按着这个定义，对一个100千米外的地震，如果伍德-安德森地震仪记录到1厘米的峰值波振幅（即1‰毫米的10000倍）,则震级4。</p><p>例: 振幅是一毫米，震级是3</p><p>用一张特殊的标度图，计算一个地震的ML的过程是很简单的：</p><ol><li>用S波与P波到达的时间差，计算出距震源的距离（S-P&#x3D;24秒）；</li><li>在地震图上测量出波运动的最大振幅（23毫米）；</li><li>在框图3.2左边选取适当的距离（左边）点，在右边选取适当的振幅点，两点联一直线，从它与中央震级标度线相交点可读出ML&#x3D;5.0。</li></ol><p>震级本身没有任何上下限（虽然地震大小有上限）。自本世纪有了地震仪以后所记录到的地震仅有几次震级达到8.5级以上（下页图）。例如，1964年3月27日在阿拉斯加威廉王子海湾的大地震的里氏震级约为8.6。另一方面，小断层的滑动可能产生小于零震级的地震（即负值）。</p><p>在局部地区记录的非常灵敏的地震仪可探测到小于-2.0级的地震。<em><strong>这种地震释放的能量大约相当于一块砖头从桌子上掉到地面的能量。</strong></em></p><h3 id="关于媒体常用的里氏震级的说明"><a href="#关于媒体常用的里氏震级的说明" class="headerlink" title="关于媒体常用的里氏震级的说明"></a>关于媒体常用的里氏震级的说明</h3><p>地震台常用的震级已经包括3种新的震级，标为MS、mb和Mw。</p><p>在新闻介和大众中仍然使用里氏震级ML。这是媒体引起的错误，因为ML起初是专为测定南加州地方小震的大小而创立的震级，对较大的地震并不适合，例如说汶川大地震是里氏8.0级是不对的，其实是面波震级MS。</p><p>但是，地震学界也不打算纠正这种民众的错误，主要大家已经习惯了里氏震级。</p><h3 id="ML、MS和mb三种震级都属里氏震级系统"><a href="#ML、MS和mb三种震级都属里氏震级系统" class="headerlink" title="ML、MS和mb三种震级都属里氏震级系统"></a>ML、MS和mb三种震级都属里氏震级系统</h3><p>由于里氏震级所用的波形没有被限定，而且伍德-安德森地震仪仅有有限的记录能力，因此在地震研究中ML不再广泛使用。由于浅源地震具有易记录到的面波，地震学家们选择周期近20秒的面波的最大振幅计算震级，这样求出的震级称作<em><strong>面波震级MS</strong></em>，ML震级是为了用于当地地震而提出的，而MS震级可用于距接收台站相当遥远的地震。对于远距离的地震，MS值近似地给出当地里氏震级的补充，并且综合地给出中强地震带来的潜在损失的合理估计。</p><p>MS震级不能用于深源地震，因为深源地震不能激发显著的面波。所以地震学家们发展了第二种震级，mb，它是根据P波的大小而不是根据面波的大小确定地震的震级。所有的地震都可以清楚地读到P波的初始，因此用P波震级mb有很大优点，它可以提供深源、浅源甚至远距离的任何地震的震级值。</p> <!-- 这个公式不需要会 --><p>对同一地震采用不同的震级标度测量，测量值是不同的。为了统一，在各种震级标度间建立了用于换算的一系列经验性公式。</p><h3 id="地震矩"><a href="#地震矩" class="headerlink" title="地震矩"></a>地震矩</h3><p>对于特大型地震，用里氏系列的震级标度测量将出现“饱和”问题。</p><p>用震级描述地震的大小或强度非常方便，但是这个参数没有物理意义。</p><p><em><strong>地震矩</strong></em>是由受构造应力影响使断裂面突然滑移的力学模型，推导出来的地震整体大小的量度。它是1966年美国地震学家安艺（Aki）提出的。</p><p>现在受到地震学界欢迎，因为它与断裂破裂过程的物理实质直接联系。根据它能推断活动断裂带的地质特性。</p><p>地震矩定义为岩石的弹性刚度、施力的面积和突然滑移中断裂的位错量三者的乘积。这种量度的好处是，它不像基于地震波幅的量度，受到波的传递过程中岩石摩擦使能量耗散的影响。在适宜的情况下，地震矩能够简单地从在野外测量的地面破裂的长度和从<em><strong>余震深度推断的破裂深度估算出来。</strong></em></p><p><em><strong>地震矩可以描述从最小到最大的地震震级变化。</strong></em></p><p>这种识别地震大小的方法的优点是通过分析地震图或者通过野外测量地震断层破裂的尺寸，包括深度，就可以计算出地震矩。从任何普通的现代地震仪记录到的地震图都可以计算出地震矩，而且该方法考虑到地震发生时出现的所有波形。由于其上述优点，现在人们多半都计算地震的矩震级，记为Mw。</p><p><em><strong>Mw震级给出了地震大小更具有物理意义的衡量，特别是对最强烈地震。</strong></em></p><p><em><strong>地震距不需要会，了解即可</strong></em></p><p>由于地震波能量辐射花样的方位性，地震波传播路径的影响、记录台台基效应的影响等，不同台站即使测定同一个地震的震级值也会有所不同，这是经常发生的事情。</p><p>震级是表征地震强弱的量度，但震级的测量精度是有限的，一般认为，震级的测定精度在0.3左右。</p><p>强震加速度及加速度地震仪</p><ul><li>近震、强震记录的需要</li><li>工程地震的需要</li><li>地震信息的完整</li></ul><p><img src="/posts/15552/6-%E6%9D%BF%E4%B9%A6.jpg" alt="板书"></p><h1 id="第七章-地震预报"><a href="#第七章-地震预报" class="headerlink" title="第七章 地震预报"></a>第七章 地震预报</h1><p>·有记录以来最大的地震：智利地震</p><p><img src="/posts/15552/7-%E5%BC%BA%E9%9C%87%E5%8E%86%E5%8F%B2.png" alt="较大地震记录"></p><p>地震灾害与其他灾害相比不同的特点：突发性强、破坏大，成灾广泛、社会影响深远、防御难度大、次生灾害多、持续时间长、地震灾害具有某种周期性；</p><p>地震预报从20世纪60年代开始在全球进行，但目前为止唯一成功预报的是</p><p><em><strong>1975 年辽宁海城 7.3 级地震的预报</strong></em></p><p>预测不等于预报——预测指学者将结果汇报给国务院，而预报由政府发布；（地震预报是地震学中高度争议性的问题）</p><p>地震预报三要素：未来地震发生的时间、地点、强度；</p><p>地震预报依赖于地震前兆信息，并且方法具有可重复性而适用于任何破坏性地震；</p><p>地震预报方法的三个方面：地震地质方法、地震统计方法、地震前兆方法（三个方面并不彼此独立不相关，而是互相有联系，将三种方法配合使用效果会更好）：</p><ol><li>地震地质方法：地震是地下构造活动的反应，理应发生在地质上比较活动的地方，尤其在最新构造运动的地区；断层成因方面地震是岩层段错（由于剪切应力）的结果，地面上应首先关注剪切应力表现最大的地区；但地质方法时间尺度太大，需要与其他方法配合使用：<ol><li>大地震常发生在现代构造差异运动最强烈的地区或活动的大断裂附近，</li><li>受构造活动影响的体积和岩层的强度越大，可能产生的地震越大；</li><li>构造运动的速度越大，岩石强度越弱，地震频度越高；</li><li>在一个构造活动区里，断层错动并不是在各处都同时发生，而是有时在这里，有时在那里 <em><strong>（随机性）</strong></em>；</li></ol></li><li>地震统计方法：适用于对地震的物理过程认识还不够清楚的时候，其可行度取决于数据多寡；</li><li>地震前兆方法：重点是识别和观察；</li></ol><p>古登堡-里克特关系</p><p>$$logN &#x3D; a-bM$$</p><p>地震级降低一级，地震发生次数变为原来 10 倍；</p><p>地震空区：有地震倾向、地震的能量释放低于平均水平的区域如环太平洋地区；</p><p>地震是高度非线性过程，迄今地震学家未找出一种确定性的地震前兆；</p><p>小补充——如何地震预报：地点——找构造活动强烈的地区，由大到小慢慢锁定，再通过异常出现的次序，最先出现的可能是震中，参考过去历史资料；时间：看异常现象发生的速度量变 &#x2F; 质变？异常诱导因素；强度：异常现象的发生规模&amp;参考历史地震资料；</p><p>（这章内容少，比较简单，记忆性和了解性比较多）</p><h1 id="第八章-宏观地震学"><a href="#第八章-宏观地震学" class="headerlink" title="第八章 宏观地震学"></a>第八章 宏观地震学</h1><p><img src="/posts/15552/8-1.jpg" alt="笔记1"></p><p><img src="/posts/15552/8-2.jpg" alt="笔记1"><img src="/posts/15552/8-3.jpg" alt="笔记1"></p><h1 id="第九章-勘探地震学"><a href="#第九章-勘探地震学" class="headerlink" title="第九章 勘探地震学"></a>第九章 勘探地震学</h1><p>（这章内容很少，只需要记住下面两个知识点！）</p><ol><li><p>勘探地震学是应用在石油勘探中的一项重要技术。石油勘探主要有三大类方法：地质法、地球物理方法（物探）、钻探法。</p></li><li><p>勘探地震学的地震资料解释成功率一般在10-30%，在如今的实际生产中解释成功率达到30%已经是相当不错的水平了。</p></li></ol><p><img src="/posts/15552/9-%E7%AC%94%E8%AE%B0.jpeg" alt="课堂笔记"></p><h1 id="第十章-海啸"><a href="#第十章-海啸" class="headerlink" title="第十章 海啸"></a>第十章 海啸</h1><h2 id="海啸定义："><a href="#海啸定义：" class="headerlink" title="海啸定义："></a>海啸定义：</h2><p>海啸是一种波长很长的水波，由海底突然垂直位移或任何积水体的破坏产生。海啸与潮汐、风或风暴无关。海啸可以由地震以外的机制产生（如山崩、陨石海啸等）。</p><h2 id="海啸的产生机制："><a href="#海啸的产生机制：" class="headerlink" title="海啸的产生机制："></a>海啸的产生机制：</h2><p>海啸通常由海底地震引起。地震发生时 <em><strong>断层两侧的板块如果产生垂直方向的相对位移</strong></em> ，则覆盖的海水也会随之产生垂直方向上的相对位移，这样海水原本的平衡状态就会被破坏，抬升板块上方的海水会变高，势能增加，然后向势能比较低的下沉板块方向流动。</p><p>也就是说， <em><strong>海底地震会使震中附近的海水突然获得大量势能</strong></em> ，在引力的作用下，这个势能会很快的 <em><strong>转化为动能</strong></em> ，使海水具有很高的速度，形成巨浪向四周扩散，从而引发海啸。</p><p>最可能引发海啸的是断层破裂面在海底地表的逆冲断层地震</p><h2 id="海啸的产生条件："><a href="#海啸的产生条件：" class="headerlink" title="海啸的产生条件："></a>海啸的产生条件：</h2><ol><li><p>地震要发生在深海区：地震释放的能量要想转变为巨大水体的波动能量并具有很强的破坏力，地震必须要发生在深海，只有这样海底上方才会有足够的水体，发生在浅海地区的地震是产生不了海啸的</p></li><li><p>地震震级要大：浪高是海啸最重要的特征，海岸上观测到的海啸浪高的对数就是海啸的等级。通常用海啸的等级来表示海啸的规模</p></li></ol><p>注：海啸等级m和地震震级M的统计关系：</p><p>$$m&#x3D;2.61M﹣18.44$$</p><p><em><strong>$M＞6.5$ 的海底地震才有可能引发灾害性的海啸</strong></em></p><p>太平洋海啸预警中心发布海啸警报的必要条件是：①海底地震的震源深度小于60km，②同时地震的震级需要大于7.8级</p><ol start="3"><li>具备开阔并逐渐变浅的海岸条件：近海岸的海水波速减慢，后面的海水高速前涌，波高急剧抬高，形成高能量的“水墙”</li></ol><h2 id="海啸和风浪的差异："><a href="#海啸和风浪的差异：" class="headerlink" title="海啸和风浪的差异："></a>海啸和风浪的差异：</h2><p>多数海水的波是表面波，随着深度增加，质点运动越来越小</p><p>海啸是从深海海底到海面的整个水体的波动</p><p><img src="/posts/15552/10-%E6%B0%B4%E6%B3%A2.jpg" alt="水波或地震面波中水或岩石质点的椭圆运动轨迹"></p><h2 id="浅水波："><a href="#浅水波：" class="headerlink" title="浅水波："></a>浅水波：</h2><p>波长远大于水深</p><p>海啸是一种特殊的浅水波，其特殊之处在于它的动力来自海底地震或火山，而非风力，并且海水的深度很大，这些决定了海啸具有长波长，能量大和传播速度快三个特点</p><p>海啸速度</p><p>$$V&#x3D;\sqrt{g\cdot d}, d为水深$$</p><p>地震发生的地方海水越深，海啸速度越快</p><p>波的频率和周期只与震源有关，所以由深水波变成浅水波的这一过程里，海浪的周期和频率不变。速度变小，周期不变，由V&#x3D;L&#x2F;T知波长变小；速度和波长均变小，由于机械波携带的能量守恒，振幅变大</p><p><img src="/posts/15552/10-%E9%A3%8E%E6%B5%AA%E5%92%8C%E6%B5%B7%E5%95%B8.png" alt="风浪和海啸的尺度对比"></p><p>海啸的波长远远大于海浪，同时，它的振幅（浪高）又比海浪小，所以在深水区，船舶是几乎无法感知的</p><h2 id="海啸按成因可分为三类：地震海啸、火山海啸和滑坡海啸。"><a href="#海啸按成因可分为三类：地震海啸、火山海啸和滑坡海啸。" class="headerlink" title="海啸按成因可分为三类：地震海啸、火山海啸和滑坡海啸。"></a>海啸按成因可分为三类：地震海啸、火山海啸和滑坡海啸。</h2><ol><li>地震海啸：</li></ol><p>海底发生地震时，海底地形发生急剧升降变动引起海水强烈扰动。其机制有两种形式：“下降型”海啸和“隆起型”海啸。</p><ol start="2"><li><p>火山海啸</p></li><li><p>滑坡海啸</p></li></ol><p>大多数海啸都是地震海啸，火山海啸和滑坡海啸很少发生，即使发生，破坏力也比较小。</p><h2 id="相对受灾区来讲，海啸可分为近海海啸和远洋海啸两类。"><a href="#相对受灾区来讲，海啸可分为近海海啸和远洋海啸两类。" class="headerlink" title="相对受灾区来讲，海啸可分为近海海啸和远洋海啸两类。"></a>相对受灾区来讲，海啸可分为近海海啸和远洋海啸两类。</h2><p>远洋海啸和近海海啸的分类是相对的。</p><h2 id="全球的海啸灾害"><a href="#全球的海啸灾害" class="headerlink" title="全球的海啸灾害"></a>全球的海啸灾害</h2><p>全球海啸发生区的分布基本上与地震带的分布一致，主要集中在 <em><strong>环太平洋地区和地中海-中亚地区</strong></em> 。日本是地震频繁发生的国家，也是世界上经常遭受海啸袭击的国家之一。</p><h2 id="中国的海啸灾害"><a href="#中国的海啸灾害" class="headerlink" title="中国的海啸灾害"></a>中国的海啸灾害</h2><p>虽然中国海区地处太平洋西部，濒临西北太平洋地震带，有很长的海岸线，但是中国的近海发生地震海啸的可能性很小。</p><p>原因：</p><ol><li><p>中国海区处于宽广大陆架上，近海总体水深都不大，不利于地震海啸的形成与传播；</p></li><li><p>从地质构造上看，中国除了郯城-庐江大断裂纵贯渤海外，沿海地区很少有大断裂层和断裂带，在中国海区内也很少有岛弧和海沟，因此，中国大部分海域地震产生本地海啸的可能性比较小。</p></li></ol><p>太平洋地震产生的远洋海啸对中国沿海地区的影响：</p><ol><li><p>中国辽阔的近海海域内的众多岛屿构成了一个环绕大陆的弧形圈，形成一道海上屏障。在中国近海外侧又有日本九洲、琉球群岛，以及菲律宾诸岛拱卫，又构成另一道天然的防波堤，抵御着外海海啸波的猛烈冲击。这两道天然岛弧屏蔽了中国大部分的海岸线；</p></li><li><p>中国的海域大都是浅水大陆架地带。向外延伸远，海底地形平缓而开阔，不像印度洋海啸影响的许多地区那样，海底逐渐由深变浅，中间没有一个平缓的缓冲带</p></li></ol><h2 id="地震的预兆："><a href="#地震的预兆：" class="headerlink" title="地震的预兆："></a>地震的预兆：</h2><p>由于地震波先于海啸到达近海岸，地震是海啸最明显的前兆，沿海水域的快速下降或上升也可能如此。</p><h2 id="海啸来临时的逃生办法：（了解即可）"><a href="#海啸来临时的逃生办法：（了解即可）" class="headerlink" title="海啸来临时的逃生办法：（了解即可）"></a>海啸来临时的逃生办法：（了解即可）</h2><ul><li>如果在海滩或邻近海的地方感到地震，应马上向高处跑去；海啸所造成的危害，往往在第一个波浪涌至后数小时内仍然持续，所以谨慎行事，即使警告看起来模棱两可，或者您认为危险已经过去。</li><li>放弃财物，拯救你的生命，而不是你的财产</li><li>只有当被困且无法到达高地时，才能去坚固建筑物的上层或爬上屋顶</li><li>作为最后的手段，如果被困在低地上，请爬上一棵强壮的树</li><li>如果被海啸席卷，请寻找可以用作木筏的东西</li><li>在海水里不要喝水</li><li>注意保暖</li></ul><h1 id="讨论课"><a href="#讨论课" class="headerlink" title="讨论课"></a>讨论课</h1><p>板书, 引发地震海啸的主要因素:</p><ul><li>地震大小</li><li>震源机制</li><li>震源深度</li><li>震源的破裂过程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从新冠肺炎疫情防控看中国共产党“以人民为中心”的发展思想——以“动态清零”政策为例</title>
    <link href="https://justaloli.cn/posts/5779.html"/>
    <id>https://justaloli.cn/posts/5779.html</id>
    <published>2023-05-24T13:23:47.000Z</published>
    <updated>2023-05-24T13:41:37.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>编者按：这篇文章是我的习概（全称习近平新时代中国特色社会主义思想概论）课程作业。选择这个题目原本是出于阴阳怪气的考虑，不过在撰写的过程中确实有一些收获（当然依然有许多阴阳怪气的成分）。我翻看了一些“动态清零”制定初期（即2021年下旬）的资料，看了一些当时对“动态清零”概念的构想。能感觉到，政策制定时确实有进行较充分的考量。不过这项政策还是失败了。这很能体现理想和现实的辩证关系，让笔者颇为感慨。</p><p><strong>提前声明：以下内容或观点与编者无关。</strong></p></blockquote><p><img src="/posts/5779/%E5%AF%BC%E5%9B%BE.svg" alt="思维导图。我思绪比较琐碎，因此构思导图之后再填充文本相对高效一些"></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>“动态清零”政策制定于2021年下旬，取消于2022年末，历时近一年的时间。在”动态清零”政策落实期间，有少数境内外的敌对分子利用政策落实期间出现的各类偶发现象抨击该政策，认为其是强硬的，违背了民意。</p><p>这种论断是错误的，险恶的。事实上，”动态清零”政策的制定和取消有其合理的背景。不能用”动态清零”取消之后的政策反对”动态清零”取消之前的政策，也不能用”动态清零”取消之前的政策反对”动态清零”取消之后的政策。</p><p>因此，本文的研究十分有必要。本文以习近平新时代中国特色社会主义思想为指导，分析”以人民为中心”发展思想的内涵，并梳理”动态清零”政策的建立过程，试图论证在”动态清零”从制定到取消的全过程都体现了”以人民为中心”的发展思想，为”动态清零”政策正名。</p><h1 id="“以人民为中心”发展思想的概念和内涵"><a href="#“以人民为中心”发展思想的概念和内涵" class="headerlink" title="“以人民为中心”发展思想的概念和内涵"></a>“以人民为中心”发展思想的概念和内涵</h1><p>“以人民为中心”的思想有深厚的历史渊源。在中国传统文化中，便有”水可载舟，亦可覆舟”的俗语，当时的专制统治者将此奉为戒律。在古代，人民和执政者是对立的。然而即便如此，执政者也清楚政权和人民的关系，并在政策制定时关注百姓的呼声和诉求，并借此巩固自己的统治。</p><p>“人民”也是马列主义中的关键词。马克思、恩格斯在历史研究中使用”人民”一词，并总结为”群众史观”或”人民史观”。人民史观是唯物史观中的重要组成部分。在人民史观中，马克思强调人民群众是历史的创造者，是社会物质财富与精神财富的创造者，更是社会变革的决定性与主体性力量。马克思写到：”人们自己创造自己的历史”<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《马克思恩格斯选集》第一卷，第669页，人民出版社，2012年版">[1]</span></a></sup>；恩格斯写到：”人们总是通过每一个人追求他自己的、自觉预期的目的来创造他们的历史”<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《马克思恩格斯选集》第四卷，第254页，人民出版社，2012年版。">[2]</span></a></sup>可见，在马克思主义中，”人民”首先作为一个历史观念存在。</p><p>在领导无产阶级的革命运动时，马克思沿用了”人民”的概念，对无产阶级运动做出了要求。马克思在《共产党宣言》中指出，为绝大多数人谋利益是无产阶级运动的奋斗目标<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《马克思恩格斯选集》第一卷，第411页，人民出版社，2012年版">[3]</span></a></sup>。同时，马克思强调强调人民群众是无产阶级政党领导的运动的直接受益者、目的指向者与价值评判标准。类似的，列宁在领导布尔什维克党的无产阶级运动，以及苏联的社会主义建设时，也将人民作为了运动的目标和评价标准。</p><p>在中共的革命和建设时期，领袖毛泽东曾多次提及”人民”，体现了以人民为中心的理念。毛泽东接受了马克思主义的”人民史观”，多次强调人民是创造历史的动力<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《毛泽东文集》第三卷，第88页。">[4]</span></a></sup><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《毛泽东选集》第三卷，第1031页。">[5]</span></a></sup>。同时，毛泽东也指出在进行无产阶级运动时，应当将人民作为运动的受益者，运动的目的指向群体和运动的评价标准。</p><p>“改革开放”以来，先后以邓小平、江泽民、胡锦涛为核心的中共对”人民”提出了更加生动的解释。邓小平时代提出的”三个有利于”将”人民生活水平”作为其中的最高标准；江泽民时代提出的”三个代表”将”代表最广大人民的根本利益”作为中共的重要政治立场；胡锦涛时代提出的”科学发展观”将”以人为本”作为了发展的重要原则。</p><p>根据”以人民为中心”理论的历史沿革，可以总结其核心理念。”以人民为中心”的核心是一种历史和哲学观念，认为广大人民是历史的主要创造者和推动者，指出”人民是真正的英雄”。这区别于传统的”由少数领袖推动历史发展”的英雄史观。</p><p>在具体的执行过程中，”以人民为中心”不再单纯作为历史和哲学用语，其也被赋予了诸多政治内涵。</p><p>在国家国体方面，人民象征一种国家政权性质，在这种政权中，人民是国家权力的实际拥有者。</p><p>在国家的大政方针方面，人民是一种制定政策和落实的原则和方法，即所谓”群众路线。具体地说，在这种原则下，人民是一种衡量政策好坏的标准，政策应当”为了群众、依靠群众”；人民是一种改革创新的方法，要尊重人民群众的首创精神，吸收人民群众的智慧实现改革创新；人民是一种实现建设成就的力量，通过充分发挥人民的积极性推动政策落实和国家建设。</p><p>在党的自身建设和巩固上，人民是衡量党的好坏的标准，中共要求自己始终与人民站在一起；人民是巩固党的统治的手段，中共力图通过制定针对人民的政策，赢得广大人民的信任和支持，从而实现长期稳定的统治。</p><p>可见，”以人民为中心”具有诸多方面的内涵。总的来说，它具有历史和政治两方面的内涵。在政治方面，又包含政策的制定和党的自身巩固两个子方面。由于本文的主题是通过”动态清零”政策看中共”以人民为中心”的理念，后文的分析将主要集中于其政治内涵。</p><h1 id="“动态清零”政策的背景，概念和原则"><a href="#“动态清零”政策的背景，概念和原则" class="headerlink" title="“动态清零”政策的背景，概念和原则"></a>“动态清零”政策的背景，概念和原则</h1><h2 id="“动态清零”政策的背景"><a href="#“动态清零”政策的背景" class="headerlink" title="“动态清零”政策的背景"></a>“动态清零”政策的背景</h2><p>2020年初，新冠肺炎在武汉大流行，人民生命健康受到严重挑战。面对这场突如其来的公共卫生事件，中国共产党领导的中国政府果断采取行动，通过对武汉进行”封城”管理，通过对全国医疗卫生资源的统一调配，实现了武汉疫情防控阻击战的首战告捷。这一时期，中国主要采取”清零”政策，通过诸如交通管制、居家办公学校线上上课等方式减少人员流动，做到隔离传染源，切断传播途径和保护易感人群，有效防止了疫情的大规模扩散。</p><p>与此同时，新冠病毒在持续变异。三年来，全球陆续出现阿尔法、贝塔、伽马、德尔塔和奥密克戎变异株。其中，德尔塔毒株因其潜伏期短、传播速度快、病毒载量高等特点，迅速成为蔓延全球的主流毒株；在奥密克戎毒株具备更快的传播速度和更大的免疫逃逸能力，出现后迅速取代德尔塔毒株成为主要毒株。</p><p>这两种毒株在中国都有广泛的传播。其中，德尔塔毒株主要在2021年流行，较典型的案例是2021年末-2022年初的西安市疫情；奥密克戎毒株主要在2022年流行，较典型的案例是2022年三月的上海市疫情。</p><p>随着毒株传染性、传播速度的增强，中国的防疫政策也与时俱进发生着变化。2020年3月，在总结武汉疫情防控的胜利经验后，中国卫健委发布《新型冠状病毒肺炎防控方案（第六版）》<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="新型冠状病毒肺炎防控方案（第六版）\[J\].全科医学临床与教育,2020,18(05):388-390+396.">[6]</span></a></sup>，其中强调了对不同风险地区实行”分级防控”。具体地说，对低风险地区实行”外防输入”，对中风险地区实行”外防输入，内防扩散”，对高风险地区实行”内防扩散，外防输出，严格管控”，包括停止聚集性活动、进行交通管控和限制人员进出等措施。</p><h2 id="“动态清零”政策的制定"><a href="#“动态清零”政策的制定" class="headerlink" title="“动态清零”政策的制定"></a>“动态清零”政策的制定</h2><p>“动态清零”一词在新冠肺炎疫情出现之前就存在。比如，2016年4月，习近平在安徽调研时就指出要确保零就业家庭的”动态’清零’”<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="杜尚泽,叶琦. 总书记来到我们身边\[N\]. 人民日报,2016-04-28(002).">[7]</span></a></sup>。</p><p>2021年下旬，潜伏期短、传播速度快的德尔塔毒株在中国流行，且奥密克戎变异株的出现增加了疫情防控的不确定性。在此背景下，中国疾控部门开始研究新的防疫政策，”动态清零”登上抗疫舞台。至少在2021年11月，”动态清零”已经作为“防疫目标”出现在公开的中央文件中。随后，中央将”动态清零”确定为”总方针”<sup id="fnref:8"><a href="#fn:8" rel="footnote">&lt;span class&#x3D;”hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label&#x3D;”金振娅. “动态清零”和”零感染”有何不同[N].    光明日报,2021-12-12(004).DOI:10.28273&#x2F;n.cnki.ngmrb.2021.006247.”&gt;[8]</a></sup></p><p>到2022年6月发布的《新型冠状病毒肺炎防控方案（第九版）》中，明确了”动态清零”总方针下的防疫各项细节。</p><h2 id="“动态清零”政策的主要原则"><a href="#“动态清零”政策的主要原则" class="headerlink" title="“动态清零”政策的主要原则"></a>“动态清零”政策的主要原则</h2><p>“动态清零”政策的制定，主要是为了平衡疫情之下，人民生命健康和经济社会发展之间的矛盾。”动态清零”核心是”清零”，手段是”动态”，即在允许宏观的疫情存在的前提下，尽可能扑灭微观的聚集性疫情。对零散，小发的疫情做到”早发现”，力求出现一起扑灭一起。通过对已感染或有感染风险的人群进行集中隔离和闭环管理，尽可能保证疫情控制在闭环内，进而保证社会的正常运转。</p><p>实现”动态清零”，需要依靠快速，精准的流行病学调查和医学防控。”动态清零”要求将所有有感染风险的人群归入闭环。这意味着，各级政府部门应在疫情发现的关键时期，及时管控感染者、同时结合人员轨迹的调查工作，准确判定和管控有关的密切接触者。同时，政策要求各级政府部门和疫情防控部门要做到”以快制快”，减少疫情规模和处置时间。再者，要规范PCR核酸检测、集中隔离、居家隔离，精准判定高低风险区域，减少因”层层加码””一刀切”给群众带来的不便。</p><h2 id="“动态清零”政策的具体案例"><a href="#“动态清零”政策的具体案例" class="headerlink" title="“动态清零”政策的具体案例"></a>“动态清零”政策的具体案例</h2><p>2021年末到2022年初的陕西西安疫情是践行”动态清零”政策的典型。在这次疫情防控阻击战中，陕西西安市政府创新的提出了”社会面清零”的概念。具体做法上，政府将有疫情扩散风险的社区人员集体转运进行集中隔离，待隔离区外不出现新的病例后，便宣布完成”社会面清零”，并逐渐放开社会的管控措施。”社会面清零”概念在西安提出后，立刻得到全国各地的效仿。”社会面清零”逐渐成为”动态清零”政策中的重要一环。</p><p>2022年春的上海市疫情中，面对疫情的集中爆发和模糊的传播链条，上海市政府创新的使用了”全域静态管理”的政策，包括停止聚集性活动、进行交通管控和限制人员进出等措施。”全域静态管理”主要的目的是通过限制人员流动，进行大批全员核酸筛查，彻底摸清传播链条，并对有风险的人群进行集中隔离，挣取实现”社会面清零”。”全域静态管理”虽然在一定程度上违背了动态清零”保障社会正常运转”的原则，但它也是实现”社会面清零”进而实现”动态清零”的必要手段。”全域静态管理”概念提出后，立刻得到全国各地的效仿。”全域静态管理”，反映了”动态清零”的总方针和实际落实之间的辩证关系。</p><h2 id="“动态清零”政策的放松和取消"><a href="#“动态清零”政策的放松和取消" class="headerlink" title="“动态清零”政策的放松和取消"></a>“动态清零”政策的放松和取消</h2><p>2022年，奥密克戎毒株流行，”动态清零”政策面临挑战。</p><p>“动态清零”政策落实的前提，是防控机构能够快速的摸清疫情的风险人群，并快速开展防控。但是奥密克戎变异株传播速度快的特性，使得摸清传播链条的工作变得非常困难。这导致政策落实过程中，地方政府越来越频繁的采用”静态管理”措施，以求获得准确的传播链条。为了更快实现”社会面清零”，部分地方出现疫情政策”层层加码”现象，”动态清零”在落实过程中，逐渐偏离了政策原本的原则。</p><p>2022年11月11日，国务院联防联控机制公布了进一步优化疫情防控工作的二十条措施。12月7日，国务院联防联控机制公布了《关于进一步优化落实新冠肺炎疫情防控措施的通知》。27日，公布《关于印发对新型冠状病毒感染实施”乙类乙管”总体方案的通知》。至此，”动态清零”总方针从公开的中央文件中消失，”动态清零”政策事实上被取消。</p><h1 id="从”动态清零”政策看”以人民为中心”的发展思想"><a href="#从”动态清零”政策看”以人民为中心”的发展思想" class="headerlink" title="从”动态清零”政策看”以人民为中心”的发展思想"></a>从”动态清零”政策看”以人民为中心”的发展思想</h1><p>回顾”动态清零”政策的全过程，可以得出结论：动态清零政策的制定，落实和取消，都切实体现了”以人民为中心”的发展思想。</p><h2 id="“动态清零”政策的制定-1"><a href="#“动态清零”政策的制定-1" class="headerlink" title="“动态清零”政策的制定"></a>“动态清零”政策的制定</h2><p>显然，”动态清零”政策的制定遵循了中共的”群众路线”，因此体现了”以人民为中心”的发展思想。”动态清零”的政策充分考虑了广大人民的切身需求。人民既希望得到身体健康，又希望社会经济正常运转。中共本着”人民至上，生命至上”的原则，果断的将”清零”作为政策的核心，尽可能的保证人民群众的生命安全，尽可能保护人民群众免受疫情伤害。与此同时，”动态清零”在构思过程中也考虑到了社会经济的运行，不同于旧有的”零感染”政策，”动态清零”强调疫情早发现，早报告，早扑灭，通过常态化的监测，尽可能的减少大规模封控对社会经济的不良影响。</p><p>总之，”动态清零”政策的制定充分考虑了人民群众多方面的需求，充分体现了群众路线”为了群众”的原则，当之无愧的反映了”以人民为中心”的发展思想。</p><h2 id="“动态清零”政策的落实"><a href="#“动态清零”政策的落实" class="headerlink" title="“动态清零”政策的落实"></a>“动态清零”政策的落实</h2><p>“动态清零”政策的落实也体现了”以人民为中心”的发展思想。</p><p>一方面，中共在落实”动态清零”政策的过程中，十分强调对广大人民群众的宣传和调动。在《新型冠状病毒肺炎防控方案（第九版）》中，有专门一节阐释疫情防控中的公共措施<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="新型冠状病毒肺炎防控方案(第九版)\[J\].中国病毒病杂志,2022,12(05):331-338.DOI:10.16505/j.2095-0136.2022.0049.">[9]</span></a></sup>。另一方面，”动态清零”的落实得到了广大人民群众的支持，涌现出一批优秀的抗议志愿者，是他们在一线的奋斗成就了全国疫情防控的伟大胜利。在政策制定的过程中，中共充分调动人民群众的积极性，利用人民群众的广大力量实现抗疫的胜利。这既反映了群众路线”依靠群众”的原则，也反应了”以人民为中心”中人民是一种实现建设成就的力量的重要内涵。同时，强调人民在政策执行过程中的重要作用，也体现了”以人民为中心”中的人民史观。人民是真正的英雄。</p><h2 id="“动态清零”政策的转向和取消"><a href="#“动态清零”政策的转向和取消" class="headerlink" title="“动态清零”政策的转向和取消"></a>“动态清零”政策的转向和取消</h2><p>“动态清零”政策的转向和取消，是中共审时度势，综合奥密克戎变异株流行的外因和人民对”动态清零”态度转变的内因所做出的重大决定，是科学的，正确的。”动态清零”政策的转向和取消，并不意味着”动态清零”政策本身出现了问题，而是”动态清零”不能适应新的疫情形势。因此，不能拿”动态清零”的取消去否定”动态清零”政策的正确性，也不能拿”动态清零”政策的成就否定”动态清零”政策的取消。</p><p>在2022年，随着奥密克戎毒株的流行，防控人员很难拿到准确的传播链条，实现”动态清零”追求的”早发现，早隔离””发现一起扑灭一起”变得非常困难。少数地方官员在政策执行过程中为了尽早实现”社会面清零”，滥用行政手段进行静态管理，在地方防疫上”层层加码”。这不但违背了”动态清零”政策的初衷，也背离了”以人民为中心”的思想，使人民的基本生活和社会的基本运转都受到冲击。</p><p>同时，还有极少数外部势力抓住这些个别情况，借助互联网和高校等渠道煽动对”动态清零”政策的反对。</p><p>曾经优秀的政策，由于疫情形势变化和政策落实过程和理想过程偏差等各类原因，逐渐失去了人民群众的支持。在这种形势下，中共实事求是，回应了广大人民的诉求，将”动态清零”政策逐步转向和取消。”水可载舟，亦可覆舟”。”动态清零”政策从制定、落实到取消的过程生动的体现了”以人民为中心”的内涵，体现了中共充分尊重人民群众的需求和想法。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>“以人民为中心”的发展思想，是习近平新时代中国特色社会主义理论的重要组成部分，源自中国传统以及社会主义理论。这种思想的核心是人民史观。在政治上，”以人民为中心”在国体，政治落实和党的建设上都有体现。”动态清零”政策经历了制定，落实再到转向和取消的过程，这一过程说明中国共产党审时度势，在政策制定时倾听人民群众的声音，在政策执行时依靠人民群众的力量。这充分体现了”以人民为中心”的发展思想。</p><p>新冠疫情作为突发的”黑天鹅”事件，其走向超出所有人的预料。这一特殊时刻的政策更能体现政党政策制定的根本原则。从”动态清零”政策，可以看出中国共产党是始终努力做到”以人民为中心”的大党。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《马克思恩格斯选集》第一卷，第669页，人民出版社，2012年版<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《马克思恩格斯选集》第四卷，第254页，人民出版社，2012年版。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《马克思恩格斯选集》第一卷，第411页，人民出版社，2012年版<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《毛泽东文集》第三卷，第88页。<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《毛泽东选集》第三卷，第1031页。<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">新型冠状病毒肺炎防控方案（第六版）[J].全科医学临床与教育,2020,18(05):388-390+396.<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">杜尚泽,叶琦. 总书记来到我们身边[N]. 人民日报,2016-04-28(002).<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">金振娅. &quot;动态清零&quot;和&quot;零感染&quot;有何不同[N].光明日报,2021-12-12(004).DOI:10.28273/n.cnki.ngmrb.2021.006247.<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">新型冠状病毒肺炎防控方案(第九版)[J].中国病毒病杂志,2022,12(05):331-338.DOI:10.16505/j.2095-0136.2022.0049.<a href="#fnref:9" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++细节：无处不在的const修饰符</title>
    <link href="https://justaloli.cn/posts/44205.html"/>
    <id>https://justaloli.cn/posts/44205.html</id>
    <published>2023-04-26T10:10:19.000Z</published>
    <updated>2023-04-26T14:47:43.668Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>const修饰符, 顾名思义是修饰某个东西为“常量”,不允许修改. 在C++中, 有很多地方需要用到const修饰符. 它不仅是一个良好的书写习惯, 在某些情况下, 它甚至是必要的. 这篇文章试图涵盖C++中所有const的出现情况.</p><p>目录</p><ul><li>1 const与变量定义<ul><li>1.1 普通变量</li><li>1.2 指针</li><li>1.3 引用</li></ul></li><li>2 const与函数<ul><li>2.1 形参<ul><li>普通</li><li>指针</li><li>引用</li></ul></li><li>2.2 返回值</li><li>2.3 案例: 一些特殊函数<ul><li>比较运算符重载</li><li>iostream的输入输出</li></ul></li></ul></li><li>3 cosnt与类<ul><li>3.1 属性</li><li>3.2 方法<ul><li>3.2.1 方法的const</li></ul></li></ul></li></ul><h1 id="1-const-与-变量定义"><a href="#1-const-与-变量定义" class="headerlink" title="1. const 与 变量定义"></a>1. const 与 变量定义</h1><h2 id="1-1-const-与-普通变量"><a href="#1-1-const-与-普通变量" class="headerlink" title="1.1 const 与 普通变量"></a>1.1 const 与 普通变量</h2><p>这是最初级、最直观的用法: 普通变量的值可以变, 而被const修饰过的普通变量的值不能变. 由此引申出一个特性, 被const修饰的变量必须在声明时立刻初始化.</p><p>下文基本上都用<code>int</code>作为普通变量的代表. 它原则上可以直接替换为任何基本变量、结构体、类.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1.1.1 无修饰的普通变量 */</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br><br><span class="hljs-comment">/* 1.1.2 const修饰变量: 变量的值不能修改 */</span><br><span class="hljs-comment">/* const修饰的变量必须在声明时立刻初始化 */</span><br><span class="hljs-comment">// const int b; // 错误</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>a = b; <span class="hljs-comment">// 正确</span><br>b = <span class="hljs-number">1</span>; <span class="hljs-comment">// 错误, 不能修改b的值</span><br></code></pre></td></tr></table></figure><h2 id="1-2-const-与-指针变量"><a href="#1-2-const-与-指针变量" class="headerlink" title="1.2 const 与 指针变量"></a>1.2 const 与 指针变量</h2><p>我想我不用详细描述指针的作用. 指针相当于两层, 指针本身存储地址, 这是一层; 存储的地址对应一个变量, 这是第二层.</p><p>由于指针的概念有两层, const的修饰也有两层: 是第一层, 指针存储的地址不能变呢? 还是第二层, 指针指向的变量的值不能变呢?</p><p>从这两个维度出发, 可以绘制这样的表格:</p><table><thead><tr><th>指针的地址 \ 通过指针访问的变量的值</th><th>能变</th><th>不能变</th></tr></thead><tbody><tr><td>能变</td><td><code>int*</code></td><td><code>const int*</code></td></tr><tr><td>不能变</td><td><code>int* const</code></td><td><code>const int* const</code></td></tr></tbody></table><p>我觉得上表已经很简明的描述了这四种指针的定义以及主要特点. 读者可以对照下面的使用例来判断自己理解是否正确.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1.2 const与指针 */</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> d = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> e = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> f = <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">/* 1.2.1 普通 int* 型指针: 指向 可变类型 的 可变指针 */</span><br><span class="hljs-type">int</span>* p1 = &amp;c; p1 = &amp;d; *p1 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 都正确</span><br><span class="hljs-comment">/* 普通指针无法指向const修饰的变量 */</span><br>p1 = &amp;e; <span class="hljs-comment">// 错误</span><br><br><span class="hljs-comment">/* 1.2.2 const int* 型指针: 指向 不可变类型 的 可变指针</span><br><span class="hljs-comment">即: 指针指向的位置可以修改, 指针指向的位置的值不能修改 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p2;<br>p2 = &amp;e; <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">/* const int* 可以指向普通变量, 此时直接访问普通变量可以修改其值, 但通过指针访问该变量则不能修改. */</span><br>p2 = &amp;c; <span class="hljs-comment">// 正确</span><br>c = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br>*p2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 错误</span><br><br><span class="hljs-comment">/* 1.2.3 int* const 型指针: 指向 可变类型 的 不可变指针</span><br><span class="hljs-comment">即: 指针指向的位置不能修改, 指针指向的位置的值可以修改 */</span><br><span class="hljs-comment">/* 类似const修饰的普通变量, 这种指针也必须在声明时立刻初始化 */</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p3 = &amp;c;<br>p3 = &amp;d; <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">/* 和 */</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p4 = &amp;e; <span class="hljs-comment">// 错误, 和int* 类似, int* const指向的必须是可变类型, 不能指向const类型.</span><br><br><span class="hljs-comment">/* 1.2.4 const int* const型指针: 指向 不可变类型 的 不可变指针</span><br><span class="hljs-comment">略, 可以自行推理得到它的使用方式. */</span><br></code></pre></td></tr></table></figure><h2 id="1-3-const-与-引用"><a href="#1-3-const-与-引用" class="headerlink" title="1.3 const 与 引用"></a>1.3 const 与 引用</h2><p>引用是C++有别于C的一个特性. 由于引用本身也很有话题, 这里不做过多介绍, 只是简单的说明一下引用与const的关系.</p><p>可以将引用粗略的理解为指针. 和指针不同在于: </p><ol><li>首先, 它不需要<code>*</code>运算符就能直接取得其所引用的变量的值, 因此引用相当于其所引用的变量的“别名”</li><li>其次, 它必须在声明时初始化, 之后不能再修改其所引用的是哪个变量.</li></ol><p>所以类似指针, 也能画出一个二维表格, 不过, “引用的是哪个变量”这件事, 不论对何种引用而言, 都是不能修改的. 因此这个表格事实上只有一行.</p><table><thead><tr><th>引用的是哪个变量 \ 通过引用访问变量的值</th><th>能变</th><th>不能变</th></tr></thead><tbody><tr><td><del>能变(不存在)</del></td><td><del>不存在</del></td><td><del>不存在</del></td></tr><tr><td>不能变</td><td><code>int&amp;</code></td><td><code>const int&amp;</code></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1.3.1 普通引用无法引用const修饰过的变量 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> g = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>&amp; h = g <span class="hljs-comment">// 错误</span><br><br><span class="hljs-comment">/* 1.3.3 形如 const int&amp; 的引用 */</span><br><span class="hljs-comment">/* 首先, 它类似const int*, 通过引用访问变量是不能修改变量的值的. */</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; j = i; <span class="hljs-comment">// 正确</span><br>j = <span class="hljs-number">1</span>; <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">/* 其次, 由于引用本身的特性, 它和const int* 不同, 它引用的是哪一个变量, 这件事也不能修改.</span><br><span class="hljs-comment">也没有任何一个语法能让你修改. */</span><br></code></pre></td></tr></table></figure><p><em><strong>需要格外注意的是: <code>const int&amp;</code> 有一个非常特殊的用法: 它可以直接引用一个字面量. 这是指针和无const修饰的引用都没有的特性. 在接下来的内容中, 读者将看到这种类型的重要性.</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; k = <span class="hljs-number">3</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span>&amp; l = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误, 不能将一个字面量赋值给一个普通引用.</span><br></code></pre></td></tr></table></figure><p>这里不得不说明一下: 以下每一行内的几种写法是完全等价的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p;<span class="hljs-type">int</span>* p;<span class="hljs-type">int</span> * p;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p; <span class="hljs-type">const</span> <span class="hljs-type">int</span> *p; <span class="hljs-type">const</span> <span class="hljs-type">int</span> * p;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p; <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p; <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p;<br><span class="hljs-type">int</span>&amp; p; <span class="hljs-type">int</span> &amp;p; <span class="hljs-type">int</span> &amp; p;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; p; <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;p; <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; p;<br></code></pre></td></tr></table></figure><p>简而言之, <code>*</code>, <code>&amp;</code>这样的修饰符, 紧挨着谁都是一样的. 而笔者主要使用第一种写法.</p><h1 id="2-const-与-函数"><a href="#2-const-与-函数" class="headerlink" title="2. const 与 函数"></a>2. const 与 函数</h1><h2 id="2-1-const-与-函数形参"><a href="#2-1-const-与-函数形参" class="headerlink" title="2.1 const 与 函数形参"></a>2.1 const 与 函数形参</h2><p>这部分内容可以直接由上面关于变量的介绍平移而来. 下文推测读者已经基本了解C++函数参数传递的机制.</p><h3 id="2-1-1-普通类型形参"><a href="#2-1-1-普通类型形参" class="headerlink" title="2.1.1 普通类型形参"></a>2.1.1 普通类型形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>&#123;<br><span class="hljs-comment">/* const修饰的效果: 在函数体内,形参a的值无法被更改 */</span><br>a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于参数传递机制,这两个函数都可以接收普通和const修饰的int变量</p><h3 id="2-1-2-指针形参"><a href="#2-1-2-指针形参" class="headerlink" title="2.1.2 指针形参"></a>2.1.2 指针形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span></span>&#123;<br>*a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>a = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* a)</span></span>&#123;<br>*a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误</span><br>a = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun3</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-type">const</span> a)</span></span>&#123;<br>*a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>a = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 错误</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> a)</span></span>&#123;<br>*a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 错误</span><br>a = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这四个函数都可以传入普通变量的地址. 普通变量的地址被拷贝如函数后, 会被自动加上const修饰.</p><p>而只有fun2和fun4可以传入const修饰的变量的地址. </p><p>为什么不能传入fun1和fun3?可以这样理解:</p><blockquote><p>编译器: 这个变量本身是const保护的, 传给函数之后, 这个保护就没有了! 在fun1和fun3中, 是允许通过指针a修改变量的值的, 而这个值本身却是const保护的! 这怎么办, 算了给个error吧.</p></blockquote><p>即: 在传递时, 允许加强const条件, 不允许丢掉const条件(这很直观).</p><p>其中, fun2是格外有用的. 如果你 <em><strong>不想在参数传递时拷贝原有数据的值</strong></em> ,又希望函数 <em><strong>以只读的方式访问某个变量</strong></em> ,fun2是一个好选择. </p><h3 id="2-1-3-引用形参"><a href="#2-1-3-引用形参" class="headerlink" title="2.1.3 引用形参"></a>2.1.3 引用形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似的, 两个函数都能传入普通变量. 而fun1不能传入带const修饰的变量.</p><p><em><strong>此外,十分重要的: fun2可以传入字面量! 这很特殊</strong></em></p><p>其中, fun2是格外有用的. 如果你 <em><strong>不想在参数传递时拷贝原有数据的值</strong></em> ,又希望函数 <em><strong>以只读的方式访问某个变量</strong></em> , 还希望 <em><strong>函数内部不要出现指针的<code>*</code>和<code>-&gt;</code>操作, 调用函数不要出现取地址<code>&amp;</code>操作</strong></em> , 还希望它 <em><strong>能传入字面量</strong></em> , fun2是一个好选择. </p><h2 id="2-2-const-与-函数返回值"><a href="#2-2-const-与-函数返回值" class="headerlink" title="2.2 const 与 函数返回值"></a>2.2 const 与 函数返回值</h2><p>这在某些场合是有点莫名其妙的命题. 比如这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对函数返回值传递机制稍有了解便能知道, 这个const是完全无用的. </p><p>但在某些情况它会不同, 比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>就有不同了. fun()返回的指针可以修改所指位置的值, 而fun2()返回的指针不能.</p><p>类似的, 对于引用, 有:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>*p = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> *p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>它们也是不同的. 不过这两个函数单看其实有些奇怪. 我们之后会在 <strong>类</strong> 那一部分更深入的探讨它们的区别和各自运用.</p><h2 id="2-3-案例-const-在几种特殊函数中的作用"><a href="#2-3-案例-const-在几种特殊函数中的作用" class="headerlink" title="2.3 案例: const 在几种特殊函数中的作用"></a>2.3 案例: const 在几种特殊函数中的作用</h2><p>在2.1.3, 我提到了: </p><blockquote><p>如果你 <em><strong>不想在参数传递时拷贝原有数据的值</strong></em> ,又希望函数 <em><strong>以只读的方式访问某个变量</strong></em> , 还希望 <em><strong>函数内部不要出现指针的<code>*</code>和<code>-&gt;</code>操作, 调用函数不要出现取地址<code>&amp;</code>操作</strong></em> , 还希望它 <em><strong>能传入字面量</strong></em> , fun2是一个好选择.</p></blockquote><p>这种情况会在什么时候出现呢? 没错, 那就是——</p><p>(函数体外的) <em><strong>运算符重载</strong></em></p><p>运算符重载有两种, 一种是写在函数体(准确的说是结构体或类定义)外,没有打括号包裹的, 另一种是定义在类内部的.</p><p>这里着重举两个例子.</p><p>以这样一个结构体为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Int</span>&#123;<br><span class="hljs-type">int</span> data;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-1-类-或结构体-的比较运算符重载"><a href="#2-3-1-类-或结构体-的比较运算符重载" class="headerlink" title="2.3.1 类(或结构体)的比较运算符重载"></a>2.3.1 类(或结构体)的比较运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Int&amp; a,<span class="hljs-type">const</span> Int&amp; b)&#123;<br><span class="hljs-keyword">return</span> a.data &lt; b.data;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是比较规范的运算符重载写法. 注意这里的<code>const Int&amp;</code>, 需要const修饰.</p><p>如果不加const,只保留&amp;,那么这个运算符将不能处理右值(可以理解为常量和字面量);</p><p>如果不加const,也不保留&amp;,那么调用运算符会进行值的拷贝, 这在Int是一个复杂的数据类型时, 会凭空增加内存消耗, 也很耗时.</p><h3 id="2-3-2-输入输出重载"><a href="#2-3-2-输入输出重载" class="headerlink" title="2.3.2 输入输出重载"></a>2.3.2 输入输出重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="hljs-type">const</span> Int&amp; a)&#123;<br>out &lt;&lt; a.data;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br>std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; in,Int&amp; a)&#123;<br>in &gt;&gt; a.data;<br><span class="hljs-keyword">return</span> in;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是比较规范的输入输出流重载写法. 注意在输出时需要加const修饰(否则无法输出字面量), 而输入时不能加const修饰(否则无法修改). 这里也能看出引用<code>&amp;</code>符的巨大作用.</p><h1 id="3-const-与-类"><a href="#3-const-与-类" class="headerlink" title="3. const 与 类"></a>3. const 与 类</h1><h2 id="3-1-const-与-类的属性"><a href="#3-1-const-与-类的属性" class="headerlink" title="3.1 const 与 类的属性"></a>3.1 const 与 类的属性</h2><p>基本和变量完全一致.</p><h2 id="3-2-const-与-类的方法"><a href="#3-2-const-与-类的方法" class="headerlink" title="3.2 const 与 类的方法"></a>3.2 const 与 类的方法</h2><p>比如这样一个类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>方法和函数在很多方面是类似的. 它也有参数的const, 和返回值的const. 这里着重介绍另一种: <strong>方法的const.</strong></p><h3 id="3-2-1-方法的const"><a href="#3-2-1-方法的const" class="headerlink" title="3.2.1 方法的const"></a>3.2.1 方法的const</h3><p>为什么需要方法const? 因为对象可能被const修饰了.</p><p>比如, 假设string有一个方法size:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(str);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于一个普通string对象, 我们可以执行size(). </p><p>然而, 对于一个 <strong>加了const修饰的string对象</strong> , 还能执行size()吗? 对于一个const修饰的对象, 其中的所有属性都自动增加了const修饰. 然而, <em>系统不知道这个size()方法会不会修改这些被加了const修饰属性</em>. 因此, 对于const string对象, 系统不会允许执行这个size()方法, 会报错.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br>s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> string s2;<br>s2.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">/* 报错信息: &#x27;this&#x27; argument to member function &#x27;size&#x27; has type &#x27; const string&#x27;</span><br><span class="hljs-comment">but function is not marked const  */</span><br></code></pre></td></tr></table></figure><p>然而, 事实上这个size()方法并不会修改对象的属性. 我们的确想让const string对象也能执行size()方法. 因此, <strong>我们要给size()对象增加const修饰</strong>, 就像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123; <span class="hljs-comment">//注意这里的const!</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(str);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样, 对于const string对象, 也可以正常执行size()方法了.</p><p><em><strong>这里, const修饰就是告诉编译器: 这个方法内的所有代码都不会修改当前类的属性值.</strong></em></p><p>const修饰的方法有以下几个特性:</p><ol><li>const修饰的对象只能执行const修饰的方法</li><li>const修饰的方法内部只能执行别的同样被const修饰的方法</li><li>没有const修饰的对象可以执行const修饰的方法</li><li>允许存在一个无const修饰一个有const修饰的两个同名方法. 程序会自动根据对象有没有const选择执行哪一个.</li></ol><p><em><strong>Remark: 关于特性4, 有以下的例子:</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">array</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span>* data;<br><span class="hljs-built_in">array</span>()&#123;data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">20</span>];&#125;<br>~<span class="hljs-built_in">array</span>()&#123;<span class="hljs-keyword">delete</span> [] data;&#125;<br><span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> index)&#123;<span class="hljs-keyword">return</span> data[index];&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> index)<span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> data[index];&#125;<br>&#125;;<br>array a1;<br>a1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> array a2;<br>a2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 错误, 调用第二个方法, 返回const int&amp;不能被修改.</span><br></code></pre></td></tr></table></figure><p><em><strong>Remark2: const保护并不代表万无一失. 对上面的例子稍作修改:</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">array</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span>* data;<br><span class="hljs-built_in">array</span>()&#123;data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">20</span>];&#125;<br>~<span class="hljs-built_in">array</span>()&#123;<span class="hljs-keyword">delete</span> [] data;&#125;<br><span class="hljs-comment">//我们直接给它加上const呢?</span><br><span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> index)<span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> data[index];&#125; <br>&#125;;<br>array a1;<br>a1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> array a2;<br>a2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p><em><strong>程序会完全正确的运行.</strong></em> 因为, const只保护了data指针, 没有保护data指向的那片空间. 因此, 它是允许你修改诸如 <code>data[0]</code> 的内容的. 但是, 这并不符合我们的预期. 我们给一个array增加const修饰, 当然是想让里面的值不被修改.</p><p>因此, 如果你想确保const修饰过的类按你的预期不被修改, 你需要 <em><strong>自觉做到</strong></em> 在const修饰过的方法中不去修改相关的值. 没人能帮你检查.</p><p>这个const修饰还有一个常见的应用: 类内部的运算符重载(尤其是<code>==</code>的重载). 请看:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span>* p;<br><span class="hljs-built_in">test</span>()&#123;p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;&#125;<br>~<span class="hljs-built_in">test</span>()&#123;<span class="hljs-keyword">delete</span> p;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<br>*p = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> test&amp; b)&#123; <span class="hljs-comment">// 不够好</span><br><span class="hljs-keyword">return</span> *p == *b.p;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> test&amp; b)<span class="hljs-type">const</span>&#123; <span class="hljs-comment">//正确的写法</span><br><span class="hljs-keyword">return</span> *p == *b.p;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>test t,t2;<br><span class="hljs-keyword">if</span>(t==t2)&#123; <span class="hljs-comment">// 如果用第一种写法,这里会报warning</span><br><span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会报一个warning:</p><blockquote><p>ISO C++20 considers use of overloaded operator ‘&#x3D;&#x3D;’ (with operand types test’ and ‘test’） to be ambiguous despitethere being a unique best viable function.</p></blockquote><p>这是为什么呢? 我的理解是, 相等运算<code>==</code>左右两边应当是对等的. 而这个重载的<code>==</code>运算, 由于没有加const修饰, 左右两边变得不对等了. 由于参数加了const, 而方法没有加const, 这意味着进行运算时, 有一方的属性可能被修改, 而另一方的属性标记了不会被修改. 这是不对等的.</p><p>这只是我的粗浅理解. 总之, 给这个方法增加const修饰, 这个warning就消失了.</p><p>以上是我目前能想到的全部内容.</p>]]></content>
    
    
    <summary type="html">const修饰符, 顾名思义是修饰某个东西为“常量”,不允许修改. 在C++中, 有很多地方需要用到const修饰符. 它不仅是一个良好的书写习惯, 在某些情况下, 它甚至是必要的. 这篇文章试图涵盖C++中所有const的出现情况, 以帮助初学者理解.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数算示例程序</title>
    <link href="https://justaloli.cn/posts/39276.html"/>
    <id>https://justaloli.cn/posts/39276.html</id>
    <published>2023-04-25T09:35:44.000Z</published>
    <updated>2023-04-25T09:52:41.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="顺序字典的二分查找"><a href="#顺序字典的二分查找" class="headerlink" title="顺序字典的二分查找"></a>顺序字典的二分查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinSearch</span><span class="hljs-params">(SeqDictionary *pdic, KeyType key, <span class="hljs-type">int</span> *pos)</span>&#123;<br><span class="hljs-type">int</span> low,mid,high;<br>low = <span class="hljs-number">0</span>; high = pdic-&gt;n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(low &lt;= high)&#123; <span class="hljs-comment">//注意这里的判断</span><br>mid = (low + high) / <span class="hljs-number">2</span>; <span class="hljs-comment">//注意中间位置</span><br><span class="hljs-keyword">if</span>(key &lt; pdic-&gt;elem[mid].key)&#123;<br>high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//注意边界变化</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; pdic-&gt;elem[mid].key)&#123;<br>low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意边界变化</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>*pos = mid;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>*pos = low; <span class="hljs-comment">//它“应该在”的位置,用于后续插入</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树二叉链表结构定义"><a href="#二叉树二叉链表结构定义" class="headerlink" title="二叉树二叉链表结构定义"></a>二叉树二叉链表结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinTreeNode</span></span><br><span class="hljs-class">&#123;</span><br>DataType info;                        <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinTreeNode</span> *<span class="hljs-title">llink</span>;</span>      <span class="hljs-comment">//指向左孩子</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinTreeNode</span> *<span class="hljs-title">rlink</span>;</span>     <span class="hljs-comment">//指向右孩子</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinTreeNode</span> *<span class="hljs-title">PBinTreeNode</span>;</span><br></code></pre></td></tr></table></figure><h3 id="前根遍历二叉树非递归算法"><a href="#前根遍历二叉树非递归算法" class="headerlink" title="前根遍历二叉树非递归算法"></a>前根遍历二叉树非递归算法</h3><h3 id="从根开始，沿左子树一直走到末端为止，在走的过程中访问所遇结点，并依次将所遇结点的非空右孩子进栈。当左子树结点全处理完后，从栈顶退出某结点的右孩子，此时该结点的左子树已经遍历完，再按照上述过程遍历结点的右子树，如此重复直到栈空为止。"><a href="#从根开始，沿左子树一直走到末端为止，在走的过程中访问所遇结点，并依次将所遇结点的非空右孩子进栈。当左子树结点全处理完后，从栈顶退出某结点的右孩子，此时该结点的左子树已经遍历完，再按照上述过程遍历结点的右子树，如此重复直到栈空为止。" class="headerlink" title="从根开始，沿左子树一直走到末端为止，在走的过程中访问所遇结点，并依次将所遇结点的非空右孩子进栈。当左子树结点全处理完后，从栈顶退出某结点的右孩子，此时该结点的左子树已经遍历完，再按照上述过程遍历结点的右子树，如此重复直到栈空为止。"></a>从根开始，沿左子树一直走到末端为止，在走的过程中访问所遇结点，并依次将所遇结点的非空右孩子进栈。当左子树结点全处理完后，从栈顶退出某结点的右孩子，此时该结点的左子树已经遍历完，再按照上述过程遍历结点的右子树，如此重复直到栈空为止。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(PBinTreeNode t)</span><br>&#123;<br><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;                                 <span class="hljs-comment">//栈顶指示器</span><br>PBinTreeNode p, S[M];             <span class="hljs-comment">//栈中存放各个右子树根结点</span><br><br>p = t;<br><span class="hljs-keyword">do</span><br>&#123;    <br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>visit(p-&gt;info);                        <span class="hljs-comment">//访问根结点</span><br><span class="hljs-keyword">if</span> (p-&gt;rlink != <span class="hljs-literal">NULL</span>)       <br>&#123;    S[top++] = p-&gt;rlink;    &#125;  <span class="hljs-comment">//右子树根结点进栈</span><br>p = p-&gt;llink;                          <span class="hljs-comment">//继续搜索p的左子树 </span><br>&#125;<br><span class="hljs-keyword">if</span> (top &gt;= <span class="hljs-number">0</span>)    p = S[--top];          <span class="hljs-comment">//右子树根结点出栈，转到搜索右子树</span><br>&#125; <span class="hljs-keyword">while</span> (top &gt;= <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中根遍历二叉树非递归算法"><a href="#中根遍历二叉树非递归算法" class="headerlink" title="中根遍历二叉树非递归算法"></a>中根遍历二叉树非递归算法</h3><p>与先根遍历基本类同，只是在沿左分支（左子树）向前搜索过程中将遇到的结点进栈，待遍历完左子树后，从栈顶退出结点并访问，然后再遍历右子树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrder</span><span class="hljs-params">(PBinTreeNode t)</span><br>&#123;   <br><span class="hljs-type">int</span> top=<span class="hljs-number">0</span>;                            <span class="hljs-comment">//栈顶指示器</span><br>PBinTreeNode p, S[M];      <span class="hljs-comment">//控制栈</span><br>p = t;<br><span class="hljs-keyword">do</span><br>&#123;    <br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>S[top++] = p;         <span class="hljs-comment">//所遇结点p进栈</span><br>p = p-&gt;llink;           <span class="hljs-comment">//继续搜索p的左子树</span><br>&#125;<br><span class="hljs-keyword">if</span> ( top &gt;= <span class="hljs-number">0</span>)<br>&#123;    <br>p = S[--top];          <span class="hljs-comment">//出栈，栈顶结点赋p</span><br>visit(p-&gt;info);       <span class="hljs-comment">//访问根结点</span><br>p = p-&gt;rlink;         <span class="hljs-comment">//继续搜索右子树 </span><br>&#125;<br>&#125; <span class="hljs-keyword">while</span> ( top &gt;= <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后根遍历二叉树非递归算法"><a href="#后根遍历二叉树非递归算法" class="headerlink" title="后根遍历二叉树非递归算法"></a>后根遍历二叉树非递归算法</h3><p>使用栈实现后根遍历要比先、中根遍历复杂。在后根遍历中，当搜索指针指向某个根结点时，不能马上进行访问，而先要遍历左子树，所以要求根结点进栈保存。当遍历完左子树后，再次搜索到该结点时，还不能进行访问，还要遍历其右子树。所以，需要再次将该结点进栈保存。为了区别同一结点的两次入栈，需要一个特别的标志：1表示该结点首次进栈[遍历左子树前入栈]，2表示第二次进栈[遍历右子树前入栈]。设立两个栈，一个栈s1[M]用于存放结点，一个s2[M]栈用于存放结点进栈标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrder</span><span class="hljs-params">( PBinTreeNode t)</span><br>&#123;   <span class="hljs-type">int</span> S2[M], top = <span class="hljs-number">0</span>, b;            <span class="hljs-comment">//结点进栈标志栈</span><br>PBinTreeNode p, S1[M];        <span class="hljs-comment">//结点栈</span><br>　<br>p = t;<br><span class="hljs-keyword">do</span><br>&#123;    <br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>S1[top] = p;<br>S2[top++] = <span class="hljs-number">1</span>;            <span class="hljs-comment">//p结点首次入栈</span><br>p = p-&gt;llink;<br>&#125;                                     <span class="hljs-comment">//遍历左子树</span><br><span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>)<br>&#123;  <br>   b = S2[--top];<br> p =S1[top];<br> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)<br> &#123;  <br>S1[top] = p;<br>  S2[top++] = <span class="hljs-number">2</span>;        <span class="hljs-comment">//p结点第二次入栈</span><br>  p = p-&gt;rlink;<br> &#125;                                 <span class="hljs-comment">//遍历p的右子树</span><br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>)<br> &#123;   <br>visit(p-&gt;info);       <span class="hljs-comment">//访问根结点</span><br>  p = <span class="hljs-literal">NULL</span>;<br> &#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>数算关键概念精简版</title>
    <link href="https://justaloli.cn/posts/51676.html"/>
    <id>https://justaloli.cn/posts/51676.html</id>
    <published>2023-04-25T09:09:48.000Z</published>
    <updated>2023-04-25T09:23:55.982Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ADT: …</p><p>数据结构: 逻辑结构、存储结构、操作</p><p>逻辑结构: …</p><p>存储结构: …</p><p>算法分类: …</p><p><em><strong>朴素的字符串匹配</strong></em></p><p><em><strong>KMP模式匹配</strong></em></p><p>FIFO、FILO: …</p><p>环形队列</p><p><em><strong>树</strong></em></p><p>树的运算</p><p><em><strong>树的遍历</strong></em></p><p><em><strong>二叉树,k叉树的多个性质!!</strong></em></p><p>二叉树的运算</p><p>二叉树的遍历</p><p>集合(bitset): 创建、插入、删除、属于、合并、交、差</p><p>字典</p>]]></content>
    
    
    <summary type="html">呕</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>C++实现一个尽可能优雅的双向链表</title>
    <link href="https://justaloli.cn/posts/46200.html"/>
    <id>https://justaloli.cn/posts/46200.html</id>
    <published>2023-04-25T04:58:55.000Z</published>
    <updated>2023-04-25T06:48:30.612Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是「数据结构与算法」课程的一部分. 在这门课中, 我们将接触各种常见的数据结构, 并了解它们各种基本操作的实现方式.</p><p>这门课的第一章为顺序表, 其中包括一种数据结构“链表”. 我产生了一种想法, 为什么不借助C++强大的类封装能力, 实现一个自己的链表呢?</p><p>我的目标是想让这个链表尽可能的“优雅”. 这要求在使用这个链表时, 各种操作应尽可能的简洁直观. 我的目标是做的比C++ STL模版库的链表易用(虽然性能可能略低), 并且尽可能靠近python的列表.</p><blockquote><p>注意: STL模版库的list是双向链表,但python的list, 据资料, 是基于变长顺序表. 这里说的靠近不是利用python list的底层逻辑, 而是实现和python list尽可能相似的调用方式.</p></blockquote><h2 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h2><p>话不多说, 先看使用例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 本程序需要引用的外部库仅iostream */</span><br><br><span class="hljs-comment">/* 例子1 简单的添加数据、打印数据 */</span><br>list&lt;<span class="hljs-type">int</span>&gt; list1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>list1.<span class="hljs-built_in">append</span>(i);<br>&#125;<br>cout &lt;&lt; list1 &lt;&lt; endl;<br><br><span class="hljs-comment">/* 例子2 列表嵌套 */</span><br>list&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; list2;<br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt; templist;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j,++num)<br>&#123;<br>templist.<span class="hljs-built_in">append</span>(num);<br>&#125;<br>list2.<span class="hljs-built_in">append</span>(templist);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; list2[i].<span class="hljs-built_in">size</span>(); ++j)<br>&#123;<br>cout &lt;&lt; list2[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>1 <br>2 3 <br>4 5 6 <br>7 8 9 10 <br>11 12 13 14 15 <br>16 17 18 19 20 21 <br>22 23 24 25 26 27 28 <br>29 30 31 32 33 34 35 36 <br>37 38 39 40 41 42 43 44 45 <br>46 47 48 49 50 51 52 53 54 55 <br>程序执行完成, 用时63微秒.<br></code></pre></td></tr></table></figure><p>使用过python的人, 应该能看出我对python列表的借鉴(比如append()); 使用过C++ STL模版库的list的人, 应该能看出它比STL list在使用(尤其是遍历)上要简单一些.</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>列表的UML类图如下:</p><pre><code class=" mermaid">classDiagram class node&#123;+T data+node* next+node* prev&#125;class list&#123;-node* head-node* tail-int _size-node* temp-int tempindex+copy() list+slice(i1,i2,i3) list+size() int+append(data) int+insert(index,data) void+swap(i1,i2) void+pop(i=-1) T+remove(data) void+clear() void+operator[](index) T+operator=(data) list+operator+(data) list+operator+=(data) list#get(index) node*#swap(node,node) void&#125;</code></pre><p>在完善这个数据类型的过程中, 遇到了很多有趣的问题, 也学习到了很多C++语法特性, 比如模版类、析构函数、运算符重载、引用符<code>&amp;</code>等等. 之后也许会慢慢整理遇到的各种问题以及经验.</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>这里只是放上完整代码. 之后有机会新建帖子进行相关的解释.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYLIST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYLIST</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> my &#123;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(args) printf(args);</span><br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">node</span>()&#123;&#125;<br><span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> T&amp; dta)&#123;data = dta;&#125;<br>T data;<br>node* next=<span class="hljs-literal">nullptr</span>;<br>node* prev=<span class="hljs-literal">nullptr</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator_base</span>&#123;<br><span class="hljs-keyword">protected</span>:<br>node* ptr;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">iterator_base</span>(node* p):<span class="hljs-built_in">ptr</span>(p)&#123;&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator_base&amp; it)<span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> ptr!=it.ptr;&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++()&#123;ptr=ptr-&gt;next;&#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)&#123;ptr=ptr-&gt;next;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span>:<span class="hljs-keyword">public</span> iterator_base&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> iterator_base::iterator_base,iterator_base::ptr;<br>T&amp; <span class="hljs-keyword">operator</span>*()&#123;<span class="hljs-keyword">return</span> ptr-&gt;data;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_iterator</span>:<span class="hljs-keyword">public</span> iterator_base&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> iterator_base::iterator_base,iterator_base::ptr;<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*()&#123;<span class="hljs-keyword">return</span> ptr-&gt;data;&#125;<br>&#125;;<br>node* head;<br>node* tail;<br><span class="hljs-type">int</span> _size;<br>node* temp;<br><span class="hljs-type">int</span> tempindex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(head-&gt;next);&#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(tail);&#125;<br><span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">const_iterator</span>(head-&gt;next);&#125;<br><span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">const_iterator</span>(tail);&#125;<br><br><br><br><span class="hljs-built_in">list</span>();<span class="hljs-comment">/* 构造函数 */</span><br><br><span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 拷贝重载，</span><br><span class="hljs-comment">做了一些区分：用这个重载是做一个影子链表，用等号重载是做一个完整地拷贝。 */</span><br><span class="hljs-comment">/* 如此，在初始化和函数传递时默认时 */</span><br><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">/* 析构函数 */</span><br><br><span class="hljs-function">list&lt;T&gt; <span class="hljs-title">copy</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/* 复制 */</span><br><br><span class="hljs-function">list&lt;T&gt; <span class="hljs-title">slice</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>)</span><span class="hljs-type">const</span></span>;<span class="hljs-comment">/* 切片 */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> _size;&#125;<span class="hljs-comment">/* 得到长度 */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>;<span class="hljs-comment">/* 追加 */</span><br><br><span class="hljs-function">list&lt;T&gt;&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> T&amp;)</span></span>;<span class="hljs-comment">/* 插入 */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">/* 交换 */</span><br><br><span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i=<span class="hljs-number">-1</span>)</span></span>;<span class="hljs-comment">/* 弹出并删除 */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>;<span class="hljs-comment">/* 删除所有和参数相同的元素 */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/* 清空 */</span><br><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span>);<span class="hljs-comment">/* 索引[]运算 */</span><br><br>list&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 赋值=运算 */</span><br><br>list&lt;T&gt; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 加+运算 */</span><br><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(list&lt;T&gt;&amp;);<span class="hljs-comment">/* 自增+=运算 */</span><br><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> T&amp;);<span class="hljs-comment">/* 自增+=运算 */</span><br><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function">node* <span class="hljs-title">gethead</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> head;&#125;<br><span class="hljs-function">node* <span class="hljs-title">gettail</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> tail;&#125;<br><span class="hljs-function">node* <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<span class="hljs-comment">/* 索引，得到节点指针 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(node*,node*)</span></span>;<span class="hljs-comment">/* 交换 */</span><br><span class="hljs-function">node* <span class="hljs-title">getFromHead</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">node* <span class="hljs-title">getFromTail</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">node* <span class="hljs-title">getFromTemp</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resetTemp</span><span class="hljs-params">()</span></span>&#123;temp=head;tempindex = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 重置temp指针保证它指向链中的某个项。 */</span><br><span class="hljs-comment">/* fun fact：虽然重置tempindex=0，但是现在temp指向head而不是第一个“元素”。</span><br><span class="hljs-comment">但这无伤大雅。由于距离的最小值判定的逻辑，查找时会优先从head向后查找，而不是用temp查找。 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;=b?a-b:b-a;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="hljs-type">const</span> list&lt;T&gt;&amp; L)&#123;<br><span class="hljs-comment">/* 运算符：重载cout输出 */</span><br>out &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:L)&#123;<br><span class="hljs-keyword">if</span>(flag)&#123;<br>out &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>flag = <span class="hljs-literal">true</span>;<br>&#125;<br>out &lt;&lt; i;<br>&#125;<br>out &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T&amp; list&lt;T&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)&#123;<br><span class="hljs-comment">/* 运算符：索引 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(i)-&gt;data;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;&amp; list&lt;T&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> list&lt;T&gt; &amp;li)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;li)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><span class="hljs-comment">/* 运算符：赋值 */</span><br><span class="hljs-built_in">clear</span>();<br>node* t = li.head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=li.tail)&#123;<br><span class="hljs-built_in">append</span>(t-&gt;data);<br>t = t-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt; list&lt;T&gt;::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> list&lt;T&gt;&amp; li)&#123;<br><span class="hljs-keyword">auto</span> rl = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">copy</span>();<br><br>node* t = li.head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=li.tail)&#123;<br>rl.<span class="hljs-built_in">append</span>(t-&gt;data);<br>t = t-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> rl;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-keyword">operator</span>+=(list&lt;T&gt;&amp; li)&#123;<br><span class="hljs-keyword">if</span>(&amp;li == <span class="hljs-keyword">this</span>)&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR: self += detected. plz use + instead.&quot;</span>;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* O1,但是引用的li会清空 */</span><br><span class="hljs-comment">/* 把中间接上 */</span><br>tail-&gt;prev-&gt;next = li.head-&gt;next;<br>li.head-&gt;next-&gt;prev = tail-&gt;prev;<br><span class="hljs-comment">/* 把结尾接上 */</span><br>tail-&gt;prev = li.tail-&gt;prev;<br>tail-&gt;prev-&gt;next = tail;<br><span class="hljs-comment">/* 更新size */</span><br>_size+=li.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">/* 让li首尾相接置空,但是不删除里面的元素(里面的元素归this了.) */</span><br>li.head-&gt;next = li.tail;<br>li.tail-&gt;prev = li.head;<br>li._size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> T&amp; dta)&#123;<br><span class="hljs-built_in">append</span>(dta);<br>&#125;<br><span class="hljs-comment">// list&lt;T&gt; list&lt;T&gt;::operator()(const int,const int,con s)&#123;&#125;</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt; list&lt;T&gt;::<span class="hljs-built_in">copy</span>()&#123;<br>list&lt;T&gt; returnlist;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _size; ++i)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br><span class="hljs-keyword">return</span> returnlist;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt; list&lt;T&gt;::<span class="hljs-built_in">slice</span>(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> p3) <span class="hljs-type">const</span>&#123;<br>list&lt;T&gt; returnlist;<br><span class="hljs-keyword">if</span>(p3&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p1; i &lt; p2; i+=p3)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p3&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p1; i &gt; p2; i+=p3)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> returnlist;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;list() called&quot;&lt;&lt;endl;</span><br>head = <span class="hljs-keyword">new</span> node;<br>tail = <span class="hljs-keyword">new</span> node;<br><br><span class="hljs-built_in">resetTemp</span>();<br><br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list&lt;T&gt;&amp; li):<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-keyword">operator</span>=(li);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br>node *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br><span class="hljs-built_in">resetTemp</span>();<br>_size=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;~list called for:&quot;&lt;&lt;*this&lt;&lt;endl;</span><br><span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;temp = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> list&lt;T&gt;::<span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> T&amp; dta)&#123;<br>temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(dta);<br>tempindex = _size;<br><br>tail-&gt;prev-&gt;next = temp;<br>temp-&gt;prev = tail-&gt;prev;<br>temp-&gt;next = tail;<br>tail-&gt;prev = temp;<br>_size++;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> list&lt;T&gt;::node* list&lt;T&gt;::<span class="hljs-built_in">get</span>(<span class="hljs-type">int</span> i)&#123;<br><span class="hljs-keyword">if</span>(i&gt;=_size||i&lt;-_size)&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;index out range&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//这是个无效值</span><br>&#125;<br><span class="hljs-type">int</span> mindis = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">int</span> minway = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i,<span class="hljs-number">0</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, <span class="hljs-number">0</span>);minway = <span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, -_size)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, -_size);minway = <span class="hljs-number">2</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, _size<span class="hljs-number">-1</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, _size<span class="hljs-number">-1</span>);minway = <span class="hljs-number">3</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, <span class="hljs-number">-1</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, <span class="hljs-number">-1</span>);minway = <span class="hljs-number">4</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i,tempindex)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i,tempindex);minway = <span class="hljs-number">5</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i+_size,tempindex)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i,tempindex);minway = <span class="hljs-number">6</span>;&#125;<br><span class="hljs-keyword">switch</span> (minway) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromHead</span>(i);<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromHead</span>(i+_size);<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTail</span>(i-_size);<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTail</span>(i);<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTemp</span>(i);<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTemp</span>(i+_size);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> list&lt;T&gt;::node* list&lt;T&gt;::<span class="hljs-built_in">getFromHead</span>(<span class="hljs-type">int</span> targeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFH called\n&quot;);</span><br>temp = head-&gt;next;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i!=targeti)&#123;<br>temp = temp-&gt;next;<br>i++;<br>&#125;<br>tempindex = targeti;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> list&lt;T&gt;::node* list&lt;T&gt;::<span class="hljs-built_in">getFromTail</span>(<span class="hljs-type">int</span> negativeTargeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFT called\n&quot;);</span><br>temp = tail-&gt;prev;<br><span class="hljs-type">int</span> i=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i!=negativeTargeti)&#123;<br>temp = temp-&gt;prev;<br>i--;<br>&#125;<br>tempindex = negativeTargeti+_size;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> list&lt;T&gt;::node* list&lt;T&gt;::<span class="hljs-built_in">getFromTemp</span>(<span class="hljs-type">int</span> targeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFTMP called\n&quot;);</span><br><span class="hljs-keyword">while</span>(targeti&gt;tempindex)<br>&#123;<br>temp = temp-&gt;next;<br>tempindex++;<br>&#125;<br><span class="hljs-keyword">while</span>(targeti&lt;tempindex)&#123;<br>temp = temp-&gt;prev;<br>tempindex--;<br>&#125;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">swap</span>(<span class="hljs-type">int</span> ia,<span class="hljs-type">int</span> ib)&#123;<br>node* a = <span class="hljs-built_in">get</span>(ia);<br>node* b = <span class="hljs-built_in">get</span>(ib);<br><span class="hljs-built_in">swap</span>(a,b);<br>tempindex = ia;<span class="hljs-comment">//temp指向b,b的下标变为了ia.</span><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">swap</span>(node *a,node *b)&#123;<br>node *anext = a-&gt;next;<br>node *bnext = b-&gt;next;<br>node *aprev = a-&gt;prev;<br>node *bprev = b-&gt;prev;<br><span class="hljs-keyword">if</span>(a-&gt;next==b)&#123;<br>b-&gt;prev = aprev;<br>a-&gt;next = bnext;<br>b-&gt;next = a;<br>a-&gt;prev = b;<br>bnext-&gt;prev = a;<br>aprev-&gt;next = b;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a-&gt;prev==b)&#123;<br>b-&gt;next = anext;<br>a-&gt;prev = bprev;<br>a-&gt;next = b;<br>b-&gt;prev = a;<br>anext-&gt;prev = b;<br>bprev-&gt;next = a;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>a-&gt;next = bnext;<br>b-&gt;next = anext;<br>a-&gt;prev = bprev;<br>b-&gt;prev = aprev;<br>anext-&gt;prev = b;<br>aprev-&gt;next = b;<br>bnext-&gt;prev = a;<br>bprev-&gt;next = a;<br>&#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;&amp; list&lt;T&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> T&amp; value)&#123;<br>node *t;<br><span class="hljs-keyword">if</span>(i&gt;=_size)&#123;<br><span class="hljs-comment">//如果用户做了这样的输入，多半是想插入到末尾，而不是在最后一个位置的前面插入。故直接调用append</span><br><span class="hljs-built_in">append</span>(value);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(i&lt;-_size)&#123;<br>i = <span class="hljs-number">0</span>;<br>&#125;<br>t = <span class="hljs-built_in">get</span>(i);<br><span class="hljs-keyword">if</span>(!t)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(value);<br>t-&gt;prev-&gt;next = temp;<br>temp-&gt;prev = t-&gt;prev;<br>temp-&gt;next = t;<br>t-&gt;prev = temp;<br>_size++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T list&lt;T&gt;::<span class="hljs-built_in">pop</span>(<span class="hljs-type">int</span> i)&#123;<br>node *t = <span class="hljs-built_in">get</span>(i);<br>t-&gt;prev-&gt;next = t-&gt;next;<br>t-&gt;next-&gt;prev = t-&gt;prev;<br><br>T dta = t-&gt;data;<br><br>temp = t-&gt;next;<span class="hljs-comment">//删除元素时，要把那个指向链表中间的temp指针指到一个在链上的节点。</span><br>_size--;<br><span class="hljs-keyword">delete</span> t;<br><span class="hljs-keyword">return</span> dta;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> T&amp; target)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _size;)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(i)-&gt;data==target)&#123;<br><span class="hljs-built_in">pop</span>(i);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>i++;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在c++实现一个(尽可能)像python一样优雅的列表. 并总结一些在进行类封装时遇到的坑和知识点.</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第九讲 超分辨率</title>
    <link href="https://justaloli.cn/posts/33559.html"/>
    <id>https://justaloli.cn/posts/33559.html</id>
    <published>2023-04-25T04:58:55.000Z</published>
    <updated>2023-04-25T06:50:32.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>更清晰、更远的变焦!</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>传感器的分辨率是有限的.</p><p>意义:</p><ul><li>提升视觉质量!</li><li>方便下游操作、识别</li></ul><p><a href="https://github.com/bloc97/Anime4K/releases">https://github.com/bloc97/Anime4K/releases</a></p><p><a href="https://jpghd.com/">https://jpgHD.com</a></p><h2 id="基于子像素位移的多帧方法-传统方法-这是基于信号于系统原理的求解方法"><a href="#基于子像素位移的多帧方法-传统方法-这是基于信号于系统原理的求解方法" class="headerlink" title="基于子像素位移的多帧方法-传统方法(这是基于信号于系统原理的求解方法)"></a>基于子像素位移的多帧方法-传统方法(这是基于信号于系统原理的求解方法)</h2><ul><li>方法动机: 多帧低分辨率图像 -&gt; 子像素的相对关系(位移) -&gt; 恢复高分辨率</li><li>图像退化模型:</li></ul><p>图像退化模型:</p><ul><li>相对运动矩阵: 平移、旋转<ul><li>透视、局部运动</li></ul></li><li>图像模糊矩阵: </li><li>降采样 像素抽取矩阵</li><li>噪声</li></ul><p>超分辨率, 就是反方向计算这些矩阵.</p><p>简化模型: 认为模糊矩阵和降采样矩阵不同图片是相同的.</p><p>做法: 1. ML 最大似然估计 2. 最大后验概率估计</p><p>太复杂了, 我不会</p><h2 id="通过改进传感器构造"><a href="#通过改进传感器构造" class="headerlink" title="通过改进传感器构造"></a>通过改进传感器构造</h2><p>让传感器产生微小抖动(2004)</p><p>规则像素排布的问题: 平移距离为整个像素的时候, 相当于没有平移, 效果不好.</p><p>Penrose像素排布(2011): 不规则的像素排布</p><p>八元组子像素排布(2014): 不规则的像素排布</p><h2 id="单帧超分辨率"><a href="#单帧超分辨率" class="headerlink" title="单帧超分辨率"></a>单帧超分辨率</h2><ol><li>生成一张保留细节的逼真的输出图像</li></ol><p>(双三次上采样)</p><ol start="2"><li>在图像内容上与低分辨率的输入图像保持一致</li></ol><p>非学习?</p><p>例1 基于图片形状的重复(自相似)</p><p>例2 基于梯度锐化变换的方法</p><p>基于学习</p><p>例 SRCNN ECCV 14 首次将深度学习引入超分辨率</p><p>VDSR 更深的网络层数</p><p>ZSSR 自监督</p><p>…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>关键概念:<ul><li>超分辨率、图像退化模型</li></ul></li><li>原理:<ul><li>基于子像素位移的多帧方法重建的原理</li></ul></li><li>一句话总结:<ul><li>相机拍摄真实场景获得图像的过程中部分高频细节信息丢失,通过超分辨率方法能够恢复图像丢失的高频细节</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第八讲 高动态范围成像</title>
    <link href="https://justaloli.cn/posts/21773.html"/>
    <id>https://justaloli.cn/posts/21773.html</id>
    <published>2023-04-18T05:00:23.000Z</published>
    <updated>2023-04-20T07:21:46.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>HDR imaging.</p><ul><li>动态范围</li><li>图像的存储</li><li>多帧合成的动态范围</li></ul><h2 id="动态范围"><a href="#动态范围" class="headerlink" title="动态范围"></a>动态范围</h2><p>场景中最亮和最暗的部分之间的亮度比。</p><p>人眼能适应的动态范围极高，完全覆盖真实世界的常见场景。</p><p>HDR期望能覆盖真实世界的常见场景。</p><p>但还有一个问题：显示器的动态范围很低</p><p>在LDR显示器中，如何呈现真实世界的动态范围？ 「色调映射」</p><h2 id="多帧合成的动态范围"><a href="#多帧合成的动态范围" class="headerlink" title="多帧合成的动态范围"></a>多帧合成的动态范围</h2><p>曝光的“挡”：按幂级数</p><p>选择什么曝光时间？几张？</p><p>其实取决于场景的动态范围；</p><p>一般选取5张，每张曝光时间差两档。</p><p>具体原理（假设已经得到线性的RAW图像）</p><p>回顾：在不欠曝，不过曝的情况下，RAW图像亮度和环境亮度为线性。</p><p>I线性(x,y) &#x3D; min(ti * L(x,y) + noise, 255);</p><p>（最理想的的）对于某个像素而言：</p><ol><li>找到正常曝光的图像（丢掉亮度过低或过高的</li><li>对这些正常的图像，选择合适的权重进行加权平均</li></ol><p>如果只有非线性的图像呢？</p><p>辐射响应曲线利用多张曝光图也能求出来，进而把图像线性化。</p><p>每个图像，每个像素的权重怎么选？</p><p>亮度接近0.5的图像权重最大，亮度接近0或1的图像权重最小。</p><p>引申：绝对辐照度恢复</p><p>HDR图像可以恢复相对辐照度，用其它仪器测出某点的绝对辐照后，能得到绝对辐照度。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>PFM格式：32bit</p><p>RGBE：增加额外的一些数据</p><p>OpenEXR：浮点数</p><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>线性缩放亮度显然是不合理的</p><p>要进行非线性缩放：</p><ul><li>一种方法：</li></ul><ol><li>渐近线1</li><li>接近0的时候，斜率为1</li></ol><ul><li>另一种方法：</li></ul><p>对数线性压缩</p><ul><li>更好的方法！</li></ul><p>色调映射 tone mapping，主要有下面两种</p><p>滤波映射：对低频部分做更多映射；“双边滤波”：分离高低频同时保留边界的锐利</p><p>梯度色调映射：计算梯度，根据梯度进行映射</p><p>双边滤波映射和梯度重建结果已经非常优秀，谁更好取决于个人喜好。</p><p>注：单反相机可以一次拍摄大概三档的动态范围，可以直接对单个RAW图像进行一些色调映射。但它效果显然比多张图要差一些</p><h2 id="HDR的应用"><a href="#HDR的应用" class="headerlink" title="HDR的应用"></a>HDR的应用</h2><p>已经有成熟的应用</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>融合多张图像的HDR方法，有没有什么问题？</p><p>场景必须静态；相机必须静态</p><p>研究方向：1. 抖动的对齐</p><ol start="2"><li><p>单张照片得HDR（应用于HDR视频很有效，需要特殊的相机</p></li><li><p>余数相机</p></li><li><p>卷积由原图猜高光部分</p></li><li><p>卷积由原图生成高光、低光的图组，再由图组合成HDR</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第七讲 光度立体视觉</title>
    <link href="https://justaloli.cn/posts/7606.html"/>
    <id>https://justaloli.cn/posts/7606.html</id>
    <published>2023-04-11T05:00:23.000Z</published>
    <updated>2023-04-11T06:12:03.024Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>计算摄像：通过计算获取普通相机拍摄图像之外的信息</p><p>例如：通过相机获取三维形状</p><p>光度法恢复物体形状：主要通过多张图</p><p>光度方法只能获得物体一面的3d信息（背面看不到），但是，可以获得的很精确。</p><p>回顾：BRDF、电光源、平行光源、朗伯反射</p><p>朗伯反射：</p><p>i 像素值 正比于 光强 x 表面反射率 x 表面法向和光源方向的夹角（写成n点乘l）</p><p><strong>光度立体视觉：假设物体表面反射符合朗伯成像模型，给定多张不同平行光光照下的图片（I），以及光源方向（L），求解每个像素的法线方向（N）。</strong></p><p>对于每个像素点：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i1</span> <span class="hljs-operator">=</span> n · l1<br><span class="hljs-attribute">i2</span> <span class="hljs-operator">=</span> n · l2<br><span class="hljs-attribute">i3</span> <span class="hljs-operator">=</span> n · l3<br>...<br><span class="hljs-attribute">iF</span> <span class="hljs-operator">=</span> n · lF<br></code></pre></td></tr></table></figure><p>可以总结为矩阵 <em><strong>I &#x3D; N * L</strong></em> I是图像数据，N是代求每个位置的法向量，L为每张图片的光源方向。用IL求N。</p><p>至少需要三张光线方向不共面的照片，能得到唯一解。当然多了更好</p><p>I可以从图像（经过光度标定的图）直接得到</p><p>L如何得到？利用镜面球进行光源标定（其实最好的是台球）。（利用球面上的亮点）</p><p>接下来，可以进一步求解表面的漫反射率</p><p>问题：</p><ol><li>朗伯反射物体很难找</li><li>平行光很难找（太阳光是不可以的，因为它的轨迹在短时间内在同一平面（见上面第40行</li><li>要求先进行光度标定</li></ol><p>更多的研究方向：</p><ol><li>减少光源数量</li><li>非标定的光源</li><li>非标定的自然光</li><li>含有噪声的观测</li><li>复杂材质</li><li>复杂环境</li></ol><p>数据集：DiLiGenT</p><p>光度立体的精度在某些极限情况可以逼近乃至超过激光扫描。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数算关键概念一览</title>
    <link href="https://justaloli.cn/posts/11144.html"/>
    <id>https://justaloli.cn/posts/11144.html</id>
    <published>2023-04-10T13:41:45.000Z</published>
    <updated>2023-06-07T09:45:58.182Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>话不多说，直入正题</p><h1 id="课上说到的重点"><a href="#课上说到的重点" class="headerlink" title="课上说到的重点"></a>课上说到的重点</h1><p>数据结构按逻辑结构和存储结构的分类</p><p>链表的操作细节</p><p>KMP搜索算法</p><p>循环队列空和满的判断</p><p>树的三种深度周游（非递归实现）</p><p>二叉树、K叉树的各种性质!!!</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><ul><li>程序</li></ul><p>是使用程序设计语言精确描述的实现模型，它是问题求解的一个可以在计算机上运行的模型。程序中描述的数据用来表示问题中涉及的对象，程序中描述的过程表示了对于数据的处理算法;通过接受实际问题的输入，经过程序的运行，便可以得到实际问题的一个解。</p><ul><li>数据类型 data type</li></ul><p>通常是指在计算机(语言）中可以使用的一个类型，它不但包括这个类型的值的集合，还包括定义在这个类型上的一组操作。例如，整数作为一个数据类型是指在计算机上所能表示的(不是数学意义上任意大小的）所有整数和语言中定义的对于这些整数的全部操作(整数的加、减、乘、除、取余等）。在不会造成误解的上下文中，本书中提到的许多类型（例如整数类型、实数类型等）多数都指数据类型。</p><ul><li>抽象数据类型 ADT</li></ul><p>可以定义为具有一定行为（操作）的抽象(数学）类型。它不关心类型中值的具体表示方式和数据类型中定义的各种操作的具体实现方法，是所有可能的值的具体表示和各种操作的具体实现的抽象。</p><ul><li>数据结构</li></ul><p>通常，可以把数据结构理解为：计算机中表示(存储）的、具有一定逻辑关系和行为特征的一组数据。</p><p>其中的每个数据元素称为这个结构的一个<em><strong>结点</strong></em>。</p><p>本书把 <em><strong>数据结构</strong></em> 理解为 <em><strong>“抽象数据类型的物理实现”</strong></em> 。</p><ul><li><p>需要注意的是，无论从什么观点出发，算法和数据结构在程序设计中的核心地位和作用并没有任何改变。对于数据结构的不同理解，实际上都离不开以下三个要素：</p><ul><li><em><strong>逻辑结构</strong></em>：它定义了数学模型中的基本元素(结点)和元素之间的相互关系。</li><li><em><strong>存储结构</strong></em>：它给出了数学模型的具体表示方式，包括结点的表示和关系的表示。</li><li><em><strong>操作</strong></em>：它给出抽象数据类型关心的各种行为在存储结构上的具体实现算法。</li></ul></li><li><p>数据结构的分类</p><ul><li>逻辑结构<ul><li>重要概念<ul><li><code>B = &lt;K,R&gt;</code></li><li>R <strong>关系</strong> “二元组的集合”</li><li><code>&lt;k,k&#39;&gt;</code> <em><strong>前驱</strong></em>k，<em><strong>后继</strong></em>k’</li><li><em><strong>开始结点</strong></em>：没有前驱的结点，<em><strong>终端结点</strong></em>：没有后继的结点</li></ul></li><li>集合</li><li>线性结构</li><li>树形结构（老师ppt称层状）</li><li>复杂结构（老师ppt称网状）</li><li>包含关系：<code>集合包含线性结构包含树形结构包含复杂结构</code></li></ul></li><li>存储结构<ul><li>顺序表示：用一个连续的空间顺序存放数据结构中的各个结点。</li><li>链接表示：结点的存放位置是任意的,结点之间的关系通过与结点关联的指针(或者引用）方式显式表达出来。</li><li>散列表示：又称为关键码——地址转换法。即选择适当的散列（杂凑）函数，根据关键码的值将结点映射到给定的存储空间(散列表）中。</li><li>索引表示：索引与散列一样，都给出一种从关键码到存储地址的映射方法。不同的是，散列法的映射是通过函数定义，而索引法是通过建立辅助的索引结构解决。</li></ul></li></ul></li><li><p>结点</p></li></ul><p>组成结构的元素抽象成<em><strong>结点</strong></em>。分成<em><strong>初等类型</strong></em>和<em><strong>组合类型</strong></em></p><ul><li>算法</li></ul><p><em><strong>算法</strong></em>是由有穷规则构成的为解决某一类问题的运算序列(方法或过程）。</p><p>算法可以有若干<em><strong>输入</strong></em>，这些输入是在算法开始时给出的初始值或条件;算法通常又有若干个<em><strong>输出</strong></em>，它们是同输入有某种关系的计算结果。</p><p><em><strong>算法的性质</strong></em>如下：<em><strong>有穷性。</strong></em> 一个算法必须在执行了有穷步之后结束。在某些领域也需要研究不终止的算法，但这不属于本书讨论的范畴。<em><strong>确定性。</strong></em> 算法的每一步必须有确切的定义。也就是说，对于每步需要执行的动作必须严格地和清楚地给出规定。<em><strong>可行性。</strong></em> 算法是可行的，意味着算法中的每个动作，原则上都是能够由机器或人准确完成的。整个算法好像是一个解决问题的“工作序列〞，其中的每一步都是我们力所能及的一个动作。</p><p><em><strong>算法正确性：如果一个算法以一组满足初始条件的输入开始，那么该算法的执行一定会终止,并且在终止时得到满足要求的(输出）结果。</strong></em></p><ul><li>算法的设计</li></ul><p>贪心法</p><p>分治法</p><p>回溯法（深度优先</p><p>动态规划法</p><p>分枝界限法（广度优先</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ul><li>线性表</li></ul><p><em><strong>线性表</strong></em>简称为<em><strong>表</strong></em>，是零个或多个元素（也称表目）的有穷序列。</p><p>K中所含元素的个数称为表的<em><strong>长度</strong></em>,长度为零的表称为<em><strong>空表</strong></em>。</p><ul><li>顺序表</li></ul><p>采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个地存储在一片相邻的存储区域中。这种顺序表示的线性表也称为<strong>顺序表</strong>。</p><ul><li>链表</li></ul><p>每个结点就包括两个域：<em><strong>数据域</strong></em>（info)—存放元素本身的信息；<em><strong>指针域</strong></em>(link）——存放其后继结点的存储位置。由于最后一个元素没有后继，它的指针不指向任何结点，称为空指针。空指针图示中用“^”表示，算法中用“NULL”</p><p>假设一个线性表有n个元素，则这几个元素所对应的几个结点就通过指针链接成一个<em><strong>链表</strong></em>。由于这种链表中每个结点只有一个指针城，故又称为<em><strong>单链表</strong></em>。指向链表中第一个结点的指针称为该链表的<em><strong>头指针</strong></em>。</p><p>有时，为了处理方便，可以在单链表的第一个结点之前另加一个结点，称之为<em><strong>头结点</strong></em>。</p><p><em><strong>循环链表</strong></em>，<em><strong>双链表</strong></em>，<em><strong>循环双链表</strong></em></p><ul><li><p>稀疏矩阵的表示方法</p></li><li><p>三元组表示法，伪地址表示法</p></li><li><p>行-列表示法</p></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul><li>字符串</li></ul><p><em><strong>字符串</strong></em>简称串,是一种特殊的线性表，其特殊性主要在于表中的每个元素是一个字符。</p><ul><li>KMP模式匹配</li></ul><p><em><strong>（书p82）</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">makeNext()&#123;PSeqString p,<span class="hljs-type">int</span> *next&#125;&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">-1</span>;<br>next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt; p-&gt;n<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">while</span>(k&gt;=<span class="hljs-number">0</span> &amp;&amp; p-&gt;c[i]!=p-&gt;c[k])&#123;<br>k = next[k];<br>&#125;<br>i++;k++;<br><span class="hljs-keyword">if</span>(p-&gt;c[i] == p-&gt;c[k])&#123;<br>next[i] = next[k];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>next[i] = k;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进后算法分析算法 3.8 从形式上看是一个二重循环，每重循环最多执行 m次,最大运行时间可能达到0(m^2）。但仔细分析一下可知，因为每执行一次外层循环(第4行),i严格增1(第6行),所以外层循环正好执行m-1 次;另外k 的值从-1 开始（第2行）,执行k +m-1次(第6行),并且只有在这一语句中k 被增值。在内层循环(第5行)中,语句<code>k= next[k]</code>至少使长减少1,所以整个算法中，这个语句的执行次数累计起来不可能超过m-1次(否则k将小于 -1,这是不可能的），所以内层循环总的执行次数最大为m-1。因此算法3.8的执行时间为0(m）。与算法3.6的执行时间合在一起，得到用长度为m的模式串p与长度为n的目标串t进行匹配所需的总计算时间为 O(m +n)。Knuth 等人提出的快速模式匹配算法，当 n≥m时，其优越性是显然的，特别在一个模式被反复使用时，只要花一次0(m）的时间计算 next 数组，以后的每次匹配只要用0(n）的时间;但是，当n与m 接近，并且处理只匹配一次的模式时，朴素的匹配算法所花的时间代价也可能会更为节省。快速匹配的算法意义还在于：算法本身的设计方法具有代表性，它首先建立了next 数组，以此作为匹配过程的工具，从而提高了匹配的速度；另外，算法3.6 和算法3.8 的时间分析方法也是常用的方法之一，希望读者掌握。</p><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><ul><li>栈</li></ul><p><em><strong>栈</strong></em>是一种特殊的线性表，它所有的插入和删除操作都限制在表的同一端进行。表中允许进行插入、删除操作的一端叫做<em><strong>栈顶</strong></em>，另一端则叫做<em><strong>栈底</strong></em>。当栈中没有元素时，称为<em><strong>空栈</strong></em>。</p><p>因此，栈又称为<em><strong>后迸先出</strong></em>(Last in First Out, LIFO)表或<em><strong>下推表</strong></em>。</p><p>由于栈是一种动态结构，而数组是静态结构，因此，当栈中已经有 MAXNUM个元素时，如果再做进栈运算，则会产生溢出，通常称为<em><strong>上溢</strong></em>(overflow）；而对空栈进行出栈运算时也会产生溢出,通常称为<em><strong>下溢</strong></em>(underlow）。为了避免溢出，在对栈进行进栈运算和出栈运算前，应分别检测栈是否已满或是否已空。</p><p><em><strong>中缀表达式的计算，书p100</strong></em></p><ul><li>队列</li></ul><p>队列也是一种特殊的线性表，是一种只允许在表的一端进行插人操作,而在另一端进行删除操作的线性表。允许进行删除的一端称为<em><strong>队头</strong></em>，允许进行插入的一端叫做<em><strong>队尾</strong></em>。当队列中没有任何元素时，称为<em><strong>空队</strong></em>。</p><p>队列的插入操作通常称为<em><strong>入队</strong></em>，队列的删除操作通常称为<em><strong>出队</strong></em>。</p><p>队列同现实生活中等车、买票的排队相仿，新来的成员总是加入到队尾，每次离开队列的总是队头上的，即当前“最老的”成员。因此，队列也称为<em><strong>先进先出</strong></em>(First In First Out, FIFO)表。</p><p>在顺序表示的队列中，同栈一样存在队列溢出问题。即当队列满时，再做入队操作，这种现象称为<em><strong>上溢</strong></em>;而当队空时，做出队操作，这种现象称为<em><strong>下溢</strong></em>。这些现象在运算中都要考虑。</p><p><em><strong>环形队列</strong></em></p><p>为区分空队列与满队列两种情况的环形队列，一般是牺牲队列中的一个结点，当队列中已有 MAXNUM-1 个结点时就称满，再要插入就发生溢出。（p105</p><p>注意形如<code>(k+1)%n</code>的形式</p><p><em><strong>双端队列</strong></em>是一种特殊的线性表，对它所有的插人和删除都限制在表的两瑞进行。它好像一个特别的书架，取书和存书限定在两边进行。</p><p><em><strong>双栈</strong></em>是一种加限制的双端队列，它规定从一端插入的元素只能从同一端删除，它就好像两个底部相连的栈。</p><p><em><strong>超队列</strong></em>是一种输出受限的双端队列，即删除限制在一端进行,而插入仍允许在两端进行。它好像一种特殊的队列,允许有的最新插入的元素最先删除。</p><p><em><strong>超栈</strong></em>是一种输人受限的双端队列，即插入限制在一端进行,而删除仍允许在两端进行。它可以看成对栈溢出时的一种特殊的处理，即当栈溢出时，可将栈中保存最久的元素删除。</p><h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><p>default定义：</p><p><em><strong>！！根的层数为0</strong></em></p><p>所有节点的最大层数为树的高度。</p><p>只有根节点的树的高度为0</p><p>空树的高度为-1</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li>运算:</li></ul><p><em><strong>创建一颗空树、判断是否为空树、求根结点、求父结点、求第一个子结点、求右兄弟、遍历树（树的周游）</strong></em></p><ul><li><p>树的存储方式</p></li><li><p>树的遍历（周游</p><ul><li>深度方向</li><li>广度方向</li></ul></li><li><p>深度方向</p><ul><li>先根遍历</li><li>中根遍历</li><li>后根遍历</li></ul></li><li><p>先根遍历</p></li></ul><p>任何结点，先根遍历完后：如有右兄弟，进入右兄弟；否则，进入上一层（父结点）的右兄弟。</p><ul><li>中根遍历</li></ul><p>任何结点，中根遍历完（长子子树也已经遍历完）后：</p><p>1)如有第2颗子树，进入。2）否则（也无其它子树），父结点第2颗和2后的子树，进入前需要保存右兄弟，以便子树遍历完后，进入右兄弟。</p><ul><li>后根遍历</li></ul><p>任何结点，后根遍历完后：如有右兄弟，进入右兄弟；否则，上一层（父结点）</p><ul><li><p>三种深度遍历的非递归实现（重要‼️）看ppt</p></li><li><p>广度方向（层次遍历）</p></li></ul><p>利用队列</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><em><strong>二叉树的定义:</strong></em> 结点的有限集合，该集合或者为空集，或者由一个称为根的结点和两颗互不相交的分别称为根的“左子树”和“右子树”的二叉树组成。</p><p>注意：左子树存在，右子树不存在，和左子树不存在，右子树存在是两种不同情况。</p><p><em><strong>运算: 创建、判断是否为空、求根、求父节点、求左子女、求右子女、周游</strong></em></p><p>‼️重要：二叉树并不属于树，<em><strong>二叉树不是树的特殊形态</strong></em>。二叉树在只有一棵子树时，也要明确是左子树还是右子树。这和普通的树是完全不同的。</p><p>满二叉树：<em><strong>如果一棵二叉树的任何结点或者是树叶，或者有两棵非空子树，则此二叉树称作“满二叉树”。</strong></em> <em><strong>注意这个定义和普通定义不同。</strong></em></p><p><em><strong>全满二叉树：</strong></em>为普通定义的“满二叉树”。</p><p><em><strong>完全二叉树</strong></em>：如果一棵二叉树至多只有最下面的两层结点度数可以小于2，并且最下面一层的结点都集中在该层<em><strong>最</strong></em>左边的若干位置上，则此二叉树称为“完全二叉树”。</p><p><em><strong>扩充二叉树</strong></em>：把原来二叉树节点中，度小于2的节点都扩充为度为2的节点。注意：在扩充二叉树的过程中，<em><strong>新增加的“外部节点”一定比原来存在的“内部节点”个数多1</strong></em></p><p>假定内部结点数为n，则扩充二叉树中有2n条边，2n+1个结点，因此外部结点数目为:2n+1-n&#x3D;n+1。</p><p><em><strong>外部路径长度E</strong></em>：在扩充的二叉树里从根到每个外部结点的路径长度之和。</p><p><em><strong>内部路径长度I</strong></em>：在扩充的二叉树里从根到每个内部结点的路径长度之和。</p><p><em><strong>E &#x3D; I + 2n</strong></em></p><h3 id="二叉树的性质："><a href="#二叉树的性质：" class="headerlink" title="二叉树的性质："></a>二叉树的性质：</h3><ol><li>在二叉树的“i层”上至多有 $2^i$ 个结点(i&gt;&#x3D;0)。<ol><li>在二叉树的“第i层”上至多有 $2^{i-1}$ 个结点(i&gt;&#x3D;1)。</li></ol></li><li>深度为k的二叉树至多有 $2^k-1$ 个结点(k&gt;&#x3D;0)。</li></ol><p>常考的性质！！！</p><ol start="3"><li><p>对任何一棵二叉树T，如果其叶子结点(度为0的节点)数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</p></li><li><p>具有n个结点的<em>完全二叉树</em>的深度k &#x3D; log(n+1)。</p></li><li><p>对于有n个节点的<em>完全二叉树</em>，从上到下，从左往右编号（从1开始）</p><ol><li>i&#x3D;1 i为根</li><li>i &gt; 1，i的父节点为i&#x2F;2</li><li>如果2i &gt; n,i无左子女，否则i的左子女为2i</li><li>如果2i+1 &gt; n,i无右子女，否则i的右子女为2i+1</li></ol></li><li><p>在<em>扩充二叉树</em>中，外部节点比内部节点多1</p></li><li><p><em>扩充二叉树</em>中，外部路径长度E &#x3D; 内部路径长度I + 2 * 内部节点数n</p></li></ol><p>要掌握性质7的证明</p><p><img src="/posts/11144/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A87%E7%9A%84%E8%AF%81%E6%98%8E.jpg"></p><h3 id="K叉树"><a href="#K叉树" class="headerlink" title="K叉树"></a>K叉树</h3><p>满（之后叶子和度为K的）K叉树；完全（顺序）K叉树；完全满K叉树</p><h1 id="集合与字典"><a href="#集合与字典" class="headerlink" title="集合与字典"></a>集合与字典</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="基于位向量的集合"><a href="#基于位向量的集合" class="headerlink" title="基于位向量的集合"></a>基于位向量的集合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BitSet</span>&#123;<br><span class="hljs-type">int</span> size;<br><span class="hljs-type">char</span> *array;<span class="hljs-comment">//一个字节存储8个0或1</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>size &#x3D; (n+7)&#x2F;8</li><li>which_char &#x3D; idx &#x2F; 8 &#x3D; idx &gt;&gt; 3</li><li>which_bit &#x3D; inx % 8 &#x3D; idx &amp; 7</li></ol><p>运算包括:</p><ol><li>创建 <code>size = (n+7) / 8</code></li><li>插入 <code>array[idx &gt;&gt; 3] |= (1 &lt;&lt; (idx &amp; 7))</code></li><li>删除 <code>array[idx &gt;&gt; 3] &amp;= ~(1 &lt;&lt; (idx &amp; 7))</code></li><li>判断是否属于 <code>return (array[idx &gt;&gt; 3] &amp; (1 &lt;&lt; (idx &amp; 7)))</code></li><li>集合合并 <code>res[i] = array1[i] | array2[i]</code></li><li>集合交集 <code>res[i] = array1[i] &amp; array2[i]</code></li><li>集合差 <code>res[i] = array1[i] &amp; ~array2[i]</code></li></ol><h3 id="基于链表的集合-几乎用不到"><a href="#基于链表的集合-几乎用不到" class="headerlink" title="基于链表的集合(几乎用不到)"></a>基于链表的集合(几乎用不到)</h3><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>组成: 关键码 + 属性</p><p>检索: 按照关键码进行</p><p>存储结构: 静态(不再增删)、动态(频繁增删)</p><p>标准: ASL(平均查找长度), p为查找概率, c为查找当前元素需要的比较次数.</p><p>$$ ASL &#x3D; \sum_{i&#x3D;1}^n p_ic_i $$</p><p>基本运算: 关键码和给定值的比较</p><p>字典的表示: 顺序表、散列表、树表</p><h3 id="顺序表检索"><a href="#顺序表检索" class="headerlink" title="顺序表检索"></a>顺序表检索</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DicElement</span>&#123;<span class="hljs-comment">/*元素结构*/</span><br>KeyType key;  <span class="hljs-comment">/*元素的关键码*/</span><br>DataType other; <span class="hljs-comment">/*其它属性字段*/</span><br>&#125;; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SeqDictionary</span>&#123; <span class="hljs-comment">/*字典结构*/</span><br>DicElement elementMAXNUM]; <span class="hljs-comment">/*字典数组*/</span><br><span class="hljs-type">int</span> n; <span class="hljs-comment">/*实际元素个数*/</span><br>&#125;; <br></code></pre></td></tr></table></figure><h3 id="顺序检索的ASL"><a href="#顺序检索的ASL" class="headerlink" title="顺序检索的ASL"></a>顺序检索的ASL</h3><ol><li>顺序检索 O(n)</li></ol><p>$$ASL &#x3D; \frac{n+1}{2}$$</p><blockquote><p>“+1”不能忘记！</p></blockquote><h3 id="二分检索（折半检索）的ASL"><a href="#二分检索（折半检索）的ASL" class="headerlink" title="二分检索（折半检索）的ASL"></a>二分检索（折半检索）的ASL</h3><ol start="2"><li>二分法检索 中间: (最左+最后)&#x2F;2</li></ol><h3 id="顺序字典的二分查找"><a href="#顺序字典的二分查找" class="headerlink" title="顺序字典的二分查找"></a>顺序字典的二分查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinSearch</span><span class="hljs-params">(SeqDictionary *pdic, KeyType key, <span class="hljs-type">int</span> *pos)</span>&#123;<br><span class="hljs-type">int</span> low,mid,high;<br>low = <span class="hljs-number">0</span>; high = pdic-&gt;n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(low &lt;= high)&#123; <span class="hljs-comment">//注意这里的判断</span><br>‼️mid = (low + high) / <span class="hljs-number">2</span>; <span class="hljs-comment">//注意中间位置</span><br><span class="hljs-keyword">if</span>(key &lt; pdic-&gt;elem[mid].key)&#123;<br>‼️high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//注意边界变化</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; pdic-&gt;elem[mid].key)&#123;<br>‼️low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意边界变化</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>*pos = mid;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>‼️*pos = low; <span class="hljs-comment">//它“应该在”的位置,用于后续插入</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>全满二叉树中，</p><p>$$ASL \approx log_2(n+1) - 1$$</p><blockquote><p>“+1”, “-1”不能忘记！</p></blockquote><p>折半检索必须要是有序的顺序表。</p><h3 id="分块检索的ASL"><a href="#分块检索的ASL" class="headerlink" title="分块检索的ASL"></a>分块检索的ASL</h3><p>分块，块间有序，块内无序</p><ol start="3"><li><em><strong>分块检索</strong></em></li></ol><p>假定b块，每块s个记录；s &#x3D; n &#x2F; b</p><p>对于b：可以顺序、可以折半；</p><p>对于s：只能顺序</p><ol><li>对块间顺序检索</li></ol><p>$$ASL &#x3D; \frac{b+s}{2} + 1  &#x3D; \frac{\frac ns + s }2 + 1$$</p><p>当 $s&#x3D;\sqrt{n}$时</p><p>$$ASL_{min} &#x3D; \sqrt{n} + 1$$</p><ol start="2"><li>块间折半检索</li></ol><p>$$ASL  &#x3D; log_2(\frac ns +1) -1 + \frac{s+1}2 \approx log_2(\frac ns + 1 ) + \frac s2$$</p><h3 id="散链表检索的ASL"><a href="#散链表检索的ASL" class="headerlink" title="散链表检索的ASL"></a>散链表检索的ASL</h3><ul><li><p>散列函数：h(key)</p></li><li><p>散列地址：location &#x3D; h(key)</p></li><li><p>散列表：通过h(key)建立起来的线性表（能够随机存取的顺序表）。</p></li><li><p>“碰撞”：h(key1) &#x3D; h(key2)。需要避免。key1和key2称同义词。</p></li><li><p>“基本区间”：通过散列函数得到的散列地址。同义词可以放在基本区域里未占用的空间，也能另开辟一片空间（溢出区）。</p></li><li><p>“负载因子”：</p></li></ul><p>$$\alpha &#x3D; \frac{散列表中的节点数目}{基本区域能容纳的节点数}$$</p><p>当$\alpha &gt; 1$时，碰撞不可避免。</p><ul><li>“二次聚集”，利用基本区域存储同义词时，不同关键码争夺同一个散列地址。</li></ul><p>处理碰撞</p><ol><li>开放地址法</li><li>再散列</li><li>拉链法</li></ol><p>如果有一组散列函数，就加上“再散列”，如果没有，答1或3</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="排序的类别和性能"><a href="#排序的类别和性能" class="headerlink" title="排序的类别和性能"></a>排序的类别和性能</h2><h2 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="一大堆概念"><a href="#一大堆概念" class="headerlink" title="一大堆概念"></a>一大堆概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>顶点、边（无向图）&amp;弧（有向图）</p><p>完全图（任意两个顶点都有边&amp;弧）</p><p>度（无向图）入度、出度（有向图）</p><p>有向图中，度&#x3D;入度+出度</p><p>$$节点数e &#x3D; \frac12 \sum_{i&#x3D;1}^{n}D_i$$</p><p>路径：从v1到v2经过的顶点的序列</p><p>路径长度：边的数目；带权：权值之和</p><p>环</p><p>根：到任何顶点都有路径</p><p>子图</p><p>【针对无向图的】连通图：</p><p>v1和v2连通：v1和v2存在路径</p><p>图连通：任意两个顶点都连通</p><p>不连通的图可以被划成多个<em><strong>极大连通子图</strong></em></p><p><em><strong>无向图的极大连通子图也称作连通分量</strong></em></p><p>【针对有向图的】强连通图</p><p>强连通：任意两个顶点都双向连通</p><p>不强连通的图，可以分成几个<em><strong>极大强连通子图（又称作强连通分量）</strong></em></p><p>权，网络</p><p>网络：带权的（无向的）连通图或（有向的）强连通图</p><p>生成树：<em><strong>包含原图中所有节点的极小连通子图</strong></em></p><p>生成树具有n-1条边。</p><h2 id="两种表示法"><a href="#两种表示法" class="headerlink" title="两种表示法"></a>两种表示法</h2><p>邻接矩阵；</p><p>邻接表，逆临接表；</p><h2 id="周游"><a href="#周游" class="headerlink" title="周游"></a>周游</h2><p>DFS</p><p>BFS</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>P算法</p><p>K算法</p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="单源最段路"><a href="#单源最段路" class="headerlink" title="单源最段路"></a>单源最段路</h3><p>D算法</p><h3 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h3><p>F算法</p><h2 id="AOV和拓扑排序"><a href="#AOV和拓扑排序" class="headerlink" title="AOV和拓扑排序"></a>AOV和拓扑排序</h2><p>拓扑排序可以检测一个有向图是否有回路。</p><p>算法思路：选取入度为0的节点；删除这个节点的出弧，减小相连的节点的入度，继续选取入度为0的节点；如果最后尚有顶点剩余，则有环，返回失败。</p><p>需要开辟一个数组计算每隔节点的入度。</p><p>对所有入度为0的节点，可以建立一个静态栈（用数组的值表示下一个入度为0的节点）。利用栈控制，拿出入度为0的节点。</p><h2 id="AOE和关键路径"><a href="#AOE和关键路径" class="headerlink" title="AOE和关键路径"></a>AOE和关键路径</h2><p>关键路径算法可以用来解决<em><strong>最长路径</strong></em></p><p>AOE网中有些活动可以<em><strong>并行进行</strong></em>，所以完成整个工程的最短时间是从开始顶点到完成顶点的 <em><strong>最长路径长度</strong></em> 、路径长度为路径上各边的权值之和。把开始顶点到完成顶点的 <em><strong>最长路径称为关键路径。</strong></em></p><p>顶点为“事件”，边为“活动”</p><ol><li>到达事件的最早时间</li></ol><p>进入vj的活动都结束，才能到达vj这个事件</p><p>有活动<code>&lt;vi,vj&gt;</code>则</p><p>$$\begin{aligned}ee(0) &amp;&#x3D; 0 \\ee(j) &amp;&#x3D; max(ee(i) + d(i,j))\end{aligned}$$</p><ol start="2"><li>vi允许发生的最迟发生时间</li></ol><p>为了不拖延整个工期，vi发生的最晚时间不得迟于其后继事件vj的最晚发生时间减去活动<code>&lt;vi,vj&gt;</code>的持续时间。</p><p>$$\begin{aligned}le(n-1) &amp;&#x3D; ee(n-1) \\le(i) &amp;&#x3D; min( le(j) - d(i,j) )\end{aligned}$$</p><ol start="3"><li>活动<code>ak=&lt;vi,vj&gt;</code>的最早开始时间</li></ol><p>就是ak的起始点vi的最早开始时间</p><p>$$ea(k) &#x3D; ee(i)$$</p><ol start="4"><li>活动<code>ak=&lt;vi,vj&gt;</code>的最迟开始时间</li></ol><p>就是ak的终点vj的最迟开始时间减去ak的持续时间</p><p>$$la(k) &#x3D; le(j) - d(i,j)$$</p><p>时间余量：la(k) - ea(k)，即可以推迟的时间</p><p>关键活动：时间余量为0的活动</p><p>关键路径由关键活动构成。</p><ul><li>延误关键活动的持续时间，推迟整个工程时间；</li><li>缩短非关键活动的持续时间，对整个工程时间无影响；</li><li>只有缩短关键活动的持续时间，才能缩短整个工程时间，但可能引起关键活动的变化；</li><li>缩短某些关键活动的持续时间，并不一定提前工程完成时间；</li></ul><p><em><strong>计算ee，le时需要按照一定顺序计算。这种顺序是拓扑序列</strong></em>。因此在算法中要首先执行拓扑排序。</p>]]></content>
    
    
    <summary type="html">讨厌这个。</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第十二讲 图像反射消除</title>
    <link href="https://justaloli.cn/posts/63671.html"/>
    <id>https://justaloli.cn/posts/63671.html</id>
    <published>2023-04-04T05:01:22.000Z</published>
    <updated>2023-04-18T05:00:46.686Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>（为什么是第十二讲）有一些论文原作者可以来讲，因此调整了一下顺序。</p><p>讲者1 常亚坤</p><p>主要内容：</p><ol><li>背景介绍<ul><li>成像模型、反射特性</li></ul></li><li>经典优化求解</li><li>基准评价数据集</li><li>基于深度学习的方法。</li></ol><h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h3><ol><li>反射的成因（经典物理图像</li><li>反射的特性<ol><li>若反射和背景都在景深内，结果相当于线性叠加</li><li>若反射在景深外，背景在景深内，结果相当于给反射加了模糊的卷积</li><li>若反射镜有厚度，将出现重影</li></ol></li><li>反射的（不利）影响<ol><li>例子：对着玻璃拍容易不美观</li><li>对后期计算造成干扰</li></ol></li><li>反射的消除</li></ol><h3 id="2-传统方法"><a href="#2-传统方法" class="headerlink" title="2. 传统方法"></a>2. 传统方法</h3><ol><li>“人力驱动”，手工标记数据</li></ol><p>它基于了“背景图层和反射图层一定程度上是独立的”的假设。</p><p>主要过程：第一阶段：边缘标记和边缘分类-&gt;第二阶段：反射消除</p><ol start="2"><li>景深引导的反射消除</li></ol><p>主要依据：背景清晰时，反射多半会模糊。在梯度分布中也能看出。如果清晰的图像被模糊，梯度值更聚集于0（图像变化更平滑）；如果原本模糊的图像被模糊，则梯度直方图没有太大变化。</p><ol start="3"><li><p>基于相对平滑性</p></li><li><p>基于多张图像：基于两层图像的位移不一致。</p></li></ol><p>变换相机角度，拍摄多张图像。移动时，背景的边缘移动和反射的边缘移动有不同。</p><h3 id="基准评价数据集"><a href="#基准评价数据集" class="headerlink" title="基准评价数据集"></a>基准评价数据集</h3><p>讲者：万人杰</p><p>量化地评价消除反射的效果。</p><p>SIR2数据集；SIR2+数据集</p><p>（后面还有一下东西，没仔细听了呜呜</p><h3 id="深度学习去反射"><a href="#深度学习去反射" class="headerlink" title="深度学习去反射"></a>深度学习去反射</h3><p>第一篇（CN ACCV 16</p><p>借鉴了传统方法的思路，对深度进行分类，然后进行剔除</p><p>Fan ICCV 17</p><p>通过神经网络学背景层的边缘，辅助去除反射</p><p>借鉴了传统的两步走方法：先提取边缘，分类，再剔除</p><p>Wan CVPR 18 CRRN</p><p>并联的反射消除网络</p><p>Wan TPAMI 19 CoRRN</p><p>“协作式”的神经网络，</p><p>Zhang CVPR 18</p><p>“感知损失函数”辅助去反射</p><p>。。。。</p><p>基于偏振的反射消除</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第六讲 光照，反射率与明暗模型</title>
    <link href="https://justaloli.cn/posts/43140.html"/>
    <id>https://justaloli.cn/posts/43140.html</id>
    <published>2023-03-28T05:01:31.000Z</published>
    <updated>2023-04-18T05:00:41.594Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>光度模型</p><p>三维建模方法，激光测距扫描？</p><p>多视角图像重建结果（相机几何标定</p><p>对比：</p><p>几何建模：有总体形状，无细节</p><p>光度立体：无形状？，有精细的细节</p><p>利用光强理解物体的形状，计算机如何从图像的强度中理解物体形象？</p><p>光度成像过程：</p><p><code>光照-&gt;表面法线+反射率-&gt;光强</code></p><p>图像是对场景的观测，观测结果收到几何位置（第三讲）和光强的影响（本讲）</p><p>相机辐射响应：由光强和传感器数值的函数关系。</p><p>线性非线性？场景的辐射度和传感器受到的辐照度是线性的。但是传感器对辐射转化为图像亮度的关系是非线性的。</p><p>相机的辐射响应曲线：图像亮度-辐照度的函数关系。低辐照度时，亮度会高于线性值。</p><p>如何反推原本的辐照度值？反函数，逆响应曲线。</p><p>如何得到逆响应曲线？</p><ul><li>标定法：已知反射率的灰度色块序列（如果认为相机的RGB三个辐射响应曲线相同（这是目前的常见情况）可以单纯用灰度色块标定；而更复杂的情况需要各种颜色的色块做标定。</li><li>没色卡怎么办！多曝光序列的自标定(Mitsunaga, CVPR 99) 用已知<code>曝光时间比</code>的内容一致的图像序列进行标定。利用静态场景不同曝光时间拍摄的一组照片进行标定。<ul><li>待求解的函数：辐照度E &#x3D; g(M)，M为光强，</li><li>将g用k次多项式拟合，k为？4-5阶</li><li>已知曝光时间的比值</li><li><strong>曝光时间比值等于场景辐照度的比值</strong>。</li><li>带入，待定系数，形成一个待优化的目标函数</li><li>利用端点(g(0)&#x3D;0;g(1)&#x3D;1)减少一个系数</li><li>用单调性约束</li><li>最小二乘法</li></ul></li></ul><ul><li>不用线性拟合？<ul><li>Grossberg CVPR 03</li><li>分析许多相机的辐射响应曲线，得到一个“主成分”分析</li><li>将主成分函数按不同比例结合，可以用很少的参数高精度地拟合辐射响应曲线</li></ul></li></ul><p>已经得到了线性的辐照度，如何拿来重建环境的光度？</p><ul><li>反射模型：漫反射、镜面反射</li><li>BRDF：双向反射率分布函数，值为给定入射光方向和反射光方向（一个方向用两个数据，故函数为4元），输出反射能量与入射能量的比值。</li><li>优化：在各向同性（具有旋转对称性），BRDF可简化为三元函数。</li></ul><p>一些难办的光传播现象：这些都不管了！</p><ul><li>折射</li><li>相互反射（光线的多次反射</li><li>次表面反射（树叶半透明</li></ul><p>理想漫反射：朗伯反射：BRDF为常数，反射率为常数。</p><p>光源？</p><ul><li>点光源：向所有方向发出同等强度光。</li><li>平行光源：</li><li>聚光灯：在锥内有光</li></ul><p>表面法线。</p><p>光度成像模型的定量描述：</p><p>L(w_r) &#x3D; 积分（环境光照 * BRDF * 表面法线) dw_i</p><p>简化：朗伯反射模型的平行光反射：好像是一个单项式，挺简单的。</p><p>学术前沿：</p><p>老师梳理了好几篇这方面的文章，主要关于重建场景的光照。并把这个光照信息应用于AR物品的光照渲染。</p>]]></content>
    
    
    <summary type="html">基本上是关于如何由图像得到场景的亮度信息（亮度信息可以帮助重建场景，也能帮助识别物体，比如借助明暗来识别物体。</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第五讲 焦点堆栈与光场摄像</title>
    <link href="https://justaloli.cn/posts/37162.html"/>
    <id>https://justaloli.cn/posts/37162.html</id>
    <published>2023-03-21T05:00:39.000Z</published>
    <updated>2023-04-10T13:45:54.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Focal Stack and Light Field</p><p>上节课的虚拟大光圈是基于“算法”的。直接得到的深度信息很有限。</p><p>本节课将介绍“物理”地方法，从场景中更直接地得到更多深度信息。</p><p>镜头成像：只有一个平面可以聚焦。</p><ul><li><p>如何得到各个深度都清晰的成像？</p><ul><li>快速拍多个不同聚焦平面的照片-&gt;焦点堆栈（Focal Stack Imaging）。</li><li>再得到一张全部对焦的图片（算法加工）（all-in-focus）</li></ul></li><li><p>如何捕获焦点堆栈照片？需要固定哪些参数，更改什么参数？</p><ul><li>更改镜头到传感器的距离S’！（Focal distence）</li><li>也可以更改镜头到物体的距离S</li></ul></li><li><p>如何得到最清晰的部分？（合成）</p><ol><li>图像对齐（Alignment&amp;registration）<ul><li>调整Focal distence时，视场FoV会有些微变化（参见第四讲），要进行一定地缩放调整。</li></ul></li><li>权重分配<ul><li>如何测量每个像素的清晰程度？<strong>这也是相机自动对焦的工作原理</strong></li><li>每个图像，清晰的地方给高权重</li></ul></li><li>加权平均<ul><li>对每个图像每个像素点进行加权平均。</li></ul></li></ol></li><li><p>注：相机自动对焦（主要通过提取边缘）</p><ul><li>做拉普拉斯算子（是一种差分）（可以起到提取边缘的作用）（也有其它提取边缘的方式）</li><li>再做高斯模糊（拉普拉斯算子对噪声比较敏感，模糊起到平滑作用，降噪）</li><li>还有主动对焦方式：比如ToF传感器</li></ul></li><li><p>在焦点堆栈过程中，我们事实上得到了一些深度信息。但是这个信息比较模糊。</p></li><li><p>学术前沿：利用对焦距离和光圈调整估计表面深度（高精度）</p><ul><li>不仅改变焦点距离、同时改变光圈</li><li>利用光圈和对焦距离两个信息得到尽可能真实的深度。</li></ul></li></ul><p>光场不同子集不同角度拍，得到真实光线的，可以还原场景光线的所有光线。</p><p>光场：所有光线的集合</p><p>光场表示方法: L(u,v,s,t)，uv表示光在透镜平面穿过的位置、st表示光在传感器平面穿过的位置。用uvst可以得到透镜到传感器之间的所有光线。</p><p>如何得到光场数据？</p><p>用相机阵列进行光场摄像 or 用一个相机移动进行拍摄</p><p>如何单次相机单次拍摄？</p><p>光场摄像。不让传感器精确聚焦，而是让聚焦的光重新散开（利用一个微透镜阵列），传感器可以得到更丰富的信息。</p><p>学术前沿：深度学习生成光场</p><p>学术前沿：神经辐射场NeRF</p>]]></content>
    
    
    <summary type="html">焦点堆栈与光场摄像</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象编程经验1——概论、模版类、构造函数、析构函数.</title>
    <link href="https://justaloli.cn/posts/38043.html"/>
    <id>https://justaloli.cn/posts/38043.html</id>
    <published>2023-03-17T02:47:10.000Z</published>
    <updated>2023-04-10T13:47:22.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p><strong>警告⚠️本文章逻辑略混乱，请谨慎阅读。</strong></p></blockquote><p>如<a href="https://justaloli.cn/posts/46200.html">上一篇文章</a>所言, 接下来我将以我的双向链表为案例, 分享一些在C++进行类封装及面向对象编程时积累的经验. 本文主要涉及概论、构造函数和析构函数.</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>对象可以理解为现实世界的各个实体. 现实中的实体, 往往具有一些属性(比如物理属性、几何属性等等属性), 也往往具有一些操作或行为(比如猫会叫). </p><p>在面向对象编程时, 所有操作都是针对<strong>对象</strong>进行的. 可以和面向过程编程做出一些比较. 面向对象编程的主体是对象, 即实体; 面向过程编程的主体是过程, 即操作本身.</p><p>以猫猫叫这件事情为例. 面向对象关注的是对象, 即猫. 在面向对象编程中, 猫叫被形容为</p><p><code>猫-&gt;叫</code>, <code>Cat.meow()</code>, 表示是猫这个对象做出了某种行为, 重点在猫.</p><p>而在面向过程编程中, 猫叫被形容为</p><p><code>叫:猫</code>, <code>meow(Cat)</code>, 表示叫这个行为被执行了, 重点在叫这个动作.</p><p>可以看出, 面向对象的描述方式更符合人类的直观.</p><p>实体之间有相互关系. 最重要的关系是, 实体可以分类. 一<strong>类</strong>实体往往具有相似甚至相同的属性, 并且具备一些相同的行为. 比如所有的猫可以归为一<strong>类</strong>猫. </p><p>描述一类事物应当具有哪些属性和行为(更准确的说法是方法)的过程称作类的定义. 根据类的定义, 创建一个具体的对象的过程叫类的实例化. 类是抽象概念, 对象是具体概念. 这很符合人们的常识.</p><p>类之间也有相互关系, 比如包含(更准确的说法是继承), 引用等等. </p><p>类的属性和方法有权限之分. 有些属性和方法可以外人访问和调用, 而有些属性和方法只能内部访问和调用.</p><p>定义一个类有多种方式. 我们当然可以用自然语言定义类:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">手机<br>具有的属性:<br>长、宽、高<br>型号、品牌、……<br>具有的操作:<br>开机、拨号、上网、打开程序……<br></code></pre></td></tr></table></figure><p>类的定义在C++语言中可以描述为这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> height;<br><span class="hljs-comment">//...etc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//...etc</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模版类"><a href="#模版类" class="headerlink" title="模版类."></a>模版类.</h2><blockquote><p>注意:从下文开始, 笔者假定读者有基本的C++编程基础. 并且明白双向链表的工作原理.</p></blockquote><p>模版是C++的一个语法特性. 利用模版, 我们可以创建一个含有未定数据类型的成员的类. 从代码上讲, 一个双向链表的节点可以这样定义.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>T data<br>Node&lt;T&gt;* next;<br>Node&lt;T&gt;* prev;<br>&#125;<br><span class="hljs-comment">//到这里为止,是template &lt;typename T&gt;</span><br><span class="hljs-comment">//的作用范围.在这个作用范围内,T就指代了一个数据类型.</span><br><span class="hljs-comment">//这个数据类型在实例化Node类时才被明确.</span><br></code></pre></td></tr></table></figure><p>实例化Node类时,就需要明确模版T对应的具体类型,如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node&lt;<span class="hljs-type">int</span>&gt; n;<span class="hljs-comment">//创建对象</span><br></code></pre></td></tr></table></figure><p>由于双向链表内部需要创建Node,因此双向链表的list类也需要笼罩在一个模版下.故list的定义需要:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>...<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>Node&lt;T&gt;* head;<br>Node&lt;T&gt;* tail;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的,实例化list需要明确模版T对应的类型.如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; li;<br></code></pre></td></tr></table></figure><p><strong>Remark:</strong> 类也是类型.因此这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; li;<br></code></pre></td></tr></table></figure><p>是合法的.你不过是创建了一个类型T为<code>list&lt;int&gt;</code>的列表. </p><p>不过需要注意, <strong>应当确保传入的类型具有你对类型T进行的运算</strong>. 比如你在对类型T进行了加减法, 你就需要确保你传入的类型具有加减法. </p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数."></a>构造函数和析构函数.</h2><p>在对象创建时, 将执行构造函数; 在对象销毁时, 将执行析构函数.</p><p>对于普通的情况, 程序将生成默认的构造函数和析构函数. 不过有时候, 我们需要在创建和删除类的时候进行复杂的操作, 这时就不能依靠默认的构造和析构函数了. 我们要自己写.</p><p>构造函数是一个名称和类名称相同,不填写返回值的函数.析构函数是一个波浪线<code>~</code>+类名称,不填写返回值的函数. 它们的定义方式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>Node&lt;T&gt;* head;<br>Node&lt;T&gt;* tail;<br><span class="hljs-type">int</span> _size;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义构造函数.</span><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义析构函数.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数的实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//填写构造函数的具体内容</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;<br>head = <span class="hljs-keyword">new</span> node&lt;T&gt;;<br>tail = <span class="hljs-keyword">new</span> node&lt;T&gt;;<br><br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里, <code>list&lt;T&gt;::</code>代表这是list这个类的函数(方法). 描述类方法的方式有两种: 在类内部定义,在类外部定义. 个人喜欢外部定义. 在外部定义时,需要<code>list&lt;T&gt;::</code>以明确这是list类的方法.同时需要加上<code>template &lt;typename T&gt;</code></p><p>在构造函数中, 我们创建了head和tail两个节点, 并让head和tail首尾相接. 这之后,我们让存储链表长度的变量_size设置为0. 这样, 在实例化一个list时,这些指令会被执行,从而完成链表的初始化.</p><p>一般我们不需要重写析构函数.系统会自动释放类里面的所有内存.但是这是链表,还有许多节点零散地分配在内存空间中,你不能保证系统知道它们是相连地,然后帮你释放它们.所以我们要自己实现析构函数.</p><p>析构函数的实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br>node&lt;T&gt; *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先删除链表里的所有元素,最后删除头和尾. 由于在使用中, 我们偶尔也想清空链表,因此可以把清空链表的部分拿出来,单独作为一个函数(方法).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>...<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义构造函数.</span><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义析构函数.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//定义方法</span><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;...&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br>node&lt;T&gt; *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;temp = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">警告⚠️本文章逻辑略混乱，请谨慎阅读。     以我的双向链表为案例, 分享一些在C++进行类封装及面向对象编程时积累的经验. 本文主要涉及概论、构造函数和析构函数.</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
    <category term="面向对象" scheme="https://justaloli.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第四讲 镜头 曝光 对焦</title>
    <link href="https://justaloli.cn/posts/29774.html"/>
    <id>https://justaloli.cn/posts/29774.html</id>
    <published>2023-03-14T05:01:11.000Z</published>
    <updated>2023-04-10T13:46:19.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><p>上节课复习：相机几何模型：场景和光学镜头之间的计算。</p></li><li><p>本节课：</p></li></ul><p>我能看多远（长焦、焦距）？我能看多广（广角、视场）？我能清晰地看多深（大光圈、大景深）？</p><ul><li>薄透镜成像</li></ul><p>注意：只有某个平面上的光会被清晰对焦。其它深度的物体处于失焦状态。光源将形成一个模糊圈（一个模糊的圆形）</p><p><strong>理想薄透镜不存在。现实上使用多个透镜的透镜组近似薄透镜的性质，而不是用单独的凸透镜成像。</strong></p><ul><li><p>像差：真实成像和理想的薄透镜成像的差距。比如：色差；单色像差（也称散光）</p></li><li><p>视场：通过镜头能观察到的高度、宽度（FoV）</p></li></ul><p>可以用薄透镜成像模型，通过相似三角形原理计算视场角。和焦距、传感器大小有关，呈arctan的变化。</p><ol><li><p>视场和对焦距离有关：降低对焦距离，视场减小</p></li><li><p>视场和焦距的关系：增加焦距，视场减小。</p></li></ol><p>Remark: 注意区分对焦距离（focus distence，改变镜头组到传感器的距离）和焦距(focal lens，改变镜片的光学性质)！</p><p><em>增加焦距的效果和画面裁切有类似。</em> 但是二者有区别！透视投影关系不同。</p><ol start="3"><li>视场和传感器大小的关系：画幅越大视场越大。</li></ol><p>全画幅（35mm）、中画幅（中画幅比全画幅大，中画幅是全画幅出现之前的标准44x33mm）、APS、……</p><p>fun fact：哈勃望远镜的焦距57.6m</p><ul><li>定焦镜头&amp;变焦镜头？</li></ul><p>定&amp;变的是焦距(focal lens)，对焦距离（focus distence）都能变。</p><ul><li>其它镜头：微距镜头，消除色差镜头，非球面镜，……</li></ul><h2 id="曝光Exposure"><a href="#曝光Exposure" class="headerlink" title="曝光Exposure"></a>曝光Exposure</h2><ul><li>快门速度(Shutter Speed)</li></ul><p>慢快门会让快速运动的物体变模糊(motion blur，动态模糊)。有一些去除动态模糊的算法。</p><p>快门的效果也可以利用：如拍摄星轨、延时摄影。</p><ul><li>光圈(Aperture)</li></ul><p>f-number 是焦距&#x2F;光圈口径的比值。数值越小，光圈越大。</p><p>例：50mm的镜头，光圈1.4, 光圈口径为50&#x2F;1.4 &#x3D; 36mm.</p><p>此外，可以用相似原理得到，模糊圈大小和光圈口径有关。光圈</p><p>大光圈会带来景深（Depth of Field, DoF）效果。大光圈，景深变浅。景深：图片看起来清晰的范围。</p><p>大光圈、浅景深带来虚化(bokeh,日语词)效果。</p><p>fun fact: 模糊圈和光圈形状有关。可以改变开口形状达到独特效果。</p><ul><li>镜头“速度”</li></ul><p>它指代了镜头的最大光圈。光圈大，快门快的时候也能得到足够进光的图像。因此认为镜头的“速度”快。它是(最大)光圈大小的描述。</p><ul><li>感光度(ISO)</li></ul><p>参见第二讲的内容。模拟前端的放大器将模拟电压进行放大，放大倍数就是iso！</p><h2 id="相机模式"><a href="#相机模式" class="headerlink" title="相机模式"></a>相机模式</h2><p>Auto、A、S、M、</p><h2 id="产业应用、学术前沿"><a href="#产业应用、学术前沿" class="headerlink" title="产业应用、学术前沿"></a>产业应用、学术前沿</h2><p>估计场景深度-&gt;加模糊效果</p><p>准确的算出深度是一件困难的事情。曾经，手机的双摄被用来估计场景深度；也有一些“双像素”技术，用于把前景扣出来。</p><ul><li>双像素技术：</li></ul><p>将一部分像素一分为二，配置独立的光电二极管用于成像。相当于两个间距极小的镜头拍摄的照片，可以用来得到深度信息。</p><p>现在还有用神经网络渲染大光圈的效果，不用传统的方式加模糊。</p><ul><li><p>神经网络的图像去模糊-&gt;重新再模糊，实现后期重对焦。</p></li><li><p>双像素去模糊</p></li><li><p>无镜头成像</p></li></ul><p>场景-&gt;某种调制膜mask-&gt;传感器得到图片-&gt;算法重建</p><p>mask可以对入射光进行光学上的编码，让传感器得到的数据可以被解码分析。</p><ul><li>不可见到可见</li></ul><p>拍一个墙，通过计算让墙成为“镜子”，得到一般看不到的物体。</p>]]></content>
    
    
    <summary type="html">本课内容：镜头、曝光、对焦</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第三讲 相机几何模型</title>
    <link href="https://justaloli.cn/posts/62008.html"/>
    <id>https://justaloli.cn/posts/62008.html</id>
    <published>2023-03-07T05:00:10.000Z</published>
    <updated>2023-04-10T13:45:43.860Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>回顾计算摄像</p><p>计算摄像：通过计算从照片中获取更多信息。</p><p>在多个环节可以引入计算：</p><ol><li>场景和光学镜头之间的计算</li><li>传感器上对光信号的计算</li><li>传感器到图像之间的计算</li></ol><h2 id="引言：相机想知道的东西"><a href="#引言：相机想知道的东西" class="headerlink" title="引言：相机想知道的东西"></a>引言：相机想知道的东西</h2><ol><li>我在哪里——相机的空间位置</li><li>我看到的世界——相机看到的物体的空间位置</li></ol><h2 id="裸传感器成像"><a href="#裸传感器成像" class="headerlink" title="裸传感器成像"></a>裸传感器成像</h2><p>空间每个点的漫反射光都被传感器每个像素点接收——几乎无法成像。</p><h2 id="针孔相机成像"><a href="#针孔相机成像" class="headerlink" title="针孔相机成像"></a>针孔相机成像</h2><p>针孔对光线路径做出了选择，可以得到一个倒像。</p><p>相机术语：</p><ul><li>投影中心：即小孔位置</li><li>光圈：即小孔</li><li>焦距（遮光板到传感器的距离）</li></ul><p>改变焦距，传感器上的成像大小会改变。</p><p>针孔相机的问题：孔大导致模糊；孔小导致光强小，且带来衍射问题。</p><p>进光效率：孔直径大，进光大；焦距短，接收光的效果好</p><p>档：（f值）：焦距除以针孔直径。</p><p><strong>针孔相机的成像模型可以帮助理解现代相机。</strong></p><h2 id="相机矩阵：三维到二维的坐标变换"><a href="#相机矩阵：三维到二维的坐标变换" class="headerlink" title="相机矩阵：三维到二维的坐标变换"></a>相机矩阵：三维到二维的坐标变换</h2><p>用于解释开头的两个问题。</p><p>一些数学</p><p><img src="/posts/62008/%E7%9B%B8%E6%9C%BA%E7%9F%A9%E9%98%B5.png" alt="相机将三维世界的坐标（大X）通过线性变换转化为二维大图像坐标（小x的前两个分量）"></p><p>x &#x3D; f X&#x2F;Z; y &#x3D; f Y&#x2F;Z</p><p>P &#x3D; K[R|t]X, P(x,y,z)’ 为相机上的图像坐标，K(3 * 3)为内参矩阵，R(3 * 3)为相机在世界坐标系的旋转，t(3 * 1)为相机坐标系在世界坐标系中的平移，X为物体在世界的坐标(X,Y,Z,1)’ </p><p><strong>外参矩阵蕴含了相机在空间的平移和旋转；内参矩阵蕴含了相机将外界投影到照片的方式。二者分别回答“我在哪里”和“我眼中的世界”的问题</strong></p><h3 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h3><p>让景物变大：增加焦距？减小物体到针孔的距离？效果不同！</p><p>应用：“眩晕效果（滑动变焦）”，固定前景的大小，同时改变焦距和物体距离，制造景深的变化。</p><p>极端情况：正交投影：超级超级超级长焦，深度对大小不影响。（常见于游戏。</p><h2 id="相机几何标定"><a href="#相机几何标定" class="headerlink" title="相机几何标定"></a>相机几何标定</h2><h3 id="三维匹配点标定法"><a href="#三维匹配点标定法" class="headerlink" title="三维匹配点标定法"></a>三维匹配点标定法</h3><p>利用一些已知的三维空间点-相机图像坐标的对应关系，推知整个相机矩阵。</p><p>再利用算出的矩阵分析焦距、中心点等参数（得到一个上三角矩阵和正交矩阵，分别是相机的内部参数和外部坐标旋转）。</p><h3 id="非线性优化算法，处理类似畸变问题"><a href="#非线性优化算法，处理类似畸变问题" class="headerlink" title="非线性优化算法，处理类似畸变问题"></a>非线性优化算法，处理类似畸变问题</h3><h3 id="多图棋盘格标定法"><a href="#多图棋盘格标定法" class="headerlink" title="多图棋盘格标定法"></a>多图棋盘格标定法</h3><p>已经很成熟。</p><h2 id="学术前沿"><a href="#学术前沿" class="headerlink" title="学术前沿"></a>学术前沿</h2><ol><li>大规模的相机几何标定</li><li>利用深度学习进行相机几何标定</li><li>利用图像的“消失点”“消失线”进行几何标定</li><li>从镜面反射进行几何标定</li><li>……</li></ol>]]></content>
    
    
    <summary type="html">难过，听不懂</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>今日无用英语——杂货铺的正确翻译</title>
    <link href="https://justaloli.cn/posts/14140.html"/>
    <id>https://justaloli.cn/posts/14140.html</id>
    <published>2023-03-05T05:13:01.000Z</published>
    <updated>2023-04-10T15:10:05.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>背单词软件常常将<em>grocery</em>翻译为杂货铺，以至于我很长时间认为杂货铺的翻译是<em>grocery</em>。</p><p>但深究杂货铺和<em>grocery</em>的含义，这种翻译大概是错误的。且看二者的词典释义：</p><blockquote><p>杂货（zá huò）（杂货铺词条在我的大辞海上找不到）<strong>各种日用</strong>的<strong>零星货物</strong>。如:杂货铺; 日用杂货。《醒世恒言·卖油郎独占花魁》: “一应麦豆茶酒油盐杂货, 无所不备。”<br>出处：语词卷</p></blockquote><blockquote><p>grocery &#x2F;ˈɡrəʊsəri; NAmE ˈɡroʊsəri’&#x2F;NOUN ( plural groceries )1.(especially BrE)(NAmE usually ˈgrocery store’) [countable] a shop&#x2F;store that sells <strong>food and other things</strong> used in the home. In American English ‘grocery store’is often used to mean <strong>‘supermarket’</strong>. <strong>食品</strong>杂货店（在美式英语中 grocery store 常用以指 supermarket）2.groceries [plural] <strong>food and other goods</strong> sold by a groceror at a supermarket食品杂货</p></blockquote><p>可以注意到grocery明确有“食品“的含义，而中文语境中的杂货铺，大概很少和食物联系上。此外，中文语境中的杂货铺大概是贩卖“小零碎”的低调存在，而反观grocery store，在美国甚至指supermarket，是一种高调的存在。</p><p>更直观的说，这是“杂货铺”的百度图片搜索结果：</p><p><img src="/posts/14140/%E6%9D%82%E8%B4%A7%E9%93%BA%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87.jpeg" alt="能看到几乎与食品无关，且店面偏小"></p><p>而这是grocery的Google图片搜索结果：</p><p><img src="/posts/14140/grocerygooglephoto.jpeg" alt="能看到几乎与完全是食品，且店面类似超市"></p><p>故二者词义差距很大，将杂货铺译成grocery是很不当的。</p><h2 id="杂货铺的良好翻译？"><a href="#杂货铺的良好翻译？" class="headerlink" title="杂货铺的良好翻译？"></a>杂货铺的良好翻译？</h2><p><strong>junk store</strong> 可能是杂货铺的一个较为良好的翻译。junk store直译是旧货店，而旧货店和杂货铺可能有一些重合的区域。</p><p>至少，junk store和杂货铺的重合范围一定比grocery和杂货铺的重合范围大。</p><p>这一点也可以从图片搜索结果中体现：</p><p><img src="/posts/14140/junkstoregooglephoto.jpeg" alt="junk store的google搜索结果。至少有了中文“杂货铺”的意境"></p><p><em><strong>因此在翻译“杂货铺”时，可以尝试翻译为junk store。</strong></em></p><p>这篇文章就到这里～</p>]]></content>
    
    
    <summary type="html">反正不是grocery.</summary>
    
    
    
    <category term="英语" scheme="https://justaloli.cn/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="博客" scheme="https://justaloli.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="英语" scheme="https://justaloli.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>地图着色问题</title>
    <link href="https://justaloli.cn/posts/32813.html"/>
    <id>https://justaloli.cn/posts/32813.html</id>
    <published>2023-03-01T10:33:34.000Z</published>
    <updated>2023-03-01T11:37:07.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题：地图着色问题"><a href="#问题：地图着色问题" class="headerlink" title="问题：地图着色问题"></a>问题：地图着色问题</h2><p>问题简介：将一个图分成几部分，使得对于每一个部分，其中的节点互相不连接。</p><p>问题理解：这种问题往往有多种划分方式，即有多个解。可以采用贪心法找到其中的某一个解，或者使用回溯法遍历所有的可能解。</p><h2 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h2><ul><li><p>程序实现的数据结构：图（用于存储节点之间的网状关系），集合（用于存储划分中的每个部分），由集合构成的顺序表（用于存储划分），字符串，字符串构成的顺序表（用于存储节点的名字）。</p></li><li><p>各数据结构的UML图：</p></li></ul><pre><code class=" mermaid">classDiagram    class string&#123;    -char* str        +fprint(FILE*) Void        +operator=(char*) Void        +operator==(string) Bool    &#125;    class graph&#123;    -int nodeCount    +initgraph() Void    +islinked(int,int) Bool    &#125;    class set&#123;    -int size    -bool* setarray    +add() Void    +remove() Void    +isempty() Bool    +begin() iterator    +end() iterator    &#125;    class iterator&#123;    &lt;&lt;enumeration&gt;&gt;    -int pos    -set* fatherset    +operator*(): Int    +operator++()    +next(): iterator    &#125;</code></pre><ul><li><p>算法：实现了贪心法 <strong>及</strong> 回溯法。仅上交回溯法的代码。</p></li><li><p>环境：g++ -std&#x3D;c++11; MacOS，arm64</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>收获：回顾了计算概论的内容。学习了图在计算机中的存储。复习了c++中类的写法。</p><p>问题与解决办法：</p><ul><li>问题：集合中元素的遍历。由于集合元素的存储方式，元素的存储位置在内存中可能是分立的，给集合的遍历带来困难。</li><li>查阅资料，实现了一个集合的迭代器，封装了集合的遍历过程。</li></ul><p>不足：搜索效率不高。</p><h2 id="输入输出："><a href="#输入输出：" class="headerlink" title="输入输出："></a>输入输出：</h2><p>输入为<code>filei.txt</code>，包含：</p><p>一个整数N，代表节点个数；N个字符串，代表每个节点的名字；一个N * N的矩阵，每个数是0或1。<code>a[i][j]=1</code>代表节点i和j相连。</p><p>输出为<code>fileo.txt</code>，包含：</p><p>所有可能的分划，以及可能的分划总数，以及最少的分划数。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 地图着色问题 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 20</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-comment">/* 类定义：字符串 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-type">char</span> str[MAXLEN] = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：打印字符串 */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,str);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fprint</span><span class="hljs-params">(FILE *fp)</span></span>&#123;<br><span class="hljs-comment">/* 操作：打印字符串 */</span><br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;%s &quot;</span>,str);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> s[])&#123;<br><span class="hljs-comment">/* 操作：字符串赋值 */</span><br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &lt; s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; i&lt;MAXLEN ; ++i)<br>&#123;<br>str[i] = s[i];<br>&#125;<br>str[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> string s)&#123;<br><span class="hljs-comment">/* 操作：字符串比较是否相等 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXLEN; ++i)<br>&#123;<br><span class="hljs-keyword">if</span>(str[i]!=s.str[i])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> <span class="hljs-type">char</span> s[])&#123;<br>string ts;ts = s;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>==ts;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span>&#123;<br><span class="hljs-comment">/* 类定义：图 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-comment">/* 逻辑关系：网状结构 */</span><br><span class="hljs-type">int</span> grapharr[MAXLEN][MAXLEN]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/* 构造函数，填入图的节点数 */</span><br><span class="hljs-built_in">graph</span>(<span class="hljs-type">int</span> nn)&#123;n=nn;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initgraph</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 初始化函数，读入图的数据 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;grapharr[i][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initgraph</span><span class="hljs-params">(FILE *fp)</span></span>&#123;<br><span class="hljs-comment">/* 初始化函数，读入图的数据 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>&#123;<br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%d&quot;</span>,&amp;grapharr[i][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/* 操作：判断两个节点是否连接上 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">islinked</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> grapharr[a][b];&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">set</span>&#123;<br><span class="hljs-comment">/* 类定义：集合 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 逻辑关系：集合；但是在内部实现时，利用了元素的线性结构 */</span><br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> setarray[MAXLEN] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：添加元素 */</span><br><span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;MAXLEN &amp;&amp; <span class="hljs-keyword">not</span> <span class="hljs-built_in">isexist</span>(i))&#123;<br>setarray[i] = <span class="hljs-literal">true</span>;<br>size++;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：删除元素 */</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isexist</span>(i))&#123;<br>setarray[i] = <span class="hljs-literal">false</span>;<br>size--;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> !size;&#125;<span class="hljs-comment">/* 判断集合是否为空 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isexist</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 判断元素是否存在 */</span><br><span class="hljs-keyword">return</span> i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;MAXLEN &amp;&amp; setarray[i];<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span>&#123;<br><span class="hljs-comment">/* 类定义：集合的迭代器，用于遍历集合的所有元素 */</span><br><span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<br>set* fatherset = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">iterator</span>(set* ptr,<span class="hljs-type">int</span> n)&#123;<br><span class="hljs-comment">/* 构造函数：给定一个指定位置 */</span><br>pos = n<span class="hljs-number">-1</span>;<br>fatherset = ptr;<br>(*<span class="hljs-keyword">this</span>)++;<br>&#125;<br><span class="hljs-built_in">iterator</span>(set* ptr)&#123;<br><span class="hljs-comment">/* 构造函数：定在初始位置 */</span><br>pos = <span class="hljs-number">-1</span>;<br>fatherset = ptr;<br>(*<span class="hljs-keyword">this</span>)++;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++()&#123;<br><span class="hljs-comment">/* 操作：自增 */</span><br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">while</span>(fatherset-&gt;setarray[pos]==<span class="hljs-number">0</span>)&#123;<br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> k)&#123;<br><span class="hljs-comment">/* 操作：自增 */</span><br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">while</span>(fatherset-&gt;setarray[pos]==<span class="hljs-number">0</span>)&#123;<br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>*()<span class="hljs-type">const</span>&#123;<br><span class="hljs-comment">/* 操作：取值 */</span><br><span class="hljs-keyword">return</span> pos;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; it)&#123;<br><span class="hljs-comment">/* 运算：是否不等 */</span><br><span class="hljs-keyword">return</span> it.pos!=pos;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> iterator&amp; it)&#123;<br><span class="hljs-comment">/* 运算：是否相等 */</span><br><span class="hljs-keyword">return</span> it.pos==pos;<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(fatherset,pos+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向首个元素的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向首个元素的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向末尾的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>,MAXLEN);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isunrelated</span><span class="hljs-params">(set targetset,graph g,<span class="hljs-type">int</span> node)</span></span>&#123;<br><span class="hljs-comment">/* 判断图 g 上的 node 节点是否与 targetset 里面的所有节点都不相连 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = targetset.<span class="hljs-built_in">begin</span>();i!=targetset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span>(g.<span class="hljs-built_in">islinked</span>(*i, node))&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printtempset</span><span class="hljs-params">(set tset,string i2s[MAXLEN])</span></span>&#123;<br><span class="hljs-comment">/* 将tset里面的元素对应的string全部打印。元素和字符串的对应关系存储在i2s[]中 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = tset.<span class="hljs-built_in">begin</span>();i!=tset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br>i2s[*i].<span class="hljs-built_in">print</span>();<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fprinttempset</span><span class="hljs-params">(FILE *fp,set tset,string i2s[MAXLEN])</span></span>&#123;<br><span class="hljs-comment">/* 将tset里面的元素对应的string全部打印。元素和字符串的对应关系存储在i2s[]中 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = tset.<span class="hljs-built_in">begin</span>();i!=tset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br>i2s[*i].<span class="hljs-built_in">fprint</span>(fp);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 节点数 */</span><br><span class="hljs-type">int</span> N=<span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 用一个顺序表存储所有数字元素对应的节点名称 */</span><br>string indexToString[MAXLEN];<br>graph *mygraph;<br>set leftset;<br>set groupsets[<span class="hljs-number">20</span>];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">loaddatafromfile</span><span class="hljs-params">(<span class="hljs-type">char</span> fpath[])</span></span>&#123;<br>FILE *fp;<br>fp = <span class="hljs-built_in">fopen</span>(fpath,<span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span>(fp==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br><span class="hljs-comment">/* 录入节点数 */</span><br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br><span class="hljs-comment">/* 录入所有名称 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>&#123;<br><span class="hljs-type">char</span> ts[MAXLEN]=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%s&quot;</span>,ts);<br>indexToString[i] = ts;<br>&#125;<br><span class="hljs-comment">/* 实例化、初始化图 */</span><br>mygraph = <span class="hljs-keyword">new</span> <span class="hljs-built_in">graph</span>(N);<br>mygraph-&gt;<span class="hljs-built_in">initgraph</span>(fp);<br><br><span class="hljs-built_in">fclose</span>(fp);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = groupsets[i].<span class="hljs-built_in">begin</span>(); j != groupsets[i].<span class="hljs-built_in">end</span>(); j++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> <span class="hljs-built_in">isunrelated</span>(groupsets[i],*mygraph,*j))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> shortestgroupnum = MAXLEN;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(FILE *fp,<span class="hljs-type">int</span> currentgroupnum, set::iterator currentanalyzenode)</span></span>&#123;<br><span class="hljs-comment">/* fp:写入结果的文件指针，currentgroupnum：目前有的分划数，</span><br><span class="hljs-comment">currentanalyzenode：目前要处理的节点 */</span><br><span class="hljs-keyword">if</span>(currentgroupnum&gt;<span class="hljs-number">4</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(currentanalyzenode == leftset.<span class="hljs-built_in">end</span>())&#123;<br><span class="hljs-comment">/* 完成了一次分划，输出分划结果 */</span><br><span class="hljs-keyword">if</span>(currentgroupnum &lt; shortestgroupnum)&#123;<br>shortestgroupnum = currentgroupnum;<br>&#125;<br>count++;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;第%d个结果:\n&quot;</span>,count);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentgroupnum; i++)<br>&#123;<br><span class="hljs-built_in">fprinttempset</span>(fp,groupsets[i],indexToString);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;校验结果：%s\n&quot;</span>,<span class="hljs-built_in">check</span>()?<span class="hljs-string">&quot;正确&quot;</span>:<span class="hljs-string">&quot;错误&quot;</span>);<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 带回溯的将当前节点放置到所有可能的分划中，包括已有的分划和放入一个新分划 */</span><br>set::iterator i = currentanalyzenode;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;currentgroupnum;j++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isunrelated</span>(groupsets[j],*mygraph , *i))&#123;<br>groupsets[j].<span class="hljs-built_in">add</span>(*i);<br>leftset.<span class="hljs-built_in">remove</span>(*i);<br><span class="hljs-comment">/* 放入已有的分划，向下搜索 */</span><br><span class="hljs-built_in">search</span>(fp,currentgroupnum,i.<span class="hljs-built_in">next</span>());<br><span class="hljs-comment">/* 回溯 */</span><br>groupsets[j].<span class="hljs-built_in">remove</span>(*i);<br>leftset.<span class="hljs-built_in">add</span>(*i);<br>&#125;<br>&#125;<br>groupsets[currentgroupnum].<span class="hljs-built_in">add</span>(*i);<br>leftset.<span class="hljs-built_in">remove</span>(*i);<br><span class="hljs-comment">/* 放入一个新分划，向下搜索 */</span><br><span class="hljs-built_in">search</span>(fp,currentgroupnum+<span class="hljs-number">1</span>,i.<span class="hljs-built_in">next</span>());<br><span class="hljs-comment">/* 回溯 */</span><br>groupsets[currentgroupnum].<span class="hljs-built_in">remove</span>(*i);<br>leftset.<span class="hljs-built_in">add</span>(*i);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mymain</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 实例化、初始化集合 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>&#123;<br>leftset.<span class="hljs-built_in">add</span>(i);<br>&#125;<br><br>FILE *fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;fileo.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-keyword">if</span>(fp==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><span class="hljs-comment">/* 搜索 */</span><br><span class="hljs-built_in">search</span>(fp,<span class="hljs-number">0</span>,leftset.<span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">/* 结果 */</span><br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;搜索完成，共%d个结果\n&quot;</span>, count);<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;最少分划个数为：%d&quot;</span>, shortestgroupnum);<br><br><span class="hljs-built_in">fclose</span>(fp);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">char</span> path[] = <span class="hljs-string">&quot;filei.txt&quot;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">loaddatafromfile</span>(path))<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">mymain</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>计算摄像学 第二讲 数字摄像流程</title>
    <link href="https://justaloli.cn/posts/23312.html"/>
    <id>https://justaloli.cn/posts/23312.html</id>
    <published>2023-02-28T04:52:50.000Z</published>
    <updated>2023-04-10T13:45:49.254Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="第二讲-数字摄像流程（Digital-Photography-Pipeline"><a href="#第二讲-数字摄像流程（Digital-Photography-Pipeline" class="headerlink" title="第二讲 数字摄像流程（Digital Photography Pipeline"></a>第二讲 数字摄像流程（Digital Photography Pipeline</h2><!-- ISP --><p>参考书：</p><ol><li><a href="http://szeliski.org/book">http://szeliski.org/book</a> 《Computer Vision: Algorithms and Applications, 2nd ed.》</li><li><a href="https://imagingtext.github.io/">https://imagingtext.github.io</a> 《Computational Imaging》</li><li><a href="https://link.springer.com/referencework/10.1007/978-3-030-63416-2">https://link.springer.com/referencework/10.1007/978-3-030-63416-2</a> 第二版</li></ol><p>计算摄像的三个处理位置：成像之前，成像，成像之后</p><p>本课内容：</p><ul><li>图像传感器</li><li>模拟前端</li><li>颜色滤波</li><li>-&gt;</li><li>相机内部的图像处理（ISP</li></ul><!-- 视频：手机和相机的拍照对比，好机友姜唯。 --><h3 id="图像传感器-Imaging-Sensor"><a href="#图像传感器-Imaging-Sensor" class="headerlink" title="图像传感器 Imaging Sensor"></a>图像传感器 Imaging Sensor</h3><p>拍照：快门打开-&gt;传感器接收光子、储存光子-&gt;快门关闭，曝光结束-&gt;将光子转化成数字信号处理。</p><p>核心的感光组件：光电二极管（产生电子）、势井（存储电子）。</p><p>衡量光电二极管的一个指标：QE &#x3D; 光子量&#x2F;电子量</p><p>过曝：光子过多，势井饱和；欠曝：光子过少，随机性太高。除此以外的情况，电子数基本上<strong>线性的反映光子数</strong>。</p><p>两种图像传感器的芯片：CCD &amp; CMOS</p><table><thead><tr><th>CCD</th><th>CMOS</th></tr></thead><tbody><tr><td>更高感光度</td><td>更快读出</td></tr><tr><td>更低噪声</td><td>更低成本</td></tr></tbody></table><p>目前CMOS已经能达到接近CCD的性能。</p><h3 id="模拟前端"><a href="#模拟前端" class="headerlink" title="模拟前端"></a>模拟前端</h3><p>将传感器得到的光子（电压，模拟信号）转化为数字信号</p><p>电压-&gt;「模拟放大器」-&gt;模拟电压-&gt;「模数转换器」-&gt;数字信号-&gt;「编码」-&gt;数字信号</p><blockquote><p>fun fact: ISO调整的是「模拟放大器」的强度。</p></blockquote><h3 id="颜色滤波器"><a href="#颜色滤波器" class="headerlink" title="颜色滤波器"></a>颜色滤波器</h3><p>可见光：400-700nm波长</p><p>大多数光源含有不止一种波长的光。</p><p>不同的光谱频率分布可以产生类似或者相同的颜色感知。</p><p>色温。</p><p>感光器的响应值受到光源的频谱和传感器对不同频率的接收能力影响。</p><p>人眼细胞分别对RGB三个颜色的接收能力最强。颜色滤波器在设计时参考了人眼。</p><p>滤波器在传感器上的分布？拜耳阵列（RGGB</p><p>为什么要更多绿色？简而言之，研究认为人眼对绿色更敏感。</p><p>颜色滤波没有标准答案。滤波会带来颜色风格的细微差异。</p><h3 id="相机内部对图像的处理（ISP"><a href="#相机内部对图像的处理（ISP" class="headerlink" title="相机内部对图像的处理（ISP"></a>相机内部对图像的处理（ISP</h3><p>ISP: Image Singal Processor: 广义的指将原始图像转换为“正常”图像的一系列图像处理操作。</p><p>白平衡；去马赛克；降噪；色调再现；压缩；etc。</p><h4 id="白平衡-White-Balance-WB"><a href="#白平衡-White-Balance-WB" class="headerlink" title="白平衡 White Balance WB"></a>白平衡 White Balance WB</h4><ul><li>人眼可以在不同光照环境下正确感知“白色是白色”。</li></ul><p>白平衡：不管在任何光源下，都能将白色物体还原成白色，用于校准色温的偏差。</p><p>方法：</p><ol><li>手动白平衡：手动确定某个点，某个物体是白色。</li><li>预设白平衡：预设一些光源条件下的色温</li></ol><p>经典的自动白平衡算法：</p><p>利用白平衡的特性：全局偏差，让全局RGB分别的统计值变成相同的，就白了。</p><ul><li>灰色世界假设<ul><li>逐通道计算RGB<strong>平均值</strong></li><li>逐通道利用<strong>平均值</strong>归一化</li><li>乘以“绿色通道的<strong>平均值</strong>”作为增益</li></ul></li><li>白色世界假设<ul><li>逐通道计算RGB<strong>最大值</strong></li><li>逐通道利用<strong>最大值</strong>归一化</li><li>乘以“绿色通道的<strong>最大值</strong>”作为增益</li></ul></li></ul><h4 id="去马赛克"><a href="#去马赛克" class="headerlink" title="去马赛克"></a>去马赛克</h4><p>拜耳阵列中，每个像素感受到不同颜色光，产生“马赛克效果”，需要去除。</p><p>用相邻的其它颜色像素取平均，得到当前像素的其它颜色值。</p><h4 id="降噪-Denoising"><a href="#降噪-Denoising" class="headerlink" title="降噪 Denoising"></a>降噪 Denoising</h4><p>噪声在低光照时尤为明显。</p><p>噪声的来源比较复杂：</p><ul><li>散粒噪声：光子到达服从泊松分布</li><li>暗电流：电路热效应产生一些电子</li><li>读出噪声：传感器和模拟前端电路的噪声</li></ul><p>简单降噪算法：平均滤波（卷积，利用周围像素），中值滤波</p><p>更复杂的降噪算法</p><h4 id="（色彩空间转化）"><a href="#（色彩空间转化）" class="headerlink" title="（色彩空间转化）"></a>（色彩空间转化）</h4><p>相机内部可能会把RGB色彩空间转化成HSV色彩空间。</p><p>这件事的意义：将RGB分离成更加独立的变量，方便研究。</p><h4 id="色调再现（伽马矫正"><a href="#色调再现（伽马矫正" class="headerlink" title="色调再现（伽马矫正"></a>色调再现（伽马矫正</h4><p>最初是因为CRT显示器对颜色的现实是非线性的。</p><p>目前伽马矫正与CRT无关。</p><p>人眼对低亮度更敏感，因此将相机的线性感光修正为适合人眼的非线性感光。</p><h4 id="（图像压缩）"><a href="#（图像压缩）" class="headerlink" title="（图像压缩）"></a>（图像压缩）</h4><p>略</p><h4 id="补充：RAW图像格式的意义：线性！"><a href="#补充：RAW图像格式的意义：线性！" class="headerlink" title="补充：RAW图像格式的意义：线性！"></a>补充：RAW图像格式的意义：线性！</h4><p>ISP处理后的图像和原始光强是非线性的。这不利于研究。</p><p>RAW图像仍然保持了和环境光强的良好的线性性。对计算机视觉而言非常有用:D</p><p>对一般人：保存更多信息，后期空间。</p><p>RAW的坏处：噪声，无压缩，降低连拍速度</p><p>注：RAW可能也经过了一些与处理，比如去马赛克。</p><p>将jpeg还原为RAW是一件非常困难的事情。</p><h3 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h3><p>ISP深入理解： <a href="https://www.eecs.yorku.ca/~mbrown/ICCV2019_Brown.html">https://www.eecs.yorku.ca/~mbrown/ICCV2019_Brown.html</a></p><p>更好的看paper的方法：two minute papers youtube</p><p>用卷积神经网络进行超暗照片的增强 Learning to see in the dark. ChenChen UIUC等 2018；</p><p>Day-to-Night image Synthesis for Training Nighttime Neural ISPs</p>]]></content>
    
    
    <summary type="html">本课内容：图像传感器、模拟前端、颜色滤波、相机内部的图像处理（ISP</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>胡椒厨房——现在的人，没有精力再DIY</title>
    <link href="https://justaloli.cn/posts/52048.html"/>
    <id>https://justaloli.cn/posts/52048.html</id>
    <published>2023-02-23T07:42:50.000Z</published>
    <updated>2023-04-10T15:07:33.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>儿时的回忆往往是碎片的，除了某些闪光点，其它的经历往往都变得模糊。这是我的其中一个碎片。</p><p>那可能是我很小的时候，在万达的一家餐厅。这是父母第一次带我走进这家餐厅。我记得，当我期待美食的时候，店员端上来一个呲呲作响的铁盘。我看着铁板上沸腾的神色的酱汁，血红的生肉，感到多么的新奇又不知所措。</p><p>我记得，在父母的指导下，我如何手忙脚乱地翻动盘中的食材，如何尝试把鸡蛋和米饭拌匀，如何小心翼翼地不让食材洒出来，如何用勺子用力把粘锅的食材刮下来，如何看着牛肉奇迹般地在我眼前变成我熟悉的颜色……</p><p>我记得，迫不及待品尝时，我如何被金属勺子轻轻烫到，在把握温度后如何大快朵颐，到最后，如何不舍地从盘底的沟槽中挖出最后一颗饭粒。饭粒在铁板的加热下，变得焦黄而且微微透明。</p><p>那是我小时候，去过的最好吃的餐厅之一。事实上，这可能是我第一次认识了什么是胡椒。（同样获此荣誉的，还有某次姥姥带我吃的老上海城隍庙。那次体验在我心里完全定义了什么是小笼包。）</p><p>当然，它获此荣誉，还有一个不得不提的原因：这之后的某个时候，它就被拆掉了，在我家附近再也找不到胡椒厨房这家店。这一次美好体验，就在我心里成为了抹不掉的念想。</p><p>之后，在离家较远的一个商城又看到了它。这之后，我偶尔会专程跑到这个很远的地方，专程吃一次这家店，在享用的同时重温当时的美妙回忆。我不会经常想到它。但是一旦想到，我几乎内心就不会再冒出其它选择。</p><p>然后，这天我又突发奇想去吃了一餐。却发现，这家店的名字从“胡椒厨房”变成了“铁板厨房”。虽然菜品没变，但店名的变化，总让人产生一些不安的情绪。事实上，从我家附近的胡椒厨房倒闭这件事就能看出，这个品牌的处境可能并不太好。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>胡椒厨房和普通的餐饮店有所区别。胡椒厨房的菜品主要包含米饭和肉（主要是牛肉），顾客也可以选择添加鸡蛋和蔬菜。在出餐时，店员端出的是放在高温铁盘上的生食。拿到餐品后，需要顾客自己对食材进行翻炒，直到菜品变熟后食用。也因此，胡椒厨房将自己定义为一家“DIY餐厅”。菜品口味方面，如「胡椒厨房」的店名，菜品中胡椒是重要调料，形成类似BBQ的烧烤风味。除了胡椒，顾客可以按照喜好，添加诸如「蒜香汁」等调料。</p><p>抛开童年回忆的光环，平心而论，胡椒厨房的菜品绝对是能分到「好吃」一类的。BBQ的风味显然具有很大的吸引力。此外，胡椒、蒜香的调料也可以带来独特的味觉享受。</p><p>更重要的是，DIY的特色使得胡椒厨房相比其它餐饮店具有一个巨大优势：<strong>它的饭菜一直是热的。</strong> 事实上，人对热的食物往往没有抵抗力。加热的铁盘，让食物可以长时间地保持在最适合的温度。</p><p>或许“石锅拌饭”之类的饭馆也有类似的特征，但请注意：胡椒厨房是铁盘而不是铁碗。在进食时，绝大部分的食材都能充分得到加热和保温。</p><p>要说菜品口味的不足，首先，它可能以咸口为主，对咸口不感冒的人可能不太喜欢；其次，它的菜品可能偏油腻。除此两点，它的口味大抵是令人满意的。</p><p>但是，味道好并不代表餐厅能活得好。我认为，至少有以下几点原因，让胡椒厨房变成现在这种局面。</p><p><strong>首先，也是最重要的，是价格问题。</strong> 胡椒厨房的人均50+，一言以蔽之，太贵了。一份「胡椒牛肉饭」需要49，还没鸡蛋，加个鸡蛋变成52。先不说一个鸡蛋三块钱的这个离谱问题，49，就一碗饭，一些牛肉还有一点胡椒，这个价格确实太贵了。</p><p>49，在呷哺呷哺我能买一整盘牛肉，再来个蔬菜双拼再点个锅底。这个量显然要比胡椒厨房足的多。有可能胡椒厨房的牛肉的来源更高级。但是，一言以蔽之，一般人吃不出来，<del>“感知不强”</del>。定价过高，注定了它不会受到太多欢迎。</p><p><strong>其次，胡椒厨房的定价引申出了第二个问题，就是品牌的定位不明。</strong> 笔者粗略地把线下餐饮业分成快餐和饭馆两种。从菜品上分析，胡椒厨房明显属于前者。胡椒厨房是一人一盘的一人食餐厅，这是几乎所有快餐店具有的共同特征。但是，人们对快餐的要求往往是廉价、快速。如果作为快餐店，它明显地太贵了。而且，它DIY的特性，也导致它并没有那么的“快速”。</p><p>但是，把胡椒厨房归类为“饭馆”又明显是不合适的。一人一盘的特点，让胡椒厨房不具备饭馆应有的社交功能。打个比方，如果约亲友聚会，胡椒厨房肯定不是备选项。此外，DIY的特性让它的进食过程显得有些紧张和狼狈，这不是饭馆应该有的。<em>（火锅店、烤肉店大概也具有DIY性质，但是首先，你不把食材放进去它就不会加热，所以至少还有喘息的机会；其次，它具有社交属性。）</em></p><p>它不甘于做廉价的快餐，它尝试做高端，它做50多的主食，做一百多的牛排；但是，它又没有高端餐饮应该具有的优雅和社交功能。不论从哪个角度看，胡椒厨房都是不合格的。</p><p><strong>此外，随着互联网的兴起，胡椒厨房DIY的性质又给它自身带来了第三重打击：无法外带</strong>。互联网改变了人们的饮食方式。现在，如果要吃快餐，人们往往会选择手机定外卖。因此，那些传统的“快餐店”，包括一些餐品不够高端的饭馆，都努力地做起了外卖的生意。但就在这样的时代，胡椒厨房无法外带，这就类似于宣告了自己的死亡。</p><p>目前这个时代，在繁忙的工作之余，人们大多靠定外卖草率解决；在周末休息的时候，人们大概会找一家优雅的餐馆给自己身心的享受。在这个时代，谁会专程出去吃一家看起来不那么高档，还需要自己忙活的DIY的餐厅呢？</p><p>现在的人，恐怕已经没有精力DIY了。</p><p>我祝愿我生活圈内的这唯一一家胡椒厨房还能长青。人们都时不时地希望自己能重温童年，我也希望能重温在我童年留下深刻印象的味道。我不希望当我脑海中闪过这种希望时，接踵而来的是无法释怀的空虚，即便这种希望可能与时代潮流相悖。</p>]]></content>
    
    
    <summary type="html">我喜欢，我仍然喜欢。我祝愿我生活圈内的这唯一一家胡椒厨房还能长青。人们都时不时地希望自己能重温童年，我也希望能重温在我童年留下深刻印象的味道。我不希望当我脑海中闪过这种希望时，接踵而来的是无法释怀的空虚，即便这种希望可能与时代潮流相悖。</summary>
    
    
    
    
    <category term="杂记" scheme="https://justaloli.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>

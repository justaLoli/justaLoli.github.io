<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loli的杂货铺</title>
  
  <subtitle>欢迎光临:D</subtitle>
  <link href="https://justaloli.cn/atom.xml" rel="self"/>
  
  <link href="https://justaloli.cn/"/>
  <updated>2023-04-26T14:47:43.668Z</updated>
  <id>https://justaloli.cn/</id>
  
  <author>
    <name>justaLoli</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++细节：无处不在的const修饰符</title>
    <link href="https://justaloli.cn/posts/44205.html"/>
    <id>https://justaloli.cn/posts/44205.html</id>
    <published>2023-04-26T10:10:19.000Z</published>
    <updated>2023-04-26T14:47:43.668Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>const修饰符, 顾名思义是修饰某个东西为“常量”,不允许修改. 在C++中, 有很多地方需要用到const修饰符. 它不仅是一个良好的书写习惯, 在某些情况下, 它甚至是必要的. 这篇文章试图涵盖C++中所有const的出现情况.</p><p>目录</p><ul><li>1 const与变量定义<ul><li>1.1 普通变量</li><li>1.2 指针</li><li>1.3 引用</li></ul></li><li>2 const与函数<ul><li>2.1 形参<ul><li>普通</li><li>指针</li><li>引用</li></ul></li><li>2.2 返回值</li><li>2.3 案例: 一些特殊函数<ul><li>比较运算符重载</li><li>iostream的输入输出</li></ul></li></ul></li><li>3 cosnt与类<ul><li>3.1 属性</li><li>3.2 方法<ul><li>3.2.1 方法的const</li></ul></li></ul></li></ul><h1 id="1-const-与-变量定义"><a href="#1-const-与-变量定义" class="headerlink" title="1. const 与 变量定义"></a>1. const 与 变量定义</h1><h2 id="1-1-const-与-普通变量"><a href="#1-1-const-与-普通变量" class="headerlink" title="1.1 const 与 普通变量"></a>1.1 const 与 普通变量</h2><p>这是最初级、最直观的用法: 普通变量的值可以变, 而被const修饰过的普通变量的值不能变. 由此引申出一个特性, 被const修饰的变量必须在声明时立刻初始化.</p><p>下文基本上都用<code>int</code>作为普通变量的代表. 它原则上可以直接替换为任何基本变量、结构体、类.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1.1.1 无修饰的普通变量 */</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br><br><span class="hljs-comment">/* 1.1.2 const修饰变量: 变量的值不能修改 */</span><br><span class="hljs-comment">/* const修饰的变量必须在声明时立刻初始化 */</span><br><span class="hljs-comment">// const int b; // 错误</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>a = b; <span class="hljs-comment">// 正确</span><br>b = <span class="hljs-number">1</span>; <span class="hljs-comment">// 错误, 不能修改b的值</span><br></code></pre></td></tr></table></figure><h2 id="1-2-const-与-指针变量"><a href="#1-2-const-与-指针变量" class="headerlink" title="1.2 const 与 指针变量"></a>1.2 const 与 指针变量</h2><p>我想我不用详细描述指针的作用. 指针相当于两层, 指针本身存储地址, 这是一层; 存储的地址对应一个变量, 这是第二层.</p><p>由于指针的概念有两层, const的修饰也有两层: 是第一层, 指针存储的地址不能变呢? 还是第二层, 指针指向的变量的值不能变呢?</p><p>从这两个维度出发, 可以绘制这样的表格:</p><table><thead><tr><th>指针的地址 \ 通过指针访问的变量的值</th><th>能变</th><th>不能变</th></tr></thead><tbody><tr><td>能变</td><td><code>int*</code></td><td><code>const int*</code></td></tr><tr><td>不能变</td><td><code>int* const</code></td><td><code>const int* const</code></td></tr></tbody></table><p>我觉得上表已经很简明的描述了这四种指针的定义以及主要特点. 读者可以对照下面的使用例来判断自己理解是否正确.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1.2 const与指针 */</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> d = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> e = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> f = <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">/* 1.2.1 普通 int* 型指针: 指向 可变类型 的 可变指针 */</span><br><span class="hljs-type">int</span>* p1 = &amp;c; p1 = &amp;d; *p1 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 都正确</span><br><span class="hljs-comment">/* 普通指针无法指向const修饰的变量 */</span><br>p1 = &amp;e; <span class="hljs-comment">// 错误</span><br><br><span class="hljs-comment">/* 1.2.2 const int* 型指针: 指向 不可变类型 的 可变指针</span><br><span class="hljs-comment">即: 指针指向的位置可以修改, 指针指向的位置的值不能修改 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p2;<br>p2 = &amp;e; <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">/* const int* 可以指向普通变量, 此时直接访问普通变量可以修改其值, 但通过指针访问该变量则不能修改. */</span><br>p2 = &amp;c; <span class="hljs-comment">// 正确</span><br>c = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br>*p2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 错误</span><br><br><span class="hljs-comment">/* 1.2.3 int* const 型指针: 指向 可变类型 的 不可变指针</span><br><span class="hljs-comment">即: 指针指向的位置不能修改, 指针指向的位置的值可以修改 */</span><br><span class="hljs-comment">/* 类似const修饰的普通变量, 这种指针也必须在声明时立刻初始化 */</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p3 = &amp;c;<br>p3 = &amp;d; <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">/* 和 */</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p4 = &amp;e; <span class="hljs-comment">// 错误, 和int* 类似, int* const指向的必须是可变类型, 不能指向const类型.</span><br><br><span class="hljs-comment">/* 1.2.4 const int* const型指针: 指向 不可变类型 的 不可变指针</span><br><span class="hljs-comment">略, 可以自行推理得到它的使用方式. */</span><br></code></pre></td></tr></table></figure><h2 id="1-3-const-与-引用"><a href="#1-3-const-与-引用" class="headerlink" title="1.3 const 与 引用"></a>1.3 const 与 引用</h2><p>引用是C++有别于C的一个特性. 由于引用本身也很有话题, 这里不做过多介绍, 只是简单的说明一下引用与const的关系.</p><p>可以将引用粗略的理解为指针. 和指针不同在于: </p><ol><li>首先, 它不需要<code>*</code>运算符就能直接取得其所引用的变量的值, 因此引用相当于其所引用的变量的“别名”</li><li>其次, 它必须在声明时初始化, 之后不能再修改其所引用的是哪个变量.</li></ol><p>所以类似指针, 也能画出一个二维表格, 不过, “引用的是哪个变量”这件事, 不论对何种引用而言, 都是不能修改的. 因此这个表格事实上只有一行.</p><table><thead><tr><th>引用的是哪个变量 \ 通过引用访问变量的值</th><th>能变</th><th>不能变</th></tr></thead><tbody><tr><td><del>能变(不存在)</del></td><td><del>不存在</del></td><td><del>不存在</del></td></tr><tr><td>不能变</td><td><code>int&amp;</code></td><td><code>const int&amp;</code></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 1.3.1 普通引用无法引用const修饰过的变量 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> g = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>&amp; h = g <span class="hljs-comment">// 错误</span><br><br><span class="hljs-comment">/* 1.3.3 形如 const int&amp; 的引用 */</span><br><span class="hljs-comment">/* 首先, 它类似const int*, 通过引用访问变量是不能修改变量的值的. */</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; j = i; <span class="hljs-comment">// 正确</span><br>j = <span class="hljs-number">1</span>; <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">/* 其次, 由于引用本身的特性, 它和const int* 不同, 它引用的是哪一个变量, 这件事也不能修改.</span><br><span class="hljs-comment">也没有任何一个语法能让你修改. */</span><br></code></pre></td></tr></table></figure><p><em><strong>需要格外注意的是: <code>const int&amp;</code> 有一个非常特殊的用法: 它可以直接引用一个字面量. 这是指针和无const修饰的引用都没有的特性. 在接下来的内容中, 读者将看到这种类型的重要性.</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; k = <span class="hljs-number">3</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span>&amp; l = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误, 不能将一个字面量赋值给一个普通引用.</span><br></code></pre></td></tr></table></figure><p>这里不得不说明一下: 以下每一行内的几种写法是完全等价的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p;<span class="hljs-type">int</span>* p;<span class="hljs-type">int</span> * p;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p; <span class="hljs-type">const</span> <span class="hljs-type">int</span> *p; <span class="hljs-type">const</span> <span class="hljs-type">int</span> * p;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p; <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p; <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p;<br><span class="hljs-type">int</span>&amp; p; <span class="hljs-type">int</span> &amp;p; <span class="hljs-type">int</span> &amp; p;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; p; <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;p; <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; p;<br></code></pre></td></tr></table></figure><p>简而言之, <code>*</code>, <code>&amp;</code>这样的修饰符, 紧挨着谁都是一样的. 而笔者主要使用第一种写法.</p><h1 id="2-const-与-函数"><a href="#2-const-与-函数" class="headerlink" title="2. const 与 函数"></a>2. const 与 函数</h1><h2 id="2-1-const-与-函数形参"><a href="#2-1-const-与-函数形参" class="headerlink" title="2.1 const 与 函数形参"></a>2.1 const 与 函数形参</h2><p>这部分内容可以直接由上面关于变量的介绍平移而来. 下文推测读者已经基本了解C++函数参数传递的机制.</p><h3 id="2-1-1-普通类型形参"><a href="#2-1-1-普通类型形参" class="headerlink" title="2.1.1 普通类型形参"></a>2.1.1 普通类型形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>&#123;<br><span class="hljs-comment">/* const修饰的效果: 在函数体内,形参a的值无法被更改 */</span><br>a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于参数传递机制,这两个函数都可以接收普通和const修饰的int变量</p><h3 id="2-1-2-指针形参"><a href="#2-1-2-指针形参" class="headerlink" title="2.1.2 指针形参"></a>2.1.2 指针形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span></span>&#123;<br>*a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>a = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* a)</span></span>&#123;<br>*a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误</span><br>a = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun3</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-type">const</span> a)</span></span>&#123;<br>*a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>a = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 错误</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> a)</span></span>&#123;<br>*a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 错误</span><br>a = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这四个函数都可以传入普通变量的地址. 普通变量的地址被拷贝如函数后, 会被自动加上const修饰.</p><p>而只有fun2和fun4可以传入const修饰的变量的地址. </p><p>为什么不能传入fun1和fun3?可以这样理解:</p><blockquote><p>编译器: 这个变量本身是const保护的, 传给函数之后, 这个保护就没有了! 在fun1和fun3中, 是允许通过指针a修改变量的值的, 而这个值本身却是const保护的! 这怎么办, 算了给个error吧.</p></blockquote><p>即: 在传递时, 允许加强const条件, 不允许丢掉const条件(这很直观).</p><p>其中, fun2是格外有用的. 如果你 <em><strong>不想在参数传递时拷贝原有数据的值</strong></em> ,又希望函数 <em><strong>以只读的方式访问某个变量</strong></em> ,fun2是一个好选择. </p><h3 id="2-1-3-引用形参"><a href="#2-1-3-引用形参" class="headerlink" title="2.1.3 引用形参"></a>2.1.3 引用形参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似的, 两个函数都能传入普通变量. 而fun1不能传入带const修饰的变量.</p><p><em><strong>此外,十分重要的: fun2可以传入字面量! 这很特殊</strong></em></p><p>其中, fun2是格外有用的. 如果你 <em><strong>不想在参数传递时拷贝原有数据的值</strong></em> ,又希望函数 <em><strong>以只读的方式访问某个变量</strong></em> , 还希望 <em><strong>函数内部不要出现指针的<code>*</code>和<code>-&gt;</code>操作, 调用函数不要出现取地址<code>&amp;</code>操作</strong></em> , 还希望它 <em><strong>能传入字面量</strong></em> , fun2是一个好选择. </p><h2 id="2-2-const-与-函数返回值"><a href="#2-2-const-与-函数返回值" class="headerlink" title="2.2 const 与 函数返回值"></a>2.2 const 与 函数返回值</h2><p>这在某些场合是有点莫名其妙的命题. 比如这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对函数返回值传递机制稍有了解便能知道, 这个const是完全无用的. </p><p>但在某些情况它会不同, 比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>就有不同了. fun()返回的指针可以修改所指位置的值, 而fun2()返回的指针不能.</p><p>类似的, 对于引用, 有:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>*p = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> *p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>它们也是不同的. 不过这两个函数单看其实有些奇怪. 我们之后会在 <strong>类</strong> 那一部分更深入的探讨它们的区别和各自运用.</p><h2 id="2-3-案例-const-在几种特殊函数中的作用"><a href="#2-3-案例-const-在几种特殊函数中的作用" class="headerlink" title="2.3 案例: const 在几种特殊函数中的作用"></a>2.3 案例: const 在几种特殊函数中的作用</h2><p>在2.1.3, 我提到了: </p><blockquote><p>如果你 <em><strong>不想在参数传递时拷贝原有数据的值</strong></em> ,又希望函数 <em><strong>以只读的方式访问某个变量</strong></em> , 还希望 <em><strong>函数内部不要出现指针的<code>*</code>和<code>-&gt;</code>操作, 调用函数不要出现取地址<code>&amp;</code>操作</strong></em> , 还希望它 <em><strong>能传入字面量</strong></em> , fun2是一个好选择.</p></blockquote><p>这种情况会在什么时候出现呢? 没错, 那就是——</p><p>(函数体外的) <em><strong>运算符重载</strong></em></p><p>运算符重载有两种, 一种是写在函数体(准确的说是结构体或类定义)外,没有打括号包裹的, 另一种是定义在类内部的.</p><p>这里着重举两个例子.</p><p>以这样一个结构体为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Int</span>&#123;<br><span class="hljs-type">int</span> data;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-1-类-或结构体-的比较运算符重载"><a href="#2-3-1-类-或结构体-的比较运算符重载" class="headerlink" title="2.3.1 类(或结构体)的比较运算符重载"></a>2.3.1 类(或结构体)的比较运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Int&amp; a,<span class="hljs-type">const</span> Int&amp; b)&#123;<br><span class="hljs-keyword">return</span> a.data &lt; b.data;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是比较规范的运算符重载写法. 注意这里的<code>const Int&amp;</code>, 需要const修饰.</p><p>如果不加const,只保留&amp;,那么这个运算符将不能处理右值(可以理解为常量和字面量);</p><p>如果不加const,也不保留&amp;,那么调用运算符会进行值的拷贝, 这在Int是一个复杂的数据类型时, 会凭空增加内存消耗, 也很耗时.</p><h3 id="2-3-2-输入输出重载"><a href="#2-3-2-输入输出重载" class="headerlink" title="2.3.2 输入输出重载"></a>2.3.2 输入输出重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="hljs-type">const</span> Int&amp; a)&#123;<br>out &lt;&lt; a.data;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br>std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; in,Int&amp; a)&#123;<br>in &gt;&gt; a.data;<br><span class="hljs-keyword">return</span> in;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是比较规范的输入输出流重载写法. 注意在输出时需要加const修饰(否则无法输出字面量), 而输入时不能加const修饰(否则无法修改). 这里也能看出引用<code>&amp;</code>符的巨大作用.</p><h1 id="3-const-与-类"><a href="#3-const-与-类" class="headerlink" title="3. const 与 类"></a>3. const 与 类</h1><h2 id="3-1-const-与-类的属性"><a href="#3-1-const-与-类的属性" class="headerlink" title="3.1 const 与 类的属性"></a>3.1 const 与 类的属性</h2><p>基本和变量完全一致.</p><h2 id="3-2-const-与-类的方法"><a href="#3-2-const-与-类的方法" class="headerlink" title="3.2 const 与 类的方法"></a>3.2 const 与 类的方法</h2><p>比如这样一个类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>方法和函数在很多方面是类似的. 它也有参数的const, 和返回值的const. 这里着重介绍另一种: <strong>方法的const.</strong></p><h3 id="3-2-1-方法的const"><a href="#3-2-1-方法的const" class="headerlink" title="3.2.1 方法的const"></a>3.2.1 方法的const</h3><p>为什么需要方法const? 因为对象可能被const修饰了.</p><p>比如, 假设string有一个方法size:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(str);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于一个普通string对象, 我们可以执行size(). </p><p>然而, 对于一个 <strong>加了const修饰的string对象</strong> , 还能执行size()吗? 对于一个const修饰的对象, 其中的所有属性都自动增加了const修饰. 然而, <em>系统不知道这个size()方法会不会修改这些被加了const修饰属性</em>. 因此, 对于const string对象, 系统不会允许执行这个size()方法, 会报错.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br>s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> string s2;<br>s2.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">/* 报错信息: &#x27;this&#x27; argument to member function &#x27;size&#x27; has type &#x27; const string&#x27;</span><br><span class="hljs-comment">but function is not marked const  */</span><br></code></pre></td></tr></table></figure><p>然而, 事实上这个size()方法并不会修改对象的属性. 我们的确想让const string对象也能执行size()方法. 因此, <strong>我们要给size()对象增加const修饰</strong>, 就像这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123; <span class="hljs-comment">//注意这里的const!</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(str);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样, 对于const string对象, 也可以正常执行size()方法了.</p><p><em><strong>这里, const修饰就是告诉编译器: 这个方法内的所有代码都不会修改当前类的属性值.</strong></em></p><p>const修饰的方法有以下几个特性:</p><ol><li>const修饰的对象只能执行const修饰的方法</li><li>const修饰的方法内部只能执行别的同样被const修饰的方法</li><li>没有const修饰的对象可以执行const修饰的方法</li><li>允许存在一个无const修饰一个有const修饰的两个同名方法. 程序会自动根据对象有没有const选择执行哪一个.</li></ol><p><em><strong>Remark: 关于特性4, 有以下的例子:</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">array</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span>* data;<br><span class="hljs-built_in">array</span>()&#123;data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">20</span>];&#125;<br>~<span class="hljs-built_in">array</span>()&#123;<span class="hljs-keyword">delete</span> [] data;&#125;<br><span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> index)&#123;<span class="hljs-keyword">return</span> data[index];&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> index)<span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> data[index];&#125;<br>&#125;;<br>array a1;<br>a1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> array a2;<br>a2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 错误, 调用第二个方法, 返回const int&amp;不能被修改.</span><br></code></pre></td></tr></table></figure><p><em><strong>Remark2: const保护并不代表万无一失. 对上面的例子稍作修改:</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">array</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span>* data;<br><span class="hljs-built_in">array</span>()&#123;data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">20</span>];&#125;<br>~<span class="hljs-built_in">array</span>()&#123;<span class="hljs-keyword">delete</span> [] data;&#125;<br><span class="hljs-comment">//我们直接给它加上const呢?</span><br><span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> index)<span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> data[index];&#125; <br>&#125;;<br>array a1;<br>a1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> array a2;<br>a2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p><em><strong>程序会完全正确的运行.</strong></em> 因为, const只保护了data指针, 没有保护data指向的那片空间. 因此, 它是允许你修改诸如 <code>data[0]</code> 的内容的. 但是, 这并不符合我们的预期. 我们给一个array增加const修饰, 当然是想让里面的值不被修改.</p><p>因此, 如果你想确保const修饰过的类按你的预期不被修改, 你需要 <em><strong>自觉做到</strong></em> 在const修饰过的方法中不去修改相关的值. 没人能帮你检查.</p><p>这个const修饰还有一个常见的应用: 类内部的运算符重载(尤其是<code>==</code>的重载). 请看:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span>* p;<br><span class="hljs-built_in">test</span>()&#123;p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;&#125;<br>~<span class="hljs-built_in">test</span>()&#123;<span class="hljs-keyword">delete</span> p;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<br>*p = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> test&amp; b)&#123; <span class="hljs-comment">// 不够好</span><br><span class="hljs-keyword">return</span> *p == *b.p;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> test&amp; b)<span class="hljs-type">const</span>&#123; <span class="hljs-comment">//正确的写法</span><br><span class="hljs-keyword">return</span> *p == *b.p;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>test t,t2;<br><span class="hljs-keyword">if</span>(t==t2)&#123; <span class="hljs-comment">// 如果用第一种写法,这里会报warning</span><br><span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会报一个warning:</p><blockquote><p>ISO C++20 considers use of overloaded operator ‘&#x3D;&#x3D;’ (with operand types test’ and ‘test’） to be ambiguous despitethere being a unique best viable function.</p></blockquote><p>这是为什么呢? 我的理解是, 相等运算<code>==</code>左右两边应当是对等的. 而这个重载的<code>==</code>运算, 由于没有加const修饰, 左右两边变得不对等了. 由于参数加了const, 而方法没有加const, 这意味着进行运算时, 有一方的属性可能被修改, 而另一方的属性标记了不会被修改. 这是不对等的.</p><p>这只是我的粗浅理解. 总之, 给这个方法增加const修饰, 这个warning就消失了.</p><p>以上是我目前能想到的全部内容.</p>]]></content>
    
    
    <summary type="html">const修饰符, 顾名思义是修饰某个东西为“常量”,不允许修改. 在C++中, 有很多地方需要用到const修饰符. 它不仅是一个良好的书写习惯, 在某些情况下, 它甚至是必要的. 这篇文章试图涵盖C++中所有const的出现情况, 以帮助初学者理解.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数算示例程序</title>
    <link href="https://justaloli.cn/posts/39276.html"/>
    <id>https://justaloli.cn/posts/39276.html</id>
    <published>2023-04-25T09:35:44.000Z</published>
    <updated>2023-04-25T09:52:41.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="顺序字典的二分查找"><a href="#顺序字典的二分查找" class="headerlink" title="顺序字典的二分查找"></a>顺序字典的二分查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinSearch</span><span class="hljs-params">(SeqDictionary *pdic, KeyType key, <span class="hljs-type">int</span> *pos)</span>&#123;<br><span class="hljs-type">int</span> low,mid,high;<br>low = <span class="hljs-number">0</span>; high = pdic-&gt;n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(low &lt;= high)&#123; <span class="hljs-comment">//注意这里的判断</span><br>mid = (low + high) / <span class="hljs-number">2</span>; <span class="hljs-comment">//注意中间位置</span><br><span class="hljs-keyword">if</span>(key &lt; pdic-&gt;elem[mid].key)&#123;<br>high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//注意边界变化</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; pdic-&gt;elem[mid].key)&#123;<br>low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意边界变化</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>*pos = mid;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>*pos = low; <span class="hljs-comment">//它“应该在”的位置,用于后续插入</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树二叉链表结构定义"><a href="#二叉树二叉链表结构定义" class="headerlink" title="二叉树二叉链表结构定义"></a>二叉树二叉链表结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinTreeNode</span></span><br><span class="hljs-class">&#123;</span><br>DataType info;                        <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinTreeNode</span> *<span class="hljs-title">llink</span>;</span>      <span class="hljs-comment">//指向左孩子</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinTreeNode</span> *<span class="hljs-title">rlink</span>;</span>     <span class="hljs-comment">//指向右孩子</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinTreeNode</span> *<span class="hljs-title">PBinTreeNode</span>;</span><br></code></pre></td></tr></table></figure><h3 id="前根遍历二叉树非递归算法"><a href="#前根遍历二叉树非递归算法" class="headerlink" title="前根遍历二叉树非递归算法"></a>前根遍历二叉树非递归算法</h3><h3 id="从根开始，沿左子树一直走到末端为止，在走的过程中访问所遇结点，并依次将所遇结点的非空右孩子进栈。当左子树结点全处理完后，从栈顶退出某结点的右孩子，此时该结点的左子树已经遍历完，再按照上述过程遍历结点的右子树，如此重复直到栈空为止。"><a href="#从根开始，沿左子树一直走到末端为止，在走的过程中访问所遇结点，并依次将所遇结点的非空右孩子进栈。当左子树结点全处理完后，从栈顶退出某结点的右孩子，此时该结点的左子树已经遍历完，再按照上述过程遍历结点的右子树，如此重复直到栈空为止。" class="headerlink" title="从根开始，沿左子树一直走到末端为止，在走的过程中访问所遇结点，并依次将所遇结点的非空右孩子进栈。当左子树结点全处理完后，从栈顶退出某结点的右孩子，此时该结点的左子树已经遍历完，再按照上述过程遍历结点的右子树，如此重复直到栈空为止。"></a>从根开始，沿左子树一直走到末端为止，在走的过程中访问所遇结点，并依次将所遇结点的非空右孩子进栈。当左子树结点全处理完后，从栈顶退出某结点的右孩子，此时该结点的左子树已经遍历完，再按照上述过程遍历结点的右子树，如此重复直到栈空为止。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(PBinTreeNode t)</span><br>&#123;<br><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;                                 <span class="hljs-comment">//栈顶指示器</span><br>PBinTreeNode p, S[M];             <span class="hljs-comment">//栈中存放各个右子树根结点</span><br><br>p = t;<br><span class="hljs-keyword">do</span><br>&#123;    <br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>visit(p-&gt;info);                        <span class="hljs-comment">//访问根结点</span><br><span class="hljs-keyword">if</span> (p-&gt;rlink != <span class="hljs-literal">NULL</span>)       <br>&#123;    S[top++] = p-&gt;rlink;    &#125;  <span class="hljs-comment">//右子树根结点进栈</span><br>p = p-&gt;llink;                          <span class="hljs-comment">//继续搜索p的左子树 </span><br>&#125;<br><span class="hljs-keyword">if</span> (top &gt;= <span class="hljs-number">0</span>)    p = S[--top];          <span class="hljs-comment">//右子树根结点出栈，转到搜索右子树</span><br>&#125; <span class="hljs-keyword">while</span> (top &gt;= <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中根遍历二叉树非递归算法"><a href="#中根遍历二叉树非递归算法" class="headerlink" title="中根遍历二叉树非递归算法"></a>中根遍历二叉树非递归算法</h3><p>与先根遍历基本类同，只是在沿左分支（左子树）向前搜索过程中将遇到的结点进栈，待遍历完左子树后，从栈顶退出结点并访问，然后再遍历右子树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrder</span><span class="hljs-params">(PBinTreeNode t)</span><br>&#123;   <br><span class="hljs-type">int</span> top=<span class="hljs-number">0</span>;                            <span class="hljs-comment">//栈顶指示器</span><br>PBinTreeNode p, S[M];      <span class="hljs-comment">//控制栈</span><br>p = t;<br><span class="hljs-keyword">do</span><br>&#123;    <br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>S[top++] = p;         <span class="hljs-comment">//所遇结点p进栈</span><br>p = p-&gt;llink;           <span class="hljs-comment">//继续搜索p的左子树</span><br>&#125;<br><span class="hljs-keyword">if</span> ( top &gt;= <span class="hljs-number">0</span>)<br>&#123;    <br>p = S[--top];          <span class="hljs-comment">//出栈，栈顶结点赋p</span><br>visit(p-&gt;info);       <span class="hljs-comment">//访问根结点</span><br>p = p-&gt;rlink;         <span class="hljs-comment">//继续搜索右子树 </span><br>&#125;<br>&#125; <span class="hljs-keyword">while</span> ( top &gt;= <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后根遍历二叉树非递归算法"><a href="#后根遍历二叉树非递归算法" class="headerlink" title="后根遍历二叉树非递归算法"></a>后根遍历二叉树非递归算法</h3><p>使用栈实现后根遍历要比先、中根遍历复杂。在后根遍历中，当搜索指针指向某个根结点时，不能马上进行访问，而先要遍历左子树，所以要求根结点进栈保存。当遍历完左子树后，再次搜索到该结点时，还不能进行访问，还要遍历其右子树。所以，需要再次将该结点进栈保存。为了区别同一结点的两次入栈，需要一个特别的标志：1表示该结点首次进栈[遍历左子树前入栈]，2表示第二次进栈[遍历右子树前入栈]。设立两个栈，一个栈s1[M]用于存放结点，一个s2[M]栈用于存放结点进栈标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrder</span><span class="hljs-params">( PBinTreeNode t)</span><br>&#123;   <span class="hljs-type">int</span> S2[M], top = <span class="hljs-number">0</span>, b;            <span class="hljs-comment">//结点进栈标志栈</span><br>PBinTreeNode p, S1[M];        <span class="hljs-comment">//结点栈</span><br>　<br>p = t;<br><span class="hljs-keyword">do</span><br>&#123;    <br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>S1[top] = p;<br>S2[top++] = <span class="hljs-number">1</span>;            <span class="hljs-comment">//p结点首次入栈</span><br>p = p-&gt;llink;<br>&#125;                                     <span class="hljs-comment">//遍历左子树</span><br><span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>)<br>&#123;  <br>   b = S2[--top];<br> p =S1[top];<br> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)<br> &#123;  <br>S1[top] = p;<br>  S2[top++] = <span class="hljs-number">2</span>;        <span class="hljs-comment">//p结点第二次入栈</span><br>  p = p-&gt;rlink;<br> &#125;                                 <span class="hljs-comment">//遍历p的右子树</span><br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>)<br> &#123;   <br>visit(p-&gt;info);       <span class="hljs-comment">//访问根结点</span><br>  p = <span class="hljs-literal">NULL</span>;<br> &#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>数算关键概念精简版</title>
    <link href="https://justaloli.cn/posts/51676.html"/>
    <id>https://justaloli.cn/posts/51676.html</id>
    <published>2023-04-25T09:09:48.000Z</published>
    <updated>2023-04-25T09:23:55.982Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ADT: …</p><p>数据结构: 逻辑结构、存储结构、操作</p><p>逻辑结构: …</p><p>存储结构: …</p><p>算法分类: …</p><p><em><strong>朴素的字符串匹配</strong></em></p><p><em><strong>KMP模式匹配</strong></em></p><p>FIFO、FILO: …</p><p>环形队列</p><p><em><strong>树</strong></em></p><p>树的运算</p><p><em><strong>树的遍历</strong></em></p><p><em><strong>二叉树,k叉树的多个性质!!</strong></em></p><p>二叉树的运算</p><p>二叉树的遍历</p><p>集合(bitset): 创建、插入、删除、属于、合并、交、差</p><p>字典</p>]]></content>
    
    
    <summary type="html">呕</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>C++实现一个尽可能优雅的双向链表</title>
    <link href="https://justaloli.cn/posts/46200.html"/>
    <id>https://justaloli.cn/posts/46200.html</id>
    <published>2023-04-25T04:58:55.000Z</published>
    <updated>2023-04-25T06:48:30.612Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是「数据结构与算法」课程的一部分. 在这门课中, 我们将接触各种常见的数据结构, 并了解它们各种基本操作的实现方式.</p><p>这门课的第一章为顺序表, 其中包括一种数据结构“链表”. 我产生了一种想法, 为什么不借助C++强大的类封装能力, 实现一个自己的链表呢?</p><p>我的目标是想让这个链表尽可能的“优雅”. 这要求在使用这个链表时, 各种操作应尽可能的简洁直观. 我的目标是做的比C++ STL模版库的链表易用(虽然性能可能略低), 并且尽可能靠近python的列表.</p><blockquote><p>注意: STL模版库的list是双向链表,但python的list, 据资料, 是基于变长顺序表. 这里说的靠近不是利用python list的底层逻辑, 而是实现和python list尽可能相似的调用方式.</p></blockquote><h2 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h2><p>话不多说, 先看使用例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 本程序需要引用的外部库仅iostream */</span><br><br><span class="hljs-comment">/* 例子1 简单的添加数据、打印数据 */</span><br>list&lt;<span class="hljs-type">int</span>&gt; list1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>list1.<span class="hljs-built_in">append</span>(i);<br>&#125;<br>cout &lt;&lt; list1 &lt;&lt; endl;<br><br><span class="hljs-comment">/* 例子2 列表嵌套 */</span><br>list&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; list2;<br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt; templist;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j,++num)<br>&#123;<br>templist.<span class="hljs-built_in">append</span>(num);<br>&#125;<br>list2.<span class="hljs-built_in">append</span>(templist);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; list2[i].<span class="hljs-built_in">size</span>(); ++j)<br>&#123;<br>cout &lt;&lt; list2[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>1 <br>2 3 <br>4 5 6 <br>7 8 9 10 <br>11 12 13 14 15 <br>16 17 18 19 20 21 <br>22 23 24 25 26 27 28 <br>29 30 31 32 33 34 35 36 <br>37 38 39 40 41 42 43 44 45 <br>46 47 48 49 50 51 52 53 54 55 <br>程序执行完成, 用时63微秒.<br></code></pre></td></tr></table></figure><p>使用过python的人, 应该能看出我对python列表的借鉴(比如append()); 使用过C++ STL模版库的list的人, 应该能看出它比STL list在使用(尤其是遍历)上要简单一些.</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>列表的UML类图如下:</p><pre><code class=" mermaid">classDiagram class node&#123;+T data+node* next+node* prev&#125;class list&#123;-node* head-node* tail-int _size-node* temp-int tempindex+copy() list+slice(i1,i2,i3) list+size() int+append(data) int+insert(index,data) void+swap(i1,i2) void+pop(i=-1) T+remove(data) void+clear() void+operator[](index) T+operator=(data) list+operator+(data) list+operator+=(data) list#get(index) node*#swap(node,node) void&#125;</code></pre><p>在完善这个数据类型的过程中, 遇到了很多有趣的问题, 也学习到了很多C++语法特性, 比如模版类、析构函数、运算符重载、引用符<code>&amp;</code>等等. 之后也许会慢慢整理遇到的各种问题以及经验.</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>这里只是放上完整代码. 之后有机会新建帖子进行相关的解释.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYLIST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYLIST</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> my &#123;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(args) printf(args);</span><br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">node</span>()&#123;&#125;<br><span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> T&amp; dta)&#123;data = dta;&#125;<br>T data;<br>node* next=<span class="hljs-literal">nullptr</span>;<br>node* prev=<span class="hljs-literal">nullptr</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator_base</span>&#123;<br><span class="hljs-keyword">protected</span>:<br>node* ptr;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">iterator_base</span>(node* p):<span class="hljs-built_in">ptr</span>(p)&#123;&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator_base&amp; it)<span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> ptr!=it.ptr;&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++()&#123;ptr=ptr-&gt;next;&#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)&#123;ptr=ptr-&gt;next;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span>:<span class="hljs-keyword">public</span> iterator_base&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> iterator_base::iterator_base,iterator_base::ptr;<br>T&amp; <span class="hljs-keyword">operator</span>*()&#123;<span class="hljs-keyword">return</span> ptr-&gt;data;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_iterator</span>:<span class="hljs-keyword">public</span> iterator_base&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> iterator_base::iterator_base,iterator_base::ptr;<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*()&#123;<span class="hljs-keyword">return</span> ptr-&gt;data;&#125;<br>&#125;;<br>node* head;<br>node* tail;<br><span class="hljs-type">int</span> _size;<br>node* temp;<br><span class="hljs-type">int</span> tempindex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(head-&gt;next);&#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(tail);&#125;<br><span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">const_iterator</span>(head-&gt;next);&#125;<br><span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">const_iterator</span>(tail);&#125;<br><br><br><br><span class="hljs-built_in">list</span>();<span class="hljs-comment">/* 构造函数 */</span><br><br><span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 拷贝重载，</span><br><span class="hljs-comment">做了一些区分：用这个重载是做一个影子链表，用等号重载是做一个完整地拷贝。 */</span><br><span class="hljs-comment">/* 如此，在初始化和函数传递时默认时 */</span><br><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">/* 析构函数 */</span><br><br><span class="hljs-function">list&lt;T&gt; <span class="hljs-title">copy</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/* 复制 */</span><br><br><span class="hljs-function">list&lt;T&gt; <span class="hljs-title">slice</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>)</span><span class="hljs-type">const</span></span>;<span class="hljs-comment">/* 切片 */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> _size;&#125;<span class="hljs-comment">/* 得到长度 */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>;<span class="hljs-comment">/* 追加 */</span><br><br><span class="hljs-function">list&lt;T&gt;&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> T&amp;)</span></span>;<span class="hljs-comment">/* 插入 */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">/* 交换 */</span><br><br><span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i=<span class="hljs-number">-1</span>)</span></span>;<span class="hljs-comment">/* 弹出并删除 */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>;<span class="hljs-comment">/* 删除所有和参数相同的元素 */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/* 清空 */</span><br><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span>);<span class="hljs-comment">/* 索引[]运算 */</span><br><br>list&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 赋值=运算 */</span><br><br>list&lt;T&gt; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> list&lt;T&gt;&amp;);<span class="hljs-comment">/* 加+运算 */</span><br><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(list&lt;T&gt;&amp;);<span class="hljs-comment">/* 自增+=运算 */</span><br><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> T&amp;);<span class="hljs-comment">/* 自增+=运算 */</span><br><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function">node* <span class="hljs-title">gethead</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> head;&#125;<br><span class="hljs-function">node* <span class="hljs-title">gettail</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> tail;&#125;<br><span class="hljs-function">node* <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<span class="hljs-comment">/* 索引，得到节点指针 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(node*,node*)</span></span>;<span class="hljs-comment">/* 交换 */</span><br><span class="hljs-function">node* <span class="hljs-title">getFromHead</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">node* <span class="hljs-title">getFromTail</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">node* <span class="hljs-title">getFromTemp</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resetTemp</span><span class="hljs-params">()</span></span>&#123;temp=head;tempindex = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 重置temp指针保证它指向链中的某个项。 */</span><br><span class="hljs-comment">/* fun fact：虽然重置tempindex=0，但是现在temp指向head而不是第一个“元素”。</span><br><span class="hljs-comment">但这无伤大雅。由于距离的最小值判定的逻辑，查找时会优先从head向后查找，而不是用temp查找。 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;=b?a-b:b-a;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out,<span class="hljs-type">const</span> list&lt;T&gt;&amp; L)&#123;<br><span class="hljs-comment">/* 运算符：重载cout输出 */</span><br>out &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:L)&#123;<br><span class="hljs-keyword">if</span>(flag)&#123;<br>out &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>flag = <span class="hljs-literal">true</span>;<br>&#125;<br>out &lt;&lt; i;<br>&#125;<br>out &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T&amp; list&lt;T&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)&#123;<br><span class="hljs-comment">/* 运算符：索引 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(i)-&gt;data;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;&amp; list&lt;T&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> list&lt;T&gt; &amp;li)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;li)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><span class="hljs-comment">/* 运算符：赋值 */</span><br><span class="hljs-built_in">clear</span>();<br>node* t = li.head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=li.tail)&#123;<br><span class="hljs-built_in">append</span>(t-&gt;data);<br>t = t-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt; list&lt;T&gt;::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> list&lt;T&gt;&amp; li)&#123;<br><span class="hljs-keyword">auto</span> rl = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">copy</span>();<br><br>node* t = li.head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=li.tail)&#123;<br>rl.<span class="hljs-built_in">append</span>(t-&gt;data);<br>t = t-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> rl;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-keyword">operator</span>+=(list&lt;T&gt;&amp; li)&#123;<br><span class="hljs-keyword">if</span>(&amp;li == <span class="hljs-keyword">this</span>)&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;ERROR: self += detected. plz use + instead.&quot;</span>;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* O1,但是引用的li会清空 */</span><br><span class="hljs-comment">/* 把中间接上 */</span><br>tail-&gt;prev-&gt;next = li.head-&gt;next;<br>li.head-&gt;next-&gt;prev = tail-&gt;prev;<br><span class="hljs-comment">/* 把结尾接上 */</span><br>tail-&gt;prev = li.tail-&gt;prev;<br>tail-&gt;prev-&gt;next = tail;<br><span class="hljs-comment">/* 更新size */</span><br>_size+=li.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">/* 让li首尾相接置空,但是不删除里面的元素(里面的元素归this了.) */</span><br>li.head-&gt;next = li.tail;<br>li.tail-&gt;prev = li.head;<br>li._size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> T&amp; dta)&#123;<br><span class="hljs-built_in">append</span>(dta);<br>&#125;<br><span class="hljs-comment">// list&lt;T&gt; list&lt;T&gt;::operator()(const int,const int,con s)&#123;&#125;</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt; list&lt;T&gt;::<span class="hljs-built_in">copy</span>()&#123;<br>list&lt;T&gt; returnlist;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _size; ++i)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br><span class="hljs-keyword">return</span> returnlist;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt; list&lt;T&gt;::<span class="hljs-built_in">slice</span>(<span class="hljs-type">int</span> p1, <span class="hljs-type">int</span> p2, <span class="hljs-type">int</span> p3) <span class="hljs-type">const</span>&#123;<br>list&lt;T&gt; returnlist;<br><span class="hljs-keyword">if</span>(p3&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p1; i &lt; p2; i+=p3)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p3&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p1; i &gt; p2; i+=p3)<br>&#123;<br>returnlist.<span class="hljs-built_in">append</span>((*<span class="hljs-keyword">this</span>)[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> returnlist;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;list() called&quot;&lt;&lt;endl;</span><br>head = <span class="hljs-keyword">new</span> node;<br>tail = <span class="hljs-keyword">new</span> node;<br><br><span class="hljs-built_in">resetTemp</span>();<br><br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list&lt;T&gt;&amp; li):<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-keyword">operator</span>=(li);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br>node *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br><span class="hljs-built_in">resetTemp</span>();<br>_size=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;~list called for:&quot;&lt;&lt;*this&lt;&lt;endl;</span><br><span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;temp = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> list&lt;T&gt;::<span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> T&amp; dta)&#123;<br>temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(dta);<br>tempindex = _size;<br><br>tail-&gt;prev-&gt;next = temp;<br>temp-&gt;prev = tail-&gt;prev;<br>temp-&gt;next = tail;<br>tail-&gt;prev = temp;<br>_size++;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> list&lt;T&gt;::node* list&lt;T&gt;::<span class="hljs-built_in">get</span>(<span class="hljs-type">int</span> i)&#123;<br><span class="hljs-keyword">if</span>(i&gt;=_size||i&lt;-_size)&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;index out range&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//这是个无效值</span><br>&#125;<br><span class="hljs-type">int</span> mindis = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-type">int</span> minway = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i,<span class="hljs-number">0</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, <span class="hljs-number">0</span>);minway = <span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, -_size)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, -_size);minway = <span class="hljs-number">2</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, _size<span class="hljs-number">-1</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, _size<span class="hljs-number">-1</span>);minway = <span class="hljs-number">3</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i, <span class="hljs-number">-1</span>)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i, <span class="hljs-number">-1</span>);minway = <span class="hljs-number">4</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i,tempindex)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i,tempindex);minway = <span class="hljs-number">5</span>;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(i+_size,tempindex)&lt;mindis)<br>&#123;mindis = <span class="hljs-built_in">dis</span>(i,tempindex);minway = <span class="hljs-number">6</span>;&#125;<br><span class="hljs-keyword">switch</span> (minway) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromHead</span>(i);<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromHead</span>(i+_size);<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTail</span>(i-_size);<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTail</span>(i);<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTemp</span>(i);<br><span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">getFromTemp</span>(i+_size);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> list&lt;T&gt;::node* list&lt;T&gt;::<span class="hljs-built_in">getFromHead</span>(<span class="hljs-type">int</span> targeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFH called\n&quot;);</span><br>temp = head-&gt;next;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i!=targeti)&#123;<br>temp = temp-&gt;next;<br>i++;<br>&#125;<br>tempindex = targeti;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> list&lt;T&gt;::node* list&lt;T&gt;::<span class="hljs-built_in">getFromTail</span>(<span class="hljs-type">int</span> negativeTargeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFT called\n&quot;);</span><br>temp = tail-&gt;prev;<br><span class="hljs-type">int</span> i=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i!=negativeTargeti)&#123;<br>temp = temp-&gt;prev;<br>i--;<br>&#125;<br>tempindex = negativeTargeti+_size;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> list&lt;T&gt;::node* list&lt;T&gt;::<span class="hljs-built_in">getFromTemp</span>(<span class="hljs-type">int</span> targeti)&#123;<br><span class="hljs-comment">// LOG(&quot;GFTMP called\n&quot;);</span><br><span class="hljs-keyword">while</span>(targeti&gt;tempindex)<br>&#123;<br>temp = temp-&gt;next;<br>tempindex++;<br>&#125;<br><span class="hljs-keyword">while</span>(targeti&lt;tempindex)&#123;<br>temp = temp-&gt;prev;<br>tempindex--;<br>&#125;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">swap</span>(<span class="hljs-type">int</span> ia,<span class="hljs-type">int</span> ib)&#123;<br>node* a = <span class="hljs-built_in">get</span>(ia);<br>node* b = <span class="hljs-built_in">get</span>(ib);<br><span class="hljs-built_in">swap</span>(a,b);<br>tempindex = ia;<span class="hljs-comment">//temp指向b,b的下标变为了ia.</span><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">swap</span>(node *a,node *b)&#123;<br>node *anext = a-&gt;next;<br>node *bnext = b-&gt;next;<br>node *aprev = a-&gt;prev;<br>node *bprev = b-&gt;prev;<br><span class="hljs-keyword">if</span>(a-&gt;next==b)&#123;<br>b-&gt;prev = aprev;<br>a-&gt;next = bnext;<br>b-&gt;next = a;<br>a-&gt;prev = b;<br>bnext-&gt;prev = a;<br>aprev-&gt;next = b;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a-&gt;prev==b)&#123;<br>b-&gt;next = anext;<br>a-&gt;prev = bprev;<br>a-&gt;next = b;<br>b-&gt;prev = a;<br>anext-&gt;prev = b;<br>bprev-&gt;next = a;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>a-&gt;next = bnext;<br>b-&gt;next = anext;<br>a-&gt;prev = bprev;<br>b-&gt;prev = aprev;<br>anext-&gt;prev = b;<br>aprev-&gt;next = b;<br>bnext-&gt;prev = a;<br>bprev-&gt;next = a;<br>&#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;&amp; list&lt;T&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> T&amp; value)&#123;<br>node *t;<br><span class="hljs-keyword">if</span>(i&gt;=_size)&#123;<br><span class="hljs-comment">//如果用户做了这样的输入，多半是想插入到末尾，而不是在最后一个位置的前面插入。故直接调用append</span><br><span class="hljs-built_in">append</span>(value);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(i&lt;-_size)&#123;<br>i = <span class="hljs-number">0</span>;<br>&#125;<br>t = <span class="hljs-built_in">get</span>(i);<br><span class="hljs-keyword">if</span>(!t)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(value);<br>t-&gt;prev-&gt;next = temp;<br>temp-&gt;prev = t-&gt;prev;<br>temp-&gt;next = t;<br>t-&gt;prev = temp;<br>_size++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T list&lt;T&gt;::<span class="hljs-built_in">pop</span>(<span class="hljs-type">int</span> i)&#123;<br>node *t = <span class="hljs-built_in">get</span>(i);<br>t-&gt;prev-&gt;next = t-&gt;next;<br>t-&gt;next-&gt;prev = t-&gt;prev;<br><br>T dta = t-&gt;data;<br><br>temp = t-&gt;next;<span class="hljs-comment">//删除元素时，要把那个指向链表中间的temp指针指到一个在链上的节点。</span><br>_size--;<br><span class="hljs-keyword">delete</span> t;<br><span class="hljs-keyword">return</span> dta;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> T&amp; target)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _size;)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(i)-&gt;data==target)&#123;<br><span class="hljs-built_in">pop</span>(i);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>i++;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在c++实现一个(尽可能)像python一样优雅的列表. 并总结一些在进行类封装时遇到的坑和知识点.</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第九讲 超分辨率</title>
    <link href="https://justaloli.cn/posts/33559.html"/>
    <id>https://justaloli.cn/posts/33559.html</id>
    <published>2023-04-25T04:58:55.000Z</published>
    <updated>2023-04-25T06:50:32.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>更清晰、更远的变焦!</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>传感器的分辨率是有限的.</p><p>意义:</p><ul><li>提升视觉质量!</li><li>方便下游操作、识别</li></ul><p><a href="https://github.com/bloc97/Anime4K/releases">https://github.com/bloc97/Anime4K/releases</a></p><p><a href="https://jpghd.com/">https://jpgHD.com</a></p><h2 id="基于子像素位移的多帧方法-传统方法-这是基于信号于系统原理的求解方法"><a href="#基于子像素位移的多帧方法-传统方法-这是基于信号于系统原理的求解方法" class="headerlink" title="基于子像素位移的多帧方法-传统方法(这是基于信号于系统原理的求解方法)"></a>基于子像素位移的多帧方法-传统方法(这是基于信号于系统原理的求解方法)</h2><ul><li>方法动机: 多帧低分辨率图像 -&gt; 子像素的相对关系(位移) -&gt; 恢复高分辨率</li><li>图像退化模型:</li></ul><p>图像退化模型:</p><ul><li>相对运动矩阵: 平移、旋转<ul><li>透视、局部运动</li></ul></li><li>图像模糊矩阵: </li><li>降采样 像素抽取矩阵</li><li>噪声</li></ul><p>超分辨率, 就是反方向计算这些矩阵.</p><p>简化模型: 认为模糊矩阵和降采样矩阵不同图片是相同的.</p><p>做法: 1. ML 最大似然估计 2. 最大后验概率估计</p><p>太复杂了, 我不会</p><h2 id="通过改进传感器构造"><a href="#通过改进传感器构造" class="headerlink" title="通过改进传感器构造"></a>通过改进传感器构造</h2><p>让传感器产生微小抖动(2004)</p><p>规则像素排布的问题: 平移距离为整个像素的时候, 相当于没有平移, 效果不好.</p><p>Penrose像素排布(2011): 不规则的像素排布</p><p>八元组子像素排布(2014): 不规则的像素排布</p><h2 id="单帧超分辨率"><a href="#单帧超分辨率" class="headerlink" title="单帧超分辨率"></a>单帧超分辨率</h2><ol><li>生成一张保留细节的逼真的输出图像</li></ol><p>(双三次上采样)</p><ol start="2"><li>在图像内容上与低分辨率的输入图像保持一致</li></ol><p>非学习?</p><p>例1 基于图片形状的重复(自相似)</p><p>例2 基于梯度锐化变换的方法</p><p>基于学习</p><p>例 SRCNN ECCV 14 首次将深度学习引入超分辨率</p><p>VDSR 更深的网络层数</p><p>ZSSR 自监督</p><p>…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>关键概念:<ul><li>超分辨率、图像退化模型</li></ul></li><li>原理:<ul><li>基于子像素位移的多帧方法重建的原理</li></ul></li><li>一句话总结:<ul><li>相机拍摄真实场景获得图像的过程中部分高频细节信息丢失,通过超分辨率方法能够恢复图像丢失的高频细节</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第八讲 高动态范围成像</title>
    <link href="https://justaloli.cn/posts/21773.html"/>
    <id>https://justaloli.cn/posts/21773.html</id>
    <published>2023-04-18T05:00:23.000Z</published>
    <updated>2023-04-20T07:21:46.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>HDR imaging.</p><ul><li>动态范围</li><li>图像的存储</li><li>多帧合成的动态范围</li></ul><h2 id="动态范围"><a href="#动态范围" class="headerlink" title="动态范围"></a>动态范围</h2><p>场景中最亮和最暗的部分之间的亮度比。</p><p>人眼能适应的动态范围极高，完全覆盖真实世界的常见场景。</p><p>HDR期望能覆盖真实世界的常见场景。</p><p>但还有一个问题：显示器的动态范围很低</p><p>在LDR显示器中，如何呈现真实世界的动态范围？ 「色调映射」</p><h2 id="多帧合成的动态范围"><a href="#多帧合成的动态范围" class="headerlink" title="多帧合成的动态范围"></a>多帧合成的动态范围</h2><p>曝光的“挡”：按幂级数</p><p>选择什么曝光时间？几张？</p><p>其实取决于场景的动态范围；</p><p>一般选取5张，每张曝光时间差两档。</p><p>具体原理（假设已经得到线性的RAW图像）</p><p>回顾：在不欠曝，不过曝的情况下，RAW图像亮度和环境亮度为线性。</p><p>I线性(x,y) &#x3D; min(ti * L(x,y) + noise, 255);</p><p>（最理想的的）对于某个像素而言：</p><ol><li>找到正常曝光的图像（丢掉亮度过低或过高的</li><li>对这些正常的图像，选择合适的权重进行加权平均</li></ol><p>如果只有非线性的图像呢？</p><p>辐射响应曲线利用多张曝光图也能求出来，进而把图像线性化。</p><p>每个图像，每个像素的权重怎么选？</p><p>亮度接近0.5的图像权重最大，亮度接近0或1的图像权重最小。</p><p>引申：绝对辐照度恢复</p><p>HDR图像可以恢复相对辐照度，用其它仪器测出某点的绝对辐照后，能得到绝对辐照度。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>PFM格式：32bit</p><p>RGBE：增加额外的一些数据</p><p>OpenEXR：浮点数</p><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>线性缩放亮度显然是不合理的</p><p>要进行非线性缩放：</p><ul><li>一种方法：</li></ul><ol><li>渐近线1</li><li>接近0的时候，斜率为1</li></ol><ul><li>另一种方法：</li></ul><p>对数线性压缩</p><ul><li>更好的方法！</li></ul><p>色调映射 tone mapping，主要有下面两种</p><p>滤波映射：对低频部分做更多映射；“双边滤波”：分离高低频同时保留边界的锐利</p><p>梯度色调映射：计算梯度，根据梯度进行映射</p><p>双边滤波映射和梯度重建结果已经非常优秀，谁更好取决于个人喜好。</p><p>注：单反相机可以一次拍摄大概三档的动态范围，可以直接对单个RAW图像进行一些色调映射。但它效果显然比多张图要差一些</p><h2 id="HDR的应用"><a href="#HDR的应用" class="headerlink" title="HDR的应用"></a>HDR的应用</h2><p>已经有成熟的应用</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>融合多张图像的HDR方法，有没有什么问题？</p><p>场景必须静态；相机必须静态</p><p>研究方向：1. 抖动的对齐</p><ol start="2"><li><p>单张照片得HDR（应用于HDR视频很有效，需要特殊的相机</p></li><li><p>余数相机</p></li><li><p>卷积由原图猜高光部分</p></li><li><p>卷积由原图生成高光、低光的图组，再由图组合成HDR</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第七讲 光度立体视觉</title>
    <link href="https://justaloli.cn/posts/7606.html"/>
    <id>https://justaloli.cn/posts/7606.html</id>
    <published>2023-04-11T05:00:23.000Z</published>
    <updated>2023-04-11T06:12:03.024Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>计算摄像：通过计算获取普通相机拍摄图像之外的信息</p><p>例如：通过相机获取三维形状</p><p>光度法恢复物体形状：主要通过多张图</p><p>光度方法只能获得物体一面的3d信息（背面看不到），但是，可以获得的很精确。</p><p>回顾：BRDF、电光源、平行光源、朗伯反射</p><p>朗伯反射：</p><p>i 像素值 正比于 光强 x 表面反射率 x 表面法向和光源方向的夹角（写成n点乘l）</p><p><strong>光度立体视觉：假设物体表面反射符合朗伯成像模型，给定多张不同平行光光照下的图片（I），以及光源方向（L），求解每个像素的法线方向（N）。</strong></p><p>对于每个像素点：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i1</span> <span class="hljs-operator">=</span> n · l1<br><span class="hljs-attribute">i2</span> <span class="hljs-operator">=</span> n · l2<br><span class="hljs-attribute">i3</span> <span class="hljs-operator">=</span> n · l3<br>...<br><span class="hljs-attribute">iF</span> <span class="hljs-operator">=</span> n · lF<br></code></pre></td></tr></table></figure><p>可以总结为矩阵 <em><strong>I &#x3D; N * L</strong></em> I是图像数据，N是代求每个位置的法向量，L为每张图片的光源方向。用IL求N。</p><p>至少需要三张光线方向不共面的照片，能得到唯一解。当然多了更好</p><p>I可以从图像（经过光度标定的图）直接得到</p><p>L如何得到？利用镜面球进行光源标定（其实最好的是台球）。（利用球面上的亮点）</p><p>接下来，可以进一步求解表面的漫反射率</p><p>问题：</p><ol><li>朗伯反射物体很难找</li><li>平行光很难找（太阳光是不可以的，因为它的轨迹在短时间内在同一平面（见上面第40行</li><li>要求先进行光度标定</li></ol><p>更多的研究方向：</p><ol><li>减少光源数量</li><li>非标定的光源</li><li>非标定的自然光</li><li>含有噪声的观测</li><li>复杂材质</li><li>复杂环境</li></ol><p>数据集：DiLiGenT</p><p>光度立体的精度在某些极限情况可以逼近乃至超过激光扫描。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数算关键概念一览</title>
    <link href="https://justaloli.cn/posts/11144.html"/>
    <id>https://justaloli.cn/posts/11144.html</id>
    <published>2023-04-10T13:41:45.000Z</published>
    <updated>2023-05-09T12:45:03.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>话不多说，直入正题</p><h1 id="课上说到的重点"><a href="#课上说到的重点" class="headerlink" title="课上说到的重点"></a>课上说到的重点</h1><p>数据结构按逻辑结构和存储结构的分类</p><p>链表的操作细节</p><p>KMP搜索算法</p><p>循环队列空和满的判断</p><p>树的三种深度周游（非递归实现）</p><p>二叉树、K叉树的各种性质!!!</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><ul><li>程序</li></ul><p>是使用程序设计语言精确描述的实现模型，它是问题求解的一个可以在计算机上运行的模型。程序中描述的数据用来表示问题中涉及的对象，程序中描述的过程表示了对于数据的处理算法;通过接受实际问题的输入，经过程序的运行，便可以得到实际问题的一个解。</p><ul><li>数据类型 data type</li></ul><p>通常是指在计算机(语言）中可以使用的一个类型，它不但包括这个类型的值的集合，还包括定义在这个类型上的一组操作。例如，整数作为一个数据类型是指在计算机上所能表示的(不是数学意义上任意大小的）所有整数和语言中定义的对于这些整数的全部操作(整数的加、减、乘、除、取余等）。在不会造成误解的上下文中，本书中提到的许多类型（例如整数类型、实数类型等）多数都指数据类型。</p><ul><li>抽象数据类型 ADT</li></ul><p>可以定义为具有一定行为（操作）的抽象(数学）类型。它不关心类型中值的具体表示方式和数据类型中定义的各种操作的具体实现方法，是所有可能的值的具体表示和各种操作的具体实现的抽象。</p><ul><li>数据结构</li></ul><p>通常，可以把数据结构理解为：计算机中表示(存储）的、具有一定逻辑关系和行为特征的一组数据。</p><p>其中的每个数据元素称为这个结构的一个<em><strong>结点</strong></em>。</p><p>本书把 <em><strong>数据结构</strong></em> 理解为 <em><strong>“抽象数据类型的物理实现”</strong></em> 。</p><ul><li><p>需要注意的是，无论从什么观点出发，算法和数据结构在程序设计中的核心地位和作用并没有任何改变。对于数据结构的不同理解，实际上都离不开以下三个要素：</p><ul><li><em><strong>逻辑结构</strong></em>：它定义了数学模型中的基本元素(结点)和元素之间的相互关系。</li><li><em><strong>存储结构</strong></em>：它给出了数学模型的具体表示方式，包括结点的表示和关系的表示。</li><li><em><strong>操作</strong></em>：它给出抽象数据类型关心的各种行为在存储结构上的具体实现算法。</li></ul></li><li><p>数据结构的分类</p><ul><li>逻辑结构<ul><li>重要概念<ul><li><code>B = &lt;K,R&gt;</code></li><li>R <strong>关系</strong> “二元组的集合”</li><li><code>&lt;k,k&#39;&gt;</code> <em><strong>前驱</strong></em>k，<em><strong>后继</strong></em>k’</li><li><em><strong>开始结点</strong></em>：没有前驱的结点，<em><strong>终端结点</strong></em>：没有后继的结点</li></ul></li><li>集合</li><li>线性结构</li><li>树形结构（老师ppt称层状）</li><li>复杂结构（老师ppt称网状）</li><li>包含关系：<code>集合包含线性结构包含树形结构包含复杂结构</code></li></ul></li><li>存储结构<ul><li>顺序表示：用一个连续的空间顺序存放数据结构中的各个结点。</li><li>链接表示：结点的存放位置是任意的,结点之间的关系通过与结点关联的指针(或者引用）方式显式表达出来。</li><li>散列表示：又称为关键码——地址转换法。即选择适当的散列（杂凑）函数，根据关键码的值将结点映射到给定的存储空间(散列表）中。</li><li>索引表示：索引与散列一样，都给出一种从关键码到存储地址的映射方法。不同的是，散列法的映射是通过函数定义，而索引法是通过建立辅助的索引结构解决。</li></ul></li></ul></li><li><p>结点</p></li></ul><p>组成结构的元素抽象成<em><strong>结点</strong></em>。分成<em><strong>初等类型</strong></em>和<em><strong>组合类型</strong></em></p><ul><li>算法</li></ul><p><em><strong>算法</strong></em>是由有穷规则构成的为解决某一类问题的运算序列(方法或过程）。</p><p>算法可以有若干<em><strong>输入</strong></em>，这些输入是在算法开始时给出的初始值或条件;算法通常又有若干个<em><strong>输出</strong></em>，它们是同输入有某种关系的计算结果。</p><p><em><strong>算法的性质</strong></em>如下：<em><strong>有穷性。</strong></em> 一个算法必须在执行了有穷步之后结束。在某些领域也需要研究不终止的算法，但这不属于本书讨论的范畴。<em><strong>确定性。</strong></em> 算法的每一步必须有确切的定义。也就是说，对于每步需要执行的动作必须严格地和清楚地给出规定。<em><strong>可行性。</strong></em> 算法是可行的，意味着算法中的每个动作，原则上都是能够由机器或人准确完成的。整个算法好像是一个解决问题的“工作序列〞，其中的每一步都是我们力所能及的一个动作。</p><p><em><strong>算法正确性：如果一个算法以一组满足初始条件的输入开始，那么该算法的执行一定会终止,并且在终止时得到满足要求的(输出）结果。</strong></em></p><ul><li>算法的设计</li></ul><p>贪心法</p><p>分治法</p><p>回溯法（深度优先</p><p>动态规划法</p><p>分枝界限法（广度优先</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ul><li>线性表</li></ul><p><em><strong>线性表</strong></em>简称为<em><strong>表</strong></em>，是零个或多个元素（也称表目）的有穷序列。</p><p>K中所含元素的个数称为表的<em><strong>长度</strong></em>,长度为零的表称为<em><strong>空表</strong></em>。</p><ul><li>顺序表</li></ul><p>采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个地存储在一片相邻的存储区域中。这种顺序表示的线性表也称为<strong>顺序表</strong>。</p><ul><li>链表</li></ul><p>每个结点就包括两个域：<em><strong>数据域</strong></em>（info)—存放元素本身的信息；<em><strong>指针域</strong></em>(link）——存放其后继结点的存储位置。由于最后一个元素没有后继，它的指针不指向任何结点，称为空指针。空指针图示中用“^”表示，算法中用“NULL”</p><p>假设一个线性表有n个元素，则这几个元素所对应的几个结点就通过指针链接成一个<em><strong>链表</strong></em>。由于这种链表中每个结点只有一个指针城，故又称为<em><strong>单链表</strong></em>。指向链表中第一个结点的指针称为该链表的<em><strong>头指针</strong></em>。</p><p>有时，为了处理方便，可以在单链表的第一个结点之前另加一个结点，称之为<em><strong>头结点</strong></em>。</p><p><em><strong>循环链表</strong></em>，<em><strong>双链表</strong></em>，<em><strong>循环双链表</strong></em></p><ul><li><p>稀疏矩阵的表示方法</p></li><li><p>三元组表示法，伪地址表示法</p></li><li><p>行-列表示法</p></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul><li>字符串</li></ul><p><em><strong>字符串</strong></em>简称串,是一种特殊的线性表，其特殊性主要在于表中的每个元素是一个字符。</p><ul><li>KMP模式匹配</li></ul><p><em><strong>（书p82）</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">makeNext()&#123;PSeqString p,<span class="hljs-type">int</span> *next&#125;&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">-1</span>;<br>next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt; p-&gt;n<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">while</span>(k&gt;=<span class="hljs-number">0</span> &amp;&amp; p-&gt;c[i]!=p-&gt;c[k])&#123;<br>k = next[k];<br>&#125;<br>i++;k++;<br><span class="hljs-keyword">if</span>(p-&gt;c[i] == p-&gt;c[k])&#123;<br>next[i] = next[k];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>next[i] = k;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进后算法分析算法 3.8 从形式上看是一个二重循环，每重循环最多执行 m次,最大运行时间可能达到0(m^2）。但仔细分析一下可知，因为每执行一次外层循环(第4行),i严格增1(第6行),所以外层循环正好执行m-1 次;另外k 的值从-1 开始（第2行）,执行k +m-1次(第6行),并且只有在这一语句中k 被增值。在内层循环(第5行)中,语句<code>k= next[k]</code>至少使长减少1,所以整个算法中，这个语句的执行次数累计起来不可能超过m-1次(否则k将小于 -1,这是不可能的），所以内层循环总的执行次数最大为m-1。因此算法3.8的执行时间为0(m）。与算法3.6的执行时间合在一起，得到用长度为m的模式串p与长度为n的目标串t进行匹配所需的总计算时间为 O(m +n)。Knuth 等人提出的快速模式匹配算法，当 n≥m时，其优越性是显然的，特别在一个模式被反复使用时，只要花一次0(m）的时间计算 next 数组，以后的每次匹配只要用0(n）的时间;但是，当n与m 接近，并且处理只匹配一次的模式时，朴素的匹配算法所花的时间代价也可能会更为节省。快速匹配的算法意义还在于：算法本身的设计方法具有代表性，它首先建立了next 数组，以此作为匹配过程的工具，从而提高了匹配的速度；另外，算法3.6 和算法3.8 的时间分析方法也是常用的方法之一，希望读者掌握。</p><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><ul><li>栈</li></ul><p><em><strong>栈</strong></em>是一种特殊的线性表，它所有的插入和删除操作都限制在表的同一端进行。表中允许进行插入、删除操作的一端叫做<em><strong>栈顶</strong></em>，另一端则叫做<em><strong>栈底</strong></em>。当栈中没有元素时，称为<em><strong>空栈</strong></em>。</p><p>因此，栈又称为<em><strong>后迸先出</strong></em>(Last in First Out, LIFO)表或<em><strong>下推表</strong></em>。</p><p>由于栈是一种动态结构，而数组是静态结构，因此，当栈中已经有 MAXNUM个元素时，如果再做进栈运算，则会产生溢出，通常称为<em><strong>上溢</strong></em>(overflow）；而对空栈进行出栈运算时也会产生溢出,通常称为<em><strong>下溢</strong></em>(underlow）。为了避免溢出，在对栈进行进栈运算和出栈运算前，应分别检测栈是否已满或是否已空。</p><p><em><strong>中缀表达式的计算，书p100</strong></em></p><ul><li>队列</li></ul><p>队列也是一种特殊的线性表，是一种只允许在表的一端进行插人操作,而在另一端进行删除操作的线性表。允许进行删除的一端称为<em><strong>队头</strong></em>，允许进行插入的一端叫做<em><strong>队尾</strong></em>。当队列中没有任何元素时，称为<em><strong>空队</strong></em>。</p><p>队列的插入操作通常称为<em><strong>入队</strong></em>，队列的删除操作通常称为<em><strong>出队</strong></em>。</p><p>队列同现实生活中等车、买票的排队相仿，新来的成员总是加入到队尾，每次离开队列的总是队头上的，即当前“最老的”成员。因此，队列也称为<em><strong>先进先出</strong></em>(First In First Out, FIFO)表。</p><p>在顺序表示的队列中，同栈一样存在队列溢出问题。即当队列满时，再做入队操作，这种现象称为<em><strong>上溢</strong></em>;而当队空时，做出队操作，这种现象称为<em><strong>下溢</strong></em>。这些现象在运算中都要考虑。</p><p><em><strong>环形队列</strong></em></p><p>为区分空队列与满队列两种情况的环形队列，一般是牺牲队列中的一个结点，当队列中已有 MAXNUM-1 个结点时就称满，再要插入就发生溢出。（p105</p><p>注意形如<code>(k+1)%n</code>的形式</p><p><em><strong>双端队列</strong></em>是一种特殊的线性表，对它所有的插人和删除都限制在表的两瑞进行。它好像一个特别的书架，取书和存书限定在两边进行。</p><p><em><strong>双栈</strong></em>是一种加限制的双端队列，它规定从一端插入的元素只能从同一端删除，它就好像两个底部相连的栈。</p><p><em><strong>超队列</strong></em>是一种输出受限的双端队列，即删除限制在一端进行,而插入仍允许在两端进行。它好像一种特殊的队列,允许有的最新插入的元素最先删除。</p><p><em><strong>超栈</strong></em>是一种输人受限的双端队列，即插入限制在一端进行,而删除仍允许在两端进行。它可以看成对栈溢出时的一种特殊的处理，即当栈溢出时，可将栈中保存最久的元素删除。</p><h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li>运算:</li></ul><p><em><strong>创建一颗空树、判断是否为空树、求根结点、求父结点、求第一个子结点、求右兄弟、遍历树（树的周游）</strong></em></p><ul><li><p>树的存储方式</p></li><li><p>树的遍历（周游</p><ul><li>深度方向</li><li>广度方向</li></ul></li><li><p>深度方向</p><ul><li>先根遍历</li><li>中根遍历</li><li>后根遍历</li></ul></li><li><p>先根遍历</p></li></ul><p>任何结点，先根遍历完后：如有右兄弟，进入右兄弟；否则，进入上一层（父结点）的右兄弟。</p><ul><li>中根遍历</li></ul><p>任何结点，中根遍历完（长子子树也已经遍历完）后：</p><p>1)如有第2颗子树，进入。2）否则（也无其它子树），父结点第2颗和2后的子树，进入前需要保存右兄弟，以便子树遍历完后，进入右兄弟。</p><ul><li>后根遍历</li></ul><p>任何结点，后根遍历完后：如有右兄弟，进入右兄弟；否则，上一层（父结点）</p><ul><li><p>三种深度遍历的非递归实现（重要‼️）看ppt</p></li><li><p>广度方向（层次遍历）</p></li></ul><p>利用队列</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><em><strong>二叉树的定义:</strong></em> 结点的有限集合，该集合或者为空集，或者由一个称为根的结点和两颗互不相交的分别称为根的“左子树”和“右子树”的二叉树组成。</p><p>注意：左子树存在，右子树不存在，和左子树不存在，右子树存在是两种不同情况。</p><p><em><strong>运算: 创建、判断是否为空、求根、求父节点、求左子女、求右子女、周游</strong></em></p><p>‼️重要：二叉树并不属于树，<em><strong>二叉树不是树的特殊形态</strong></em>。二叉树在只有一棵子树时，也要明确是左子树还是右子树。这和普通的树是完全不同的。</p><p>满二叉树：<em><strong>如果一棵二叉树的任何结点或者是树叶，或者有两棵非空子树，则此二叉树称作“满二叉树”。</strong></em> <em><strong>注意这个定义和普通定义不同。</strong></em></p><p><em><strong>全满二叉树：</strong></em>为普通定义的“满二叉树”。</p><p><em><strong>完全二叉树</strong></em>：如果一棵二叉树至多只有最下面的两层结点度数可以小于2，并且最下面一层的结点都集中在该层<em><strong>最</strong></em>左边的若干位置上，则此二叉树称为“完全二叉树”。</p><p><em><strong>扩充二叉树</strong></em>：把原来二叉树节点中，度小于2的节点都扩充为度为2的节点。注意：在扩充二叉树的过程中，<em><strong>新增加的“外部节点”一定比原来存在的“内部节点”个数多1</strong></em></p><p>假定内部结点数为n，则扩充二叉树中有2n条边，2n+1个结点，因此外部结点数目为:2n+1-n&#x3D;n+1。</p><p><em><strong>外部路径长度E</strong></em>：在扩充的二叉树里从根到每个外部结点的路径长度之和。</p><p><em><strong>内部路径长度I</strong></em>：在扩充的二叉树里从根到每个内部结点的路径长度之和。</p><p><em><strong>E &#x3D; I + 2n</strong></em></p><h3 id="二叉树的性质："><a href="#二叉树的性质：" class="headerlink" title="二叉树的性质："></a>二叉树的性质：</h3><ol><li>在二叉树的“i层”上至多有 $2^i$ 个结点(i&gt;&#x3D;0)。<ol><li>在二叉树的“第i层”上至多有 $2^{i-1}$ 个结点(i&gt;&#x3D;1)。</li></ol></li><li>深度为k的二叉树至多有 $2^k-1$ 个结点(k&gt;&#x3D;0)。</li><li>对任何一棵二叉树T，如果其叶子结点(度为0的节点)数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</li><li>具有n个结点的<em>完全二叉树</em>的深度k &#x3D; log(n+1)。</li><li>对于有n个节点的<em>完全二叉树</em>，从上到下，从左往右编号（从1开始）<ol><li>i&#x3D;1 i为根</li><li>i &gt; 1，i的父节点为i&#x2F;2</li><li>如果2i &gt; n,i无左子女，否则i的左子女为2i</li><li>如果2i+1 &gt; n,i无右子女，否则i的右子女为2i+1</li></ol></li><li>在<em>扩充二叉树</em>中，外部节点比内部节点多1</li><li><em>扩充二叉树</em>中，外部路径长度E &#x3D; 内部路径长度I + 2 * 内部节点数n</li></ol><p>要掌握性质7的证明</p><p><img src="/posts/11144/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A87%E7%9A%84%E8%AF%81%E6%98%8E.jpg"></p><h1 id="集合与字典"><a href="#集合与字典" class="headerlink" title="集合与字典"></a>集合与字典</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="基于位向量的集合"><a href="#基于位向量的集合" class="headerlink" title="基于位向量的集合"></a>基于位向量的集合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BitSet</span>&#123;<br><span class="hljs-type">int</span> size;<br><span class="hljs-type">char</span> *array;<span class="hljs-comment">//一个字节存储8个0或1</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>size &#x3D; (n+7)&#x2F;8</li><li>which_char &#x3D; idx &#x2F; 8 &#x3D; idx &gt;&gt; 3</li><li>which_bit &#x3D; inx % 8 &#x3D; idx &amp; 7</li></ol><p>运算包括:</p><ol><li>创建 <code>size = (n+7) / 8</code></li><li>插入 <code>array[idx &gt;&gt; 3] |= (1 &lt;&lt; (idx &amp; 7))</code></li><li>删除 <code>array[idx &gt;&gt; 3] &amp;= ~(1 &lt;&lt; (idx &amp; 7))</code></li><li>判断是否属于 <code>return (array[idx &gt;&gt; 3] &amp; (1 &lt;&lt; (idx &amp; 7)))</code></li><li>集合合并 <code>res[i] = array1[i] | array2[i]</code></li><li>集合交集 <code>res[i] = array1[i] &amp; array2[i]</code></li><li>集合差 <code>res[i] = array1[i] &amp; ~array2[i]</code></li></ol><h3 id="基于链表的集合-几乎用不到"><a href="#基于链表的集合-几乎用不到" class="headerlink" title="基于链表的集合(几乎用不到)"></a>基于链表的集合(几乎用不到)</h3><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>组成: 关键码 + 属性</p><p>检索: 按照关键码进行</p><p>存储结构: 静态(不再增删)、动态(频繁增删)</p><p>标准: ASL(平均查找长度), p为查找概率, c为查找当前元素需要的比较次数.</p><p>$$ ASL &#x3D; \sum_{i&#x3D;1}^n p_ic_i $$</p><p>基本运算: 关键码和给定值的比较</p><p>字典的表示: 顺序表、散列表、树表</p><h3 id="顺序表检索"><a href="#顺序表检索" class="headerlink" title="顺序表检索"></a>顺序表检索</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DicElement</span>&#123;<span class="hljs-comment">/*元素结构*/</span><br>KeyType key;  <span class="hljs-comment">/*元素的关键码*/</span><br>DataType other; <span class="hljs-comment">/*其它属性字段*/</span><br>&#125;; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SeqDictionary</span>&#123; <span class="hljs-comment">/*字典结构*/</span><br>DicElement elementMAXNUM]; <span class="hljs-comment">/*字典数组*/</span><br><span class="hljs-type">int</span> n; <span class="hljs-comment">/*实际元素个数*/</span><br>&#125;; <br></code></pre></td></tr></table></figure><h3 id="顺序检索的ASL"><a href="#顺序检索的ASL" class="headerlink" title="顺序检索的ASL"></a>顺序检索的ASL</h3><ol><li>顺序检索 O(n)</li></ol><p>$$ASL &#x3D; \frac{n+1}{2}$$</p><blockquote><p>“+1”不能忘记！</p></blockquote><h3 id="二分检索（折半检索）的ASL"><a href="#二分检索（折半检索）的ASL" class="headerlink" title="二分检索（折半检索）的ASL"></a>二分检索（折半检索）的ASL</h3><ol start="2"><li>二分法检索 中间: (最左+最后)&#x2F;2</li></ol><h3 id="顺序字典的二分查找"><a href="#顺序字典的二分查找" class="headerlink" title="顺序字典的二分查找"></a>顺序字典的二分查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinSearch</span><span class="hljs-params">(SeqDictionary *pdic, KeyType key, <span class="hljs-type">int</span> *pos)</span>&#123;<br><span class="hljs-type">int</span> low,mid,high;<br>low = <span class="hljs-number">0</span>; high = pdic-&gt;n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(low &lt;= high)&#123; <span class="hljs-comment">//注意这里的判断</span><br>‼️mid = (low + high) / <span class="hljs-number">2</span>; <span class="hljs-comment">//注意中间位置</span><br><span class="hljs-keyword">if</span>(key &lt; pdic-&gt;elem[mid].key)&#123;<br>‼️high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//注意边界变化</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; pdic-&gt;elem[mid].key)&#123;<br>‼️low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意边界变化</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>*pos = mid;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>‼️*pos = low; <span class="hljs-comment">//它“应该在”的位置,用于后续插入</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>全满二叉树中，</p><p>$$ASL \approx log_2(n+1) - 1$$</p><blockquote><p>“+1”, “-1”不能忘记！</p></blockquote><p>折半检索必须要是有序的顺序表。</p><h3 id="分块检索的ASL"><a href="#分块检索的ASL" class="headerlink" title="分块检索的ASL"></a>分块检索的ASL</h3><p>分块，块间有序，块内无序</p><ol start="3"><li><em><strong>分块检索</strong></em></li></ol><p>假定b块，每块s个记录；s &#x3D; n &#x2F; b</p><p>对于b：可以顺序、可以折半；</p><p>对于s：只能顺序</p><ol><li>对块间顺序检索</li></ol><p>$$ASL &#x3D; \frac{b+s}{2} + 1  &#x3D; \frac{\frac ns + s }2 + 1$$</p><p>当 $s&#x3D;\sqrt{n}$时</p><p>$$ASL_{min} &#x3D; \sqrt{n} + 1$$</p><ol start="2"><li>块间折半检索</li></ol><p>$$ASL  &#x3D; log_2(\frac ns +1) -1 + \frac{s+1}2 \approx log_2(\frac ns + 1 ) + \frac s2$$</p><h3 id="散链表检索的ASL"><a href="#散链表检索的ASL" class="headerlink" title="散链表检索的ASL"></a>散链表检索的ASL</h3><ul><li><p>散列函数：h(key)</p></li><li><p>散列地址：location &#x3D; h(key)</p></li><li><p>散列表：通过h(key)建立起来的线性表（能够随机存取的顺序表）。</p></li><li><p>“碰撞”：h(key1) &#x3D; h(key2)。需要避免。key1和key2称同义词。</p></li><li><p>“基本区间”：通过散列函数得到的散列地址。同义词可以放在基本区域里未占用的空间，也能另开辟一片空间（溢出区）。</p></li><li><p>“负载因子”：</p></li></ul><p>$$\alpha &#x3D; \frac{散列表中的节点数目}{基本区域能容纳的节点数}$$</p><p>当$\alpha &gt; 1$时，碰撞不可避免。</p><ul><li>“二次聚集”，利用基本区域存储同义词时，不同关键码争夺同一个散列地址。</li></ul><p>处理碰撞</p><ol><li>开放地址法</li><li>再散列</li><li>拉链法</li></ol><p>如果有一组散列函数，就加上“再散列”，如果没有，答1或3</p>]]></content>
    
    
    <summary type="html">讨厌这个。</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第十二讲 图像反射消除</title>
    <link href="https://justaloli.cn/posts/63671.html"/>
    <id>https://justaloli.cn/posts/63671.html</id>
    <published>2023-04-04T05:01:22.000Z</published>
    <updated>2023-04-18T05:00:46.686Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>（为什么是第十二讲）有一些论文原作者可以来讲，因此调整了一下顺序。</p><p>讲者1 常亚坤</p><p>主要内容：</p><ol><li>背景介绍<ul><li>成像模型、反射特性</li></ul></li><li>经典优化求解</li><li>基准评价数据集</li><li>基于深度学习的方法。</li></ol><h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h3><ol><li>反射的成因（经典物理图像</li><li>反射的特性<ol><li>若反射和背景都在景深内，结果相当于线性叠加</li><li>若反射在景深外，背景在景深内，结果相当于给反射加了模糊的卷积</li><li>若反射镜有厚度，将出现重影</li></ol></li><li>反射的（不利）影响<ol><li>例子：对着玻璃拍容易不美观</li><li>对后期计算造成干扰</li></ol></li><li>反射的消除</li></ol><h3 id="2-传统方法"><a href="#2-传统方法" class="headerlink" title="2. 传统方法"></a>2. 传统方法</h3><ol><li>“人力驱动”，手工标记数据</li></ol><p>它基于了“背景图层和反射图层一定程度上是独立的”的假设。</p><p>主要过程：第一阶段：边缘标记和边缘分类-&gt;第二阶段：反射消除</p><ol start="2"><li>景深引导的反射消除</li></ol><p>主要依据：背景清晰时，反射多半会模糊。在梯度分布中也能看出。如果清晰的图像被模糊，梯度值更聚集于0（图像变化更平滑）；如果原本模糊的图像被模糊，则梯度直方图没有太大变化。</p><ol start="3"><li><p>基于相对平滑性</p></li><li><p>基于多张图像：基于两层图像的位移不一致。</p></li></ol><p>变换相机角度，拍摄多张图像。移动时，背景的边缘移动和反射的边缘移动有不同。</p><h3 id="基准评价数据集"><a href="#基准评价数据集" class="headerlink" title="基准评价数据集"></a>基准评价数据集</h3><p>讲者：万人杰</p><p>量化地评价消除反射的效果。</p><p>SIR2数据集；SIR2+数据集</p><p>（后面还有一下东西，没仔细听了呜呜</p><h3 id="深度学习去反射"><a href="#深度学习去反射" class="headerlink" title="深度学习去反射"></a>深度学习去反射</h3><p>第一篇（CN ACCV 16</p><p>借鉴了传统方法的思路，对深度进行分类，然后进行剔除</p><p>Fan ICCV 17</p><p>通过神经网络学背景层的边缘，辅助去除反射</p><p>借鉴了传统的两步走方法：先提取边缘，分类，再剔除</p><p>Wan CVPR 18 CRRN</p><p>并联的反射消除网络</p><p>Wan TPAMI 19 CoRRN</p><p>“协作式”的神经网络，</p><p>Zhang CVPR 18</p><p>“感知损失函数”辅助去反射</p><p>。。。。</p><p>基于偏振的反射消除</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第六讲 光照，反射率与明暗模型</title>
    <link href="https://justaloli.cn/posts/43140.html"/>
    <id>https://justaloli.cn/posts/43140.html</id>
    <published>2023-03-28T05:01:31.000Z</published>
    <updated>2023-04-18T05:00:41.594Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>光度模型</p><p>三维建模方法，激光测距扫描？</p><p>多视角图像重建结果（相机几何标定</p><p>对比：</p><p>几何建模：有总体形状，无细节</p><p>光度立体：无形状？，有精细的细节</p><p>利用光强理解物体的形状，计算机如何从图像的强度中理解物体形象？</p><p>光度成像过程：</p><p><code>光照-&gt;表面法线+反射率-&gt;光强</code></p><p>图像是对场景的观测，观测结果收到几何位置（第三讲）和光强的影响（本讲）</p><p>相机辐射响应：由光强和传感器数值的函数关系。</p><p>线性非线性？场景的辐射度和传感器受到的辐照度是线性的。但是传感器对辐射转化为图像亮度的关系是非线性的。</p><p>相机的辐射响应曲线：图像亮度-辐照度的函数关系。低辐照度时，亮度会高于线性值。</p><p>如何反推原本的辐照度值？反函数，逆响应曲线。</p><p>如何得到逆响应曲线？</p><ul><li>标定法：已知反射率的灰度色块序列（如果认为相机的RGB三个辐射响应曲线相同（这是目前的常见情况）可以单纯用灰度色块标定；而更复杂的情况需要各种颜色的色块做标定。</li><li>没色卡怎么办！多曝光序列的自标定(Mitsunaga, CVPR 99) 用已知<code>曝光时间比</code>的内容一致的图像序列进行标定。利用静态场景不同曝光时间拍摄的一组照片进行标定。<ul><li>待求解的函数：辐照度E &#x3D; g(M)，M为光强，</li><li>将g用k次多项式拟合，k为？4-5阶</li><li>已知曝光时间的比值</li><li><strong>曝光时间比值等于场景辐照度的比值</strong>。</li><li>带入，待定系数，形成一个待优化的目标函数</li><li>利用端点(g(0)&#x3D;0;g(1)&#x3D;1)减少一个系数</li><li>用单调性约束</li><li>最小二乘法</li></ul></li></ul><ul><li>不用线性拟合？<ul><li>Grossberg CVPR 03</li><li>分析许多相机的辐射响应曲线，得到一个“主成分”分析</li><li>将主成分函数按不同比例结合，可以用很少的参数高精度地拟合辐射响应曲线</li></ul></li></ul><p>已经得到了线性的辐照度，如何拿来重建环境的光度？</p><ul><li>反射模型：漫反射、镜面反射</li><li>BRDF：双向反射率分布函数，值为给定入射光方向和反射光方向（一个方向用两个数据，故函数为4元），输出反射能量与入射能量的比值。</li><li>优化：在各向同性（具有旋转对称性），BRDF可简化为三元函数。</li></ul><p>一些难办的光传播现象：这些都不管了！</p><ul><li>折射</li><li>相互反射（光线的多次反射</li><li>次表面反射（树叶半透明</li></ul><p>理想漫反射：朗伯反射：BRDF为常数，反射率为常数。</p><p>光源？</p><ul><li>点光源：向所有方向发出同等强度光。</li><li>平行光源：</li><li>聚光灯：在锥内有光</li></ul><p>表面法线。</p><p>光度成像模型的定量描述：</p><p>L(w_r) &#x3D; 积分（环境光照 * BRDF * 表面法线) dw_i</p><p>简化：朗伯反射模型的平行光反射：好像是一个单项式，挺简单的。</p><p>学术前沿：</p><p>老师梳理了好几篇这方面的文章，主要关于重建场景的光照。并把这个光照信息应用于AR物品的光照渲染。</p>]]></content>
    
    
    <summary type="html">基本上是关于如何由图像得到场景的亮度信息（亮度信息可以帮助重建场景，也能帮助识别物体，比如借助明暗来识别物体。</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第五讲 焦点堆栈与光场摄像</title>
    <link href="https://justaloli.cn/posts/37162.html"/>
    <id>https://justaloli.cn/posts/37162.html</id>
    <published>2023-03-21T05:00:39.000Z</published>
    <updated>2023-04-10T13:45:54.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Focal Stack and Light Field</p><p>上节课的虚拟大光圈是基于“算法”的。直接得到的深度信息很有限。</p><p>本节课将介绍“物理”地方法，从场景中更直接地得到更多深度信息。</p><p>镜头成像：只有一个平面可以聚焦。</p><ul><li><p>如何得到各个深度都清晰的成像？</p><ul><li>快速拍多个不同聚焦平面的照片-&gt;焦点堆栈（Focal Stack Imaging）。</li><li>再得到一张全部对焦的图片（算法加工）（all-in-focus）</li></ul></li><li><p>如何捕获焦点堆栈照片？需要固定哪些参数，更改什么参数？</p><ul><li>更改镜头到传感器的距离S’！（Focal distence）</li><li>也可以更改镜头到物体的距离S</li></ul></li><li><p>如何得到最清晰的部分？（合成）</p><ol><li>图像对齐（Alignment&amp;registration）<ul><li>调整Focal distence时，视场FoV会有些微变化（参见第四讲），要进行一定地缩放调整。</li></ul></li><li>权重分配<ul><li>如何测量每个像素的清晰程度？<strong>这也是相机自动对焦的工作原理</strong></li><li>每个图像，清晰的地方给高权重</li></ul></li><li>加权平均<ul><li>对每个图像每个像素点进行加权平均。</li></ul></li></ol></li><li><p>注：相机自动对焦（主要通过提取边缘）</p><ul><li>做拉普拉斯算子（是一种差分）（可以起到提取边缘的作用）（也有其它提取边缘的方式）</li><li>再做高斯模糊（拉普拉斯算子对噪声比较敏感，模糊起到平滑作用，降噪）</li><li>还有主动对焦方式：比如ToF传感器</li></ul></li><li><p>在焦点堆栈过程中，我们事实上得到了一些深度信息。但是这个信息比较模糊。</p></li><li><p>学术前沿：利用对焦距离和光圈调整估计表面深度（高精度）</p><ul><li>不仅改变焦点距离、同时改变光圈</li><li>利用光圈和对焦距离两个信息得到尽可能真实的深度。</li></ul></li></ul><p>光场不同子集不同角度拍，得到真实光线的，可以还原场景光线的所有光线。</p><p>光场：所有光线的集合</p><p>光场表示方法: L(u,v,s,t)，uv表示光在透镜平面穿过的位置、st表示光在传感器平面穿过的位置。用uvst可以得到透镜到传感器之间的所有光线。</p><p>如何得到光场数据？</p><p>用相机阵列进行光场摄像 or 用一个相机移动进行拍摄</p><p>如何单次相机单次拍摄？</p><p>光场摄像。不让传感器精确聚焦，而是让聚焦的光重新散开（利用一个微透镜阵列），传感器可以得到更丰富的信息。</p><p>学术前沿：深度学习生成光场</p><p>学术前沿：神经辐射场NeRF</p>]]></content>
    
    
    <summary type="html">焦点堆栈与光场摄像</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象编程经验1——概论、模版类、构造函数、析构函数.</title>
    <link href="https://justaloli.cn/posts/38043.html"/>
    <id>https://justaloli.cn/posts/38043.html</id>
    <published>2023-03-17T02:47:10.000Z</published>
    <updated>2023-04-10T13:47:22.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p><strong>警告⚠️本文章逻辑略混乱，请谨慎阅读。</strong></p></blockquote><p>如<a href="https://justaloli.cn/posts/46200.html">上一篇文章</a>所言, 接下来我将以我的双向链表为案例, 分享一些在C++进行类封装及面向对象编程时积累的经验. 本文主要涉及概论、构造函数和析构函数.</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>对象可以理解为现实世界的各个实体. 现实中的实体, 往往具有一些属性(比如物理属性、几何属性等等属性), 也往往具有一些操作或行为(比如猫会叫). </p><p>在面向对象编程时, 所有操作都是针对<strong>对象</strong>进行的. 可以和面向过程编程做出一些比较. 面向对象编程的主体是对象, 即实体; 面向过程编程的主体是过程, 即操作本身.</p><p>以猫猫叫这件事情为例. 面向对象关注的是对象, 即猫. 在面向对象编程中, 猫叫被形容为</p><p><code>猫-&gt;叫</code>, <code>Cat.meow()</code>, 表示是猫这个对象做出了某种行为, 重点在猫.</p><p>而在面向过程编程中, 猫叫被形容为</p><p><code>叫:猫</code>, <code>meow(Cat)</code>, 表示叫这个行为被执行了, 重点在叫这个动作.</p><p>可以看出, 面向对象的描述方式更符合人类的直观.</p><p>实体之间有相互关系. 最重要的关系是, 实体可以分类. 一<strong>类</strong>实体往往具有相似甚至相同的属性, 并且具备一些相同的行为. 比如所有的猫可以归为一<strong>类</strong>猫. </p><p>描述一类事物应当具有哪些属性和行为(更准确的说法是方法)的过程称作类的定义. 根据类的定义, 创建一个具体的对象的过程叫类的实例化. 类是抽象概念, 对象是具体概念. 这很符合人们的常识.</p><p>类之间也有相互关系, 比如包含(更准确的说法是继承), 引用等等. </p><p>类的属性和方法有权限之分. 有些属性和方法可以外人访问和调用, 而有些属性和方法只能内部访问和调用.</p><p>定义一个类有多种方式. 我们当然可以用自然语言定义类:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">手机<br>具有的属性:<br>长、宽、高<br>型号、品牌、……<br>具有的操作:<br>开机、拨号、上网、打开程序……<br></code></pre></td></tr></table></figure><p>类的定义在C++语言中可以描述为这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> height;<br><span class="hljs-comment">//...etc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//...etc</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模版类"><a href="#模版类" class="headerlink" title="模版类."></a>模版类.</h2><blockquote><p>注意:从下文开始, 笔者假定读者有基本的C++编程基础. 并且明白双向链表的工作原理.</p></blockquote><p>模版是C++的一个语法特性. 利用模版, 我们可以创建一个含有未定数据类型的成员的类. 从代码上讲, 一个双向链表的节点可以这样定义.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>T data<br>Node&lt;T&gt;* next;<br>Node&lt;T&gt;* prev;<br>&#125;<br><span class="hljs-comment">//到这里为止,是template &lt;typename T&gt;</span><br><span class="hljs-comment">//的作用范围.在这个作用范围内,T就指代了一个数据类型.</span><br><span class="hljs-comment">//这个数据类型在实例化Node类时才被明确.</span><br></code></pre></td></tr></table></figure><p>实例化Node类时,就需要明确模版T对应的具体类型,如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node&lt;<span class="hljs-type">int</span>&gt; n;<span class="hljs-comment">//创建对象</span><br></code></pre></td></tr></table></figure><p>由于双向链表内部需要创建Node,因此双向链表的list类也需要笼罩在一个模版下.故list的定义需要:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>...<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>Node&lt;T&gt;* head;<br>Node&lt;T&gt;* tail;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的,实例化list需要明确模版T对应的类型.如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; li;<br></code></pre></td></tr></table></figure><p><strong>Remark:</strong> 类也是类型.因此这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; li;<br></code></pre></td></tr></table></figure><p>是合法的.你不过是创建了一个类型T为<code>list&lt;int&gt;</code>的列表. </p><p>不过需要注意, <strong>应当确保传入的类型具有你对类型T进行的运算</strong>. 比如你在对类型T进行了加减法, 你就需要确保你传入的类型具有加减法. </p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数."></a>构造函数和析构函数.</h2><p>在对象创建时, 将执行构造函数; 在对象销毁时, 将执行析构函数.</p><p>对于普通的情况, 程序将生成默认的构造函数和析构函数. 不过有时候, 我们需要在创建和删除类的时候进行复杂的操作, 这时就不能依靠默认的构造和析构函数了. 我们要自己写.</p><p>构造函数是一个名称和类名称相同,不填写返回值的函数.析构函数是一个波浪线<code>~</code>+类名称,不填写返回值的函数. 它们的定义方式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>Node&lt;T&gt;* head;<br>Node&lt;T&gt;* tail;<br><span class="hljs-type">int</span> _size;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义构造函数.</span><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义析构函数.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数的实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//填写构造函数的具体内容</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;<br>head = <span class="hljs-keyword">new</span> node&lt;T&gt;;<br>tail = <span class="hljs-keyword">new</span> node&lt;T&gt;;<br><br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里, <code>list&lt;T&gt;::</code>代表这是list这个类的函数(方法). 描述类方法的方式有两种: 在类内部定义,在类外部定义. 个人喜欢外部定义. 在外部定义时,需要<code>list&lt;T&gt;::</code>以明确这是list类的方法.同时需要加上<code>template &lt;typename T&gt;</code></p><p>在构造函数中, 我们创建了head和tail两个节点, 并让head和tail首尾相接. 这之后,我们让存储链表长度的变量_size设置为0. 这样, 在实例化一个list时,这些指令会被执行,从而完成链表的初始化.</p><p>一般我们不需要重写析构函数.系统会自动释放类里面的所有内存.但是这是链表,还有许多节点零散地分配在内存空间中,你不能保证系统知道它们是相连地,然后帮你释放它们.所以我们要自己实现析构函数.</p><p>析构函数的实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br>node&lt;T&gt; *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先删除链表里的所有元素,最后删除头和尾. 由于在使用中, 我们偶尔也想清空链表,因此可以把清空链表的部分拿出来,单独作为一个函数(方法).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span>&#123;<br><span class="hljs-keyword">private</span>:<br>...<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义构造函数.</span><br>~<span class="hljs-built_in">list</span>();<span class="hljs-comment">//定义析构函数.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//定义方法</span><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::<span class="hljs-built_in">list</span>()&#123;...&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> list&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br>node&lt;T&gt; *t = head-&gt;next;<br><span class="hljs-keyword">while</span>(t!=tail)&#123;<br>t = t-&gt;next;<br><span class="hljs-keyword">delete</span> t-&gt;prev;<br>&#125;<br>head-&gt;next = tail;<br>tail-&gt;prev = head;<br>_size=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>list&lt;T&gt;::~<span class="hljs-built_in">list</span>()&#123;<br><span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">delete</span> head;<br><span class="hljs-keyword">delete</span> tail;<br>head = <span class="hljs-literal">nullptr</span>;tail = <span class="hljs-literal">nullptr</span>;temp = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">警告⚠️本文章逻辑略混乱，请谨慎阅读。     以我的双向链表为案例, 分享一些在C++进行类封装及面向对象编程时积累的经验. 本文主要涉及概论、构造函数和析构函数.</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数算" scheme="https://justaloli.cn/tags/%E6%95%B0%E7%AE%97/"/>
    
    <category term="面向对象" scheme="https://justaloli.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第四讲 镜头 曝光 对焦</title>
    <link href="https://justaloli.cn/posts/29774.html"/>
    <id>https://justaloli.cn/posts/29774.html</id>
    <published>2023-03-14T05:01:11.000Z</published>
    <updated>2023-04-10T13:46:19.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><p>上节课复习：相机几何模型：场景和光学镜头之间的计算。</p></li><li><p>本节课：</p></li></ul><p>我能看多远（长焦、焦距）？我能看多广（广角、视场）？我能清晰地看多深（大光圈、大景深）？</p><ul><li>薄透镜成像</li></ul><p>注意：只有某个平面上的光会被清晰对焦。其它深度的物体处于失焦状态。光源将形成一个模糊圈（一个模糊的圆形）</p><p><strong>理想薄透镜不存在。现实上使用多个透镜的透镜组近似薄透镜的性质，而不是用单独的凸透镜成像。</strong></p><ul><li><p>像差：真实成像和理想的薄透镜成像的差距。比如：色差；单色像差（也称散光）</p></li><li><p>视场：通过镜头能观察到的高度、宽度（FoV）</p></li></ul><p>可以用薄透镜成像模型，通过相似三角形原理计算视场角。和焦距、传感器大小有关，呈arctan的变化。</p><ol><li><p>视场和对焦距离有关：降低对焦距离，视场减小</p></li><li><p>视场和焦距的关系：增加焦距，视场减小。</p></li></ol><p>Remark: 注意区分对焦距离（focus distence，改变镜头组到传感器的距离）和焦距(focal lens，改变镜片的光学性质)！</p><p><em>增加焦距的效果和画面裁切有类似。</em> 但是二者有区别！透视投影关系不同。</p><ol start="3"><li>视场和传感器大小的关系：画幅越大视场越大。</li></ol><p>全画幅（35mm）、中画幅（中画幅比全画幅大，中画幅是全画幅出现之前的标准44x33mm）、APS、……</p><p>fun fact：哈勃望远镜的焦距57.6m</p><ul><li>定焦镜头&amp;变焦镜头？</li></ul><p>定&amp;变的是焦距(focal lens)，对焦距离（focus distence）都能变。</p><ul><li>其它镜头：微距镜头，消除色差镜头，非球面镜，……</li></ul><h2 id="曝光Exposure"><a href="#曝光Exposure" class="headerlink" title="曝光Exposure"></a>曝光Exposure</h2><ul><li>快门速度(Shutter Speed)</li></ul><p>慢快门会让快速运动的物体变模糊(motion blur，动态模糊)。有一些去除动态模糊的算法。</p><p>快门的效果也可以利用：如拍摄星轨、延时摄影。</p><ul><li>光圈(Aperture)</li></ul><p>f-number 是焦距&#x2F;光圈口径的比值。数值越小，光圈越大。</p><p>例：50mm的镜头，光圈1.4, 光圈口径为50&#x2F;1.4 &#x3D; 36mm.</p><p>此外，可以用相似原理得到，模糊圈大小和光圈口径有关。光圈</p><p>大光圈会带来景深（Depth of Field, DoF）效果。大光圈，景深变浅。景深：图片看起来清晰的范围。</p><p>大光圈、浅景深带来虚化(bokeh,日语词)效果。</p><p>fun fact: 模糊圈和光圈形状有关。可以改变开口形状达到独特效果。</p><ul><li>镜头“速度”</li></ul><p>它指代了镜头的最大光圈。光圈大，快门快的时候也能得到足够进光的图像。因此认为镜头的“速度”快。它是(最大)光圈大小的描述。</p><ul><li>感光度(ISO)</li></ul><p>参见第二讲的内容。模拟前端的放大器将模拟电压进行放大，放大倍数就是iso！</p><h2 id="相机模式"><a href="#相机模式" class="headerlink" title="相机模式"></a>相机模式</h2><p>Auto、A、S、M、</p><h2 id="产业应用、学术前沿"><a href="#产业应用、学术前沿" class="headerlink" title="产业应用、学术前沿"></a>产业应用、学术前沿</h2><p>估计场景深度-&gt;加模糊效果</p><p>准确的算出深度是一件困难的事情。曾经，手机的双摄被用来估计场景深度；也有一些“双像素”技术，用于把前景扣出来。</p><ul><li>双像素技术：</li></ul><p>将一部分像素一分为二，配置独立的光电二极管用于成像。相当于两个间距极小的镜头拍摄的照片，可以用来得到深度信息。</p><p>现在还有用神经网络渲染大光圈的效果，不用传统的方式加模糊。</p><ul><li><p>神经网络的图像去模糊-&gt;重新再模糊，实现后期重对焦。</p></li><li><p>双像素去模糊</p></li><li><p>无镜头成像</p></li></ul><p>场景-&gt;某种调制膜mask-&gt;传感器得到图片-&gt;算法重建</p><p>mask可以对入射光进行光学上的编码，让传感器得到的数据可以被解码分析。</p><ul><li>不可见到可见</li></ul><p>拍一个墙，通过计算让墙成为“镜子”，得到一般看不到的物体。</p>]]></content>
    
    
    <summary type="html">本课内容：镜头、曝光、对焦</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算摄像学 第三讲 相机几何模型</title>
    <link href="https://justaloli.cn/posts/62008.html"/>
    <id>https://justaloli.cn/posts/62008.html</id>
    <published>2023-03-07T05:00:10.000Z</published>
    <updated>2023-04-10T13:45:43.860Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>回顾计算摄像</p><p>计算摄像：通过计算从照片中获取更多信息。</p><p>在多个环节可以引入计算：</p><ol><li>场景和光学镜头之间的计算</li><li>传感器上对光信号的计算</li><li>传感器到图像之间的计算</li></ol><h2 id="引言：相机想知道的东西"><a href="#引言：相机想知道的东西" class="headerlink" title="引言：相机想知道的东西"></a>引言：相机想知道的东西</h2><ol><li>我在哪里——相机的空间位置</li><li>我看到的世界——相机看到的物体的空间位置</li></ol><h2 id="裸传感器成像"><a href="#裸传感器成像" class="headerlink" title="裸传感器成像"></a>裸传感器成像</h2><p>空间每个点的漫反射光都被传感器每个像素点接收——几乎无法成像。</p><h2 id="针孔相机成像"><a href="#针孔相机成像" class="headerlink" title="针孔相机成像"></a>针孔相机成像</h2><p>针孔对光线路径做出了选择，可以得到一个倒像。</p><p>相机术语：</p><ul><li>投影中心：即小孔位置</li><li>光圈：即小孔</li><li>焦距（遮光板到传感器的距离）</li></ul><p>改变焦距，传感器上的成像大小会改变。</p><p>针孔相机的问题：孔大导致模糊；孔小导致光强小，且带来衍射问题。</p><p>进光效率：孔直径大，进光大；焦距短，接收光的效果好</p><p>档：（f值）：焦距除以针孔直径。</p><p><strong>针孔相机的成像模型可以帮助理解现代相机。</strong></p><h2 id="相机矩阵：三维到二维的坐标变换"><a href="#相机矩阵：三维到二维的坐标变换" class="headerlink" title="相机矩阵：三维到二维的坐标变换"></a>相机矩阵：三维到二维的坐标变换</h2><p>用于解释开头的两个问题。</p><p>一些数学</p><p><img src="/posts/62008/%E7%9B%B8%E6%9C%BA%E7%9F%A9%E9%98%B5.png" alt="相机将三维世界的坐标（大X）通过线性变换转化为二维大图像坐标（小x的前两个分量）"></p><p>x &#x3D; f X&#x2F;Z; y &#x3D; f Y&#x2F;Z</p><p>P &#x3D; K[R|t]X, P(x,y,z)’ 为相机上的图像坐标，K(3 * 3)为内参矩阵，R(3 * 3)为相机在世界坐标系的旋转，t(3 * 1)为相机坐标系在世界坐标系中的平移，X为物体在世界的坐标(X,Y,Z,1)’ </p><p><strong>外参矩阵蕴含了相机在空间的平移和旋转；内参矩阵蕴含了相机将外界投影到照片的方式。二者分别回答“我在哪里”和“我眼中的世界”的问题</strong></p><h3 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h3><p>让景物变大：增加焦距？减小物体到针孔的距离？效果不同！</p><p>应用：“眩晕效果（滑动变焦）”，固定前景的大小，同时改变焦距和物体距离，制造景深的变化。</p><p>极端情况：正交投影：超级超级超级长焦，深度对大小不影响。（常见于游戏。</p><h2 id="相机几何标定"><a href="#相机几何标定" class="headerlink" title="相机几何标定"></a>相机几何标定</h2><h3 id="三维匹配点标定法"><a href="#三维匹配点标定法" class="headerlink" title="三维匹配点标定法"></a>三维匹配点标定法</h3><p>利用一些已知的三维空间点-相机图像坐标的对应关系，推知整个相机矩阵。</p><p>再利用算出的矩阵分析焦距、中心点等参数（得到一个上三角矩阵和正交矩阵，分别是相机的内部参数和外部坐标旋转）。</p><h3 id="非线性优化算法，处理类似畸变问题"><a href="#非线性优化算法，处理类似畸变问题" class="headerlink" title="非线性优化算法，处理类似畸变问题"></a>非线性优化算法，处理类似畸变问题</h3><h3 id="多图棋盘格标定法"><a href="#多图棋盘格标定法" class="headerlink" title="多图棋盘格标定法"></a>多图棋盘格标定法</h3><p>已经很成熟。</p><h2 id="学术前沿"><a href="#学术前沿" class="headerlink" title="学术前沿"></a>学术前沿</h2><ol><li>大规模的相机几何标定</li><li>利用深度学习进行相机几何标定</li><li>利用图像的“消失点”“消失线”进行几何标定</li><li>从镜面反射进行几何标定</li><li>……</li></ol>]]></content>
    
    
    <summary type="html">难过，听不懂</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>今日无用英语——杂货铺的正确翻译</title>
    <link href="https://justaloli.cn/posts/14140.html"/>
    <id>https://justaloli.cn/posts/14140.html</id>
    <published>2023-03-05T05:13:01.000Z</published>
    <updated>2023-04-10T15:10:05.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>背单词软件常常将<em>grocery</em>翻译为杂货铺，以至于我很长时间认为杂货铺的翻译是<em>grocery</em>。</p><p>但深究杂货铺和<em>grocery</em>的含义，这种翻译大概是错误的。且看二者的词典释义：</p><blockquote><p>杂货（zá huò）（杂货铺词条在我的大辞海上找不到）<strong>各种日用</strong>的<strong>零星货物</strong>。如:杂货铺; 日用杂货。《醒世恒言·卖油郎独占花魁》: “一应麦豆茶酒油盐杂货, 无所不备。”<br>出处：语词卷</p></blockquote><blockquote><p>grocery &#x2F;ˈɡrəʊsəri; NAmE ˈɡroʊsəri’&#x2F;NOUN ( plural groceries )1.(especially BrE)(NAmE usually ˈgrocery store’) [countable] a shop&#x2F;store that sells <strong>food and other things</strong> used in the home. In American English ‘grocery store’is often used to mean <strong>‘supermarket’</strong>. <strong>食品</strong>杂货店（在美式英语中 grocery store 常用以指 supermarket）2.groceries [plural] <strong>food and other goods</strong> sold by a groceror at a supermarket食品杂货</p></blockquote><p>可以注意到grocery明确有“食品“的含义，而中文语境中的杂货铺，大概很少和食物联系上。此外，中文语境中的杂货铺大概是贩卖“小零碎”的低调存在，而反观grocery store，在美国甚至指supermarket，是一种高调的存在。</p><p>更直观的说，这是“杂货铺”的百度图片搜索结果：</p><p><img src="/posts/14140/%E6%9D%82%E8%B4%A7%E9%93%BA%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87.jpeg" alt="能看到几乎与食品无关，且店面偏小"></p><p>而这是grocery的Google图片搜索结果：</p><p><img src="/posts/14140/grocerygooglephoto.jpeg" alt="能看到几乎与完全是食品，且店面类似超市"></p><p>故二者词义差距很大，将杂货铺译成grocery是很不当的。</p><h2 id="杂货铺的良好翻译？"><a href="#杂货铺的良好翻译？" class="headerlink" title="杂货铺的良好翻译？"></a>杂货铺的良好翻译？</h2><p><strong>junk store</strong> 可能是杂货铺的一个较为良好的翻译。junk store直译是旧货店，而旧货店和杂货铺可能有一些重合的区域。</p><p>至少，junk store和杂货铺的重合范围一定比grocery和杂货铺的重合范围大。</p><p>这一点也可以从图片搜索结果中体现：</p><p><img src="/posts/14140/junkstoregooglephoto.jpeg" alt="junk store的google搜索结果。至少有了中文“杂货铺”的意境"></p><p><em><strong>因此在翻译“杂货铺”时，可以尝试翻译为junk store。</strong></em></p><p>这篇文章就到这里～</p>]]></content>
    
    
    <summary type="html">反正不是grocery.</summary>
    
    
    
    <category term="英语" scheme="https://justaloli.cn/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="博客" scheme="https://justaloli.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="英语" scheme="https://justaloli.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>地图着色问题</title>
    <link href="https://justaloli.cn/posts/32813.html"/>
    <id>https://justaloli.cn/posts/32813.html</id>
    <published>2023-03-01T10:33:34.000Z</published>
    <updated>2023-03-01T11:37:07.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题：地图着色问题"><a href="#问题：地图着色问题" class="headerlink" title="问题：地图着色问题"></a>问题：地图着色问题</h2><p>问题简介：将一个图分成几部分，使得对于每一个部分，其中的节点互相不连接。</p><p>问题理解：这种问题往往有多种划分方式，即有多个解。可以采用贪心法找到其中的某一个解，或者使用回溯法遍历所有的可能解。</p><h2 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h2><ul><li><p>程序实现的数据结构：图（用于存储节点之间的网状关系），集合（用于存储划分中的每个部分），由集合构成的顺序表（用于存储划分），字符串，字符串构成的顺序表（用于存储节点的名字）。</p></li><li><p>各数据结构的UML图：</p></li></ul><pre><code class=" mermaid">classDiagram    class string&#123;    -char* str        +fprint(FILE*) Void        +operator=(char*) Void        +operator==(string) Bool    &#125;    class graph&#123;    -int nodeCount    +initgraph() Void    +islinked(int,int) Bool    &#125;    class set&#123;    -int size    -bool* setarray    +add() Void    +remove() Void    +isempty() Bool    +begin() iterator    +end() iterator    &#125;    class iterator&#123;    &lt;&lt;enumeration&gt;&gt;    -int pos    -set* fatherset    +operator*(): Int    +operator++()    +next(): iterator    &#125;</code></pre><ul><li><p>算法：实现了贪心法 <strong>及</strong> 回溯法。仅上交回溯法的代码。</p></li><li><p>环境：g++ -std&#x3D;c++11; MacOS，arm64</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>收获：回顾了计算概论的内容。学习了图在计算机中的存储。复习了c++中类的写法。</p><p>问题与解决办法：</p><ul><li>问题：集合中元素的遍历。由于集合元素的存储方式，元素的存储位置在内存中可能是分立的，给集合的遍历带来困难。</li><li>查阅资料，实现了一个集合的迭代器，封装了集合的遍历过程。</li></ul><p>不足：搜索效率不高。</p><h2 id="输入输出："><a href="#输入输出：" class="headerlink" title="输入输出："></a>输入输出：</h2><p>输入为<code>filei.txt</code>，包含：</p><p>一个整数N，代表节点个数；N个字符串，代表每个节点的名字；一个N * N的矩阵，每个数是0或1。<code>a[i][j]=1</code>代表节点i和j相连。</p><p>输出为<code>fileo.txt</code>，包含：</p><p>所有可能的分划，以及可能的分划总数，以及最少的分划数。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 地图着色问题 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 20</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br><span class="hljs-comment">/* 类定义：字符串 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-type">char</span> str[MAXLEN] = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：打印字符串 */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,str);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fprint</span><span class="hljs-params">(FILE *fp)</span></span>&#123;<br><span class="hljs-comment">/* 操作：打印字符串 */</span><br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;%s &quot;</span>,str);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> s[])&#123;<br><span class="hljs-comment">/* 操作：字符串赋值 */</span><br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &lt; s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; i&lt;MAXLEN ; ++i)<br>&#123;<br>str[i] = s[i];<br>&#125;<br>str[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> string s)&#123;<br><span class="hljs-comment">/* 操作：字符串比较是否相等 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXLEN; ++i)<br>&#123;<br><span class="hljs-keyword">if</span>(str[i]!=s.str[i])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> <span class="hljs-type">char</span> s[])&#123;<br>string ts;ts = s;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>==ts;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span>&#123;<br><span class="hljs-comment">/* 类定义：图 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-comment">/* 逻辑关系：网状结构 */</span><br><span class="hljs-type">int</span> grapharr[MAXLEN][MAXLEN]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/* 构造函数，填入图的节点数 */</span><br><span class="hljs-built_in">graph</span>(<span class="hljs-type">int</span> nn)&#123;n=nn;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initgraph</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 初始化函数，读入图的数据 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;grapharr[i][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initgraph</span><span class="hljs-params">(FILE *fp)</span></span>&#123;<br><span class="hljs-comment">/* 初始化函数，读入图的数据 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>&#123;<br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%d&quot;</span>,&amp;grapharr[i][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/* 操作：判断两个节点是否连接上 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">islinked</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> grapharr[a][b];&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">set</span>&#123;<br><span class="hljs-comment">/* 类定义：集合 */</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/* 逻辑关系：集合；但是在内部实现时，利用了元素的线性结构 */</span><br><span class="hljs-comment">/* 存储结构：顺序存储 */</span><br><span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> setarray[MAXLEN] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：添加元素 */</span><br><span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;MAXLEN &amp;&amp; <span class="hljs-keyword">not</span> <span class="hljs-built_in">isexist</span>(i))&#123;<br>setarray[i] = <span class="hljs-literal">true</span>;<br>size++;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：删除元素 */</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isexist</span>(i))&#123;<br>setarray[i] = <span class="hljs-literal">false</span>;<br>size--;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> !size;&#125;<span class="hljs-comment">/* 判断集合是否为空 */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isexist</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 判断元素是否存在 */</span><br><span class="hljs-keyword">return</span> i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;MAXLEN &amp;&amp; setarray[i];<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span>&#123;<br><span class="hljs-comment">/* 类定义：集合的迭代器，用于遍历集合的所有元素 */</span><br><span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<br>set* fatherset = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">iterator</span>(set* ptr,<span class="hljs-type">int</span> n)&#123;<br><span class="hljs-comment">/* 构造函数：给定一个指定位置 */</span><br>pos = n<span class="hljs-number">-1</span>;<br>fatherset = ptr;<br>(*<span class="hljs-keyword">this</span>)++;<br>&#125;<br><span class="hljs-built_in">iterator</span>(set* ptr)&#123;<br><span class="hljs-comment">/* 构造函数：定在初始位置 */</span><br>pos = <span class="hljs-number">-1</span>;<br>fatherset = ptr;<br>(*<span class="hljs-keyword">this</span>)++;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++()&#123;<br><span class="hljs-comment">/* 操作：自增 */</span><br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">while</span>(fatherset-&gt;setarray[pos]==<span class="hljs-number">0</span>)&#123;<br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> k)&#123;<br><span class="hljs-comment">/* 操作：自增 */</span><br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">while</span>(fatherset-&gt;setarray[pos]==<span class="hljs-number">0</span>)&#123;<br>pos++;<br><span class="hljs-keyword">if</span>(pos&gt;=MAXLEN)<span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>*()<span class="hljs-type">const</span>&#123;<br><span class="hljs-comment">/* 操作：取值 */</span><br><span class="hljs-keyword">return</span> pos;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; it)&#123;<br><span class="hljs-comment">/* 运算：是否不等 */</span><br><span class="hljs-keyword">return</span> it.pos!=pos;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> iterator&amp; it)&#123;<br><span class="hljs-comment">/* 运算：是否相等 */</span><br><span class="hljs-keyword">return</span> it.pos==pos;<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(fatherset,pos+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;;<br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向首个元素的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向首个元素的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 操作：得到一个指向末尾的迭代器 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>,MAXLEN);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isunrelated</span><span class="hljs-params">(set targetset,graph g,<span class="hljs-type">int</span> node)</span></span>&#123;<br><span class="hljs-comment">/* 判断图 g 上的 node 节点是否与 targetset 里面的所有节点都不相连 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = targetset.<span class="hljs-built_in">begin</span>();i!=targetset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span>(g.<span class="hljs-built_in">islinked</span>(*i, node))&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printtempset</span><span class="hljs-params">(set tset,string i2s[MAXLEN])</span></span>&#123;<br><span class="hljs-comment">/* 将tset里面的元素对应的string全部打印。元素和字符串的对应关系存储在i2s[]中 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = tset.<span class="hljs-built_in">begin</span>();i!=tset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br>i2s[*i].<span class="hljs-built_in">print</span>();<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fprinttempset</span><span class="hljs-params">(FILE *fp,set tset,string i2s[MAXLEN])</span></span>&#123;<br><span class="hljs-comment">/* 将tset里面的元素对应的string全部打印。元素和字符串的对应关系存储在i2s[]中 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = tset.<span class="hljs-built_in">begin</span>();i!=tset.<span class="hljs-built_in">end</span>();i++)<br>&#123;<br>i2s[*i].<span class="hljs-built_in">fprint</span>(fp);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 节点数 */</span><br><span class="hljs-type">int</span> N=<span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 用一个顺序表存储所有数字元素对应的节点名称 */</span><br>string indexToString[MAXLEN];<br>graph *mygraph;<br>set leftset;<br>set groupsets[<span class="hljs-number">20</span>];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">loaddatafromfile</span><span class="hljs-params">(<span class="hljs-type">char</span> fpath[])</span></span>&#123;<br>FILE *fp;<br>fp = <span class="hljs-built_in">fopen</span>(fpath,<span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span>(fp==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br><span class="hljs-comment">/* 录入节点数 */</span><br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br><span class="hljs-comment">/* 录入所有名称 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>&#123;<br><span class="hljs-type">char</span> ts[MAXLEN]=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%s&quot;</span>,ts);<br>indexToString[i] = ts;<br>&#125;<br><span class="hljs-comment">/* 实例化、初始化图 */</span><br>mygraph = <span class="hljs-keyword">new</span> <span class="hljs-built_in">graph</span>(N);<br>mygraph-&gt;<span class="hljs-built_in">initgraph</span>(fp);<br><br><span class="hljs-built_in">fclose</span>(fp);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = groupsets[i].<span class="hljs-built_in">begin</span>(); j != groupsets[i].<span class="hljs-built_in">end</span>(); j++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> <span class="hljs-built_in">isunrelated</span>(groupsets[i],*mygraph,*j))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> shortestgroupnum = MAXLEN;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(FILE *fp,<span class="hljs-type">int</span> currentgroupnum, set::iterator currentanalyzenode)</span></span>&#123;<br><span class="hljs-comment">/* fp:写入结果的文件指针，currentgroupnum：目前有的分划数，</span><br><span class="hljs-comment">currentanalyzenode：目前要处理的节点 */</span><br><span class="hljs-keyword">if</span>(currentgroupnum&gt;<span class="hljs-number">4</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(currentanalyzenode == leftset.<span class="hljs-built_in">end</span>())&#123;<br><span class="hljs-comment">/* 完成了一次分划，输出分划结果 */</span><br><span class="hljs-keyword">if</span>(currentgroupnum &lt; shortestgroupnum)&#123;<br>shortestgroupnum = currentgroupnum;<br>&#125;<br>count++;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;第%d个结果:\n&quot;</span>,count);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentgroupnum; i++)<br>&#123;<br><span class="hljs-built_in">fprinttempset</span>(fp,groupsets[i],indexToString);<br>&#125;<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;校验结果：%s\n&quot;</span>,<span class="hljs-built_in">check</span>()?<span class="hljs-string">&quot;正确&quot;</span>:<span class="hljs-string">&quot;错误&quot;</span>);<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 带回溯的将当前节点放置到所有可能的分划中，包括已有的分划和放入一个新分划 */</span><br>set::iterator i = currentanalyzenode;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;currentgroupnum;j++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isunrelated</span>(groupsets[j],*mygraph , *i))&#123;<br>groupsets[j].<span class="hljs-built_in">add</span>(*i);<br>leftset.<span class="hljs-built_in">remove</span>(*i);<br><span class="hljs-comment">/* 放入已有的分划，向下搜索 */</span><br><span class="hljs-built_in">search</span>(fp,currentgroupnum,i.<span class="hljs-built_in">next</span>());<br><span class="hljs-comment">/* 回溯 */</span><br>groupsets[j].<span class="hljs-built_in">remove</span>(*i);<br>leftset.<span class="hljs-built_in">add</span>(*i);<br>&#125;<br>&#125;<br>groupsets[currentgroupnum].<span class="hljs-built_in">add</span>(*i);<br>leftset.<span class="hljs-built_in">remove</span>(*i);<br><span class="hljs-comment">/* 放入一个新分划，向下搜索 */</span><br><span class="hljs-built_in">search</span>(fp,currentgroupnum+<span class="hljs-number">1</span>,i.<span class="hljs-built_in">next</span>());<br><span class="hljs-comment">/* 回溯 */</span><br>groupsets[currentgroupnum].<span class="hljs-built_in">remove</span>(*i);<br>leftset.<span class="hljs-built_in">add</span>(*i);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mymain</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* 实例化、初始化集合 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>&#123;<br>leftset.<span class="hljs-built_in">add</span>(i);<br>&#125;<br><br>FILE *fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;fileo.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-keyword">if</span>(fp==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><span class="hljs-comment">/* 搜索 */</span><br><span class="hljs-built_in">search</span>(fp,<span class="hljs-number">0</span>,leftset.<span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">/* 结果 */</span><br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;搜索完成，共%d个结果\n&quot;</span>, count);<br><span class="hljs-built_in">fprintf</span>(fp,<span class="hljs-string">&quot;最少分划个数为：%d&quot;</span>, shortestgroupnum);<br><br><span class="hljs-built_in">fclose</span>(fp);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">char</span> path[] = <span class="hljs-string">&quot;filei.txt&quot;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">loaddatafromfile</span>(path))<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">mymain</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>计算摄像学 第二讲 数字摄像流程</title>
    <link href="https://justaloli.cn/posts/23312.html"/>
    <id>https://justaloli.cn/posts/23312.html</id>
    <published>2023-02-28T04:52:50.000Z</published>
    <updated>2023-04-10T13:45:49.254Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="第二讲-数字摄像流程（Digital-Photography-Pipeline"><a href="#第二讲-数字摄像流程（Digital-Photography-Pipeline" class="headerlink" title="第二讲 数字摄像流程（Digital Photography Pipeline"></a>第二讲 数字摄像流程（Digital Photography Pipeline</h2><!-- ISP --><p>参考书：</p><ol><li><a href="http://szeliski.org/book">http://szeliski.org/book</a> 《Computer Vision: Algorithms and Applications, 2nd ed.》</li><li><a href="https://imagingtext.github.io/">https://imagingtext.github.io</a> 《Computational Imaging》</li><li><a href="https://link.springer.com/referencework/10.1007/978-3-030-63416-2">https://link.springer.com/referencework/10.1007/978-3-030-63416-2</a> 第二版</li></ol><p>计算摄像的三个处理位置：成像之前，成像，成像之后</p><p>本课内容：</p><ul><li>图像传感器</li><li>模拟前端</li><li>颜色滤波</li><li>-&gt;</li><li>相机内部的图像处理（ISP</li></ul><!-- 视频：手机和相机的拍照对比，好机友姜唯。 --><h3 id="图像传感器-Imaging-Sensor"><a href="#图像传感器-Imaging-Sensor" class="headerlink" title="图像传感器 Imaging Sensor"></a>图像传感器 Imaging Sensor</h3><p>拍照：快门打开-&gt;传感器接收光子、储存光子-&gt;快门关闭，曝光结束-&gt;将光子转化成数字信号处理。</p><p>核心的感光组件：光电二极管（产生电子）、势井（存储电子）。</p><p>衡量光电二极管的一个指标：QE &#x3D; 光子量&#x2F;电子量</p><p>过曝：光子过多，势井饱和；欠曝：光子过少，随机性太高。除此以外的情况，电子数基本上<strong>线性的反映光子数</strong>。</p><p>两种图像传感器的芯片：CCD &amp; CMOS</p><table><thead><tr><th>CCD</th><th>CMOS</th></tr></thead><tbody><tr><td>更高感光度</td><td>更快读出</td></tr><tr><td>更低噪声</td><td>更低成本</td></tr></tbody></table><p>目前CMOS已经能达到接近CCD的性能。</p><h3 id="模拟前端"><a href="#模拟前端" class="headerlink" title="模拟前端"></a>模拟前端</h3><p>将传感器得到的光子（电压，模拟信号）转化为数字信号</p><p>电压-&gt;「模拟放大器」-&gt;模拟电压-&gt;「模数转换器」-&gt;数字信号-&gt;「编码」-&gt;数字信号</p><blockquote><p>fun fact: ISO调整的是「模拟放大器」的强度。</p></blockquote><h3 id="颜色滤波器"><a href="#颜色滤波器" class="headerlink" title="颜色滤波器"></a>颜色滤波器</h3><p>可见光：400-700nm波长</p><p>大多数光源含有不止一种波长的光。</p><p>不同的光谱频率分布可以产生类似或者相同的颜色感知。</p><p>色温。</p><p>感光器的响应值受到光源的频谱和传感器对不同频率的接收能力影响。</p><p>人眼细胞分别对RGB三个颜色的接收能力最强。颜色滤波器在设计时参考了人眼。</p><p>滤波器在传感器上的分布？拜耳阵列（RGGB</p><p>为什么要更多绿色？简而言之，研究认为人眼对绿色更敏感。</p><p>颜色滤波没有标准答案。滤波会带来颜色风格的细微差异。</p><h3 id="相机内部对图像的处理（ISP"><a href="#相机内部对图像的处理（ISP" class="headerlink" title="相机内部对图像的处理（ISP"></a>相机内部对图像的处理（ISP</h3><p>ISP: Image Singal Processor: 广义的指将原始图像转换为“正常”图像的一系列图像处理操作。</p><p>白平衡；去马赛克；降噪；色调再现；压缩；etc。</p><h4 id="白平衡-White-Balance-WB"><a href="#白平衡-White-Balance-WB" class="headerlink" title="白平衡 White Balance WB"></a>白平衡 White Balance WB</h4><ul><li>人眼可以在不同光照环境下正确感知“白色是白色”。</li></ul><p>白平衡：不管在任何光源下，都能将白色物体还原成白色，用于校准色温的偏差。</p><p>方法：</p><ol><li>手动白平衡：手动确定某个点，某个物体是白色。</li><li>预设白平衡：预设一些光源条件下的色温</li></ol><p>经典的自动白平衡算法：</p><p>利用白平衡的特性：全局偏差，让全局RGB分别的统计值变成相同的，就白了。</p><ul><li>灰色世界假设<ul><li>逐通道计算RGB<strong>平均值</strong></li><li>逐通道利用<strong>平均值</strong>归一化</li><li>乘以“绿色通道的<strong>平均值</strong>”作为增益</li></ul></li><li>白色世界假设<ul><li>逐通道计算RGB<strong>最大值</strong></li><li>逐通道利用<strong>最大值</strong>归一化</li><li>乘以“绿色通道的<strong>最大值</strong>”作为增益</li></ul></li></ul><h4 id="去马赛克"><a href="#去马赛克" class="headerlink" title="去马赛克"></a>去马赛克</h4><p>拜耳阵列中，每个像素感受到不同颜色光，产生“马赛克效果”，需要去除。</p><p>用相邻的其它颜色像素取平均，得到当前像素的其它颜色值。</p><h4 id="降噪-Denoising"><a href="#降噪-Denoising" class="headerlink" title="降噪 Denoising"></a>降噪 Denoising</h4><p>噪声在低光照时尤为明显。</p><p>噪声的来源比较复杂：</p><ul><li>散粒噪声：光子到达服从泊松分布</li><li>暗电流：电路热效应产生一些电子</li><li>读出噪声：传感器和模拟前端电路的噪声</li></ul><p>简单降噪算法：平均滤波（卷积，利用周围像素），中值滤波</p><p>更复杂的降噪算法</p><h4 id="（色彩空间转化）"><a href="#（色彩空间转化）" class="headerlink" title="（色彩空间转化）"></a>（色彩空间转化）</h4><p>相机内部可能会把RGB色彩空间转化成HSV色彩空间。</p><p>这件事的意义：将RGB分离成更加独立的变量，方便研究。</p><h4 id="色调再现（伽马矫正"><a href="#色调再现（伽马矫正" class="headerlink" title="色调再现（伽马矫正"></a>色调再现（伽马矫正</h4><p>最初是因为CRT显示器对颜色的现实是非线性的。</p><p>目前伽马矫正与CRT无关。</p><p>人眼对低亮度更敏感，因此将相机的线性感光修正为适合人眼的非线性感光。</p><h4 id="（图像压缩）"><a href="#（图像压缩）" class="headerlink" title="（图像压缩）"></a>（图像压缩）</h4><p>略</p><h4 id="补充：RAW图像格式的意义：线性！"><a href="#补充：RAW图像格式的意义：线性！" class="headerlink" title="补充：RAW图像格式的意义：线性！"></a>补充：RAW图像格式的意义：线性！</h4><p>ISP处理后的图像和原始光强是非线性的。这不利于研究。</p><p>RAW图像仍然保持了和环境光强的良好的线性性。对计算机视觉而言非常有用:D</p><p>对一般人：保存更多信息，后期空间。</p><p>RAW的坏处：噪声，无压缩，降低连拍速度</p><p>注：RAW可能也经过了一些与处理，比如去马赛克。</p><p>将jpeg还原为RAW是一件非常困难的事情。</p><h3 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h3><p>ISP深入理解： <a href="https://www.eecs.yorku.ca/~mbrown/ICCV2019_Brown.html">https://www.eecs.yorku.ca/~mbrown/ICCV2019_Brown.html</a></p><p>更好的看paper的方法：two minute papers youtube</p><p>用卷积神经网络进行超暗照片的增强 Learning to see in the dark. ChenChen UIUC等 2018；</p><p>Day-to-Night image Synthesis for Training Nighttime Neural ISPs</p>]]></content>
    
    
    <summary type="html">本课内容：图像传感器、模拟前端、颜色滤波、相机内部的图像处理（ISP</summary>
    
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/categories/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
    
    <category term="计算摄像学" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%91%84%E5%83%8F%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>胡椒厨房——现在的人，没有精力再DIY</title>
    <link href="https://justaloli.cn/posts/52048.html"/>
    <id>https://justaloli.cn/posts/52048.html</id>
    <published>2023-02-23T07:42:50.000Z</published>
    <updated>2023-04-10T15:07:33.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>儿时的回忆往往是碎片的，除了某些闪光点，其它的经历往往都变得模糊。这是我的其中一个碎片。</p><p>那可能是我很小的时候，在万达的一家餐厅。这是父母第一次带我走进这家餐厅。我记得，当我期待美食的时候，店员端上来一个呲呲作响的铁盘。我看着铁板上沸腾的神色的酱汁，血红的生肉，感到多么的新奇又不知所措。</p><p>我记得，在父母的指导下，我如何手忙脚乱地翻动盘中的食材，如何尝试把鸡蛋和米饭拌匀，如何小心翼翼地不让食材洒出来，如何用勺子用力把粘锅的食材刮下来，如何看着牛肉奇迹般地在我眼前变成我熟悉的颜色……</p><p>我记得，迫不及待品尝时，我如何被金属勺子轻轻烫到，在把握温度后如何大快朵颐，到最后，如何不舍地从盘底的沟槽中挖出最后一颗饭粒。饭粒在铁板的加热下，变得焦黄而且微微透明。</p><p>那是我小时候，去过的最好吃的餐厅之一。事实上，这可能是我第一次认识了什么是胡椒。（同样获此荣誉的，还有某次姥姥带我吃的老上海城隍庙。那次体验在我心里完全定义了什么是小笼包。）</p><p>当然，它获此荣誉，还有一个不得不提的原因：这之后的某个时候，它就被拆掉了，在我家附近再也找不到胡椒厨房这家店。这一次美好体验，就在我心里成为了抹不掉的念想。</p><p>之后，在离家较远的一个商城又看到了它。这之后，我偶尔会专程跑到这个很远的地方，专程吃一次这家店，在享用的同时重温当时的美妙回忆。我不会经常想到它。但是一旦想到，我几乎内心就不会再冒出其它选择。</p><p>然后，这天我又突发奇想去吃了一餐。却发现，这家店的名字从“胡椒厨房”变成了“铁板厨房”。虽然菜品没变，但店名的变化，总让人产生一些不安的情绪。事实上，从我家附近的胡椒厨房倒闭这件事就能看出，这个品牌的处境可能并不太好。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>胡椒厨房和普通的餐饮店有所区别。胡椒厨房的菜品主要包含米饭和肉（主要是牛肉），顾客也可以选择添加鸡蛋和蔬菜。在出餐时，店员端出的是放在高温铁盘上的生食。拿到餐品后，需要顾客自己对食材进行翻炒，直到菜品变熟后食用。也因此，胡椒厨房将自己定义为一家“DIY餐厅”。菜品口味方面，如「胡椒厨房」的店名，菜品中胡椒是重要调料，形成类似BBQ的烧烤风味。除了胡椒，顾客可以按照喜好，添加诸如「蒜香汁」等调料。</p><p>抛开童年回忆的光环，平心而论，胡椒厨房的菜品绝对是能分到「好吃」一类的。BBQ的风味显然具有很大的吸引力。此外，胡椒、蒜香的调料也可以带来独特的味觉享受。</p><p>更重要的是，DIY的特色使得胡椒厨房相比其它餐饮店具有一个巨大优势：<strong>它的饭菜一直是热的。</strong> 事实上，人对热的食物往往没有抵抗力。加热的铁盘，让食物可以长时间地保持在最适合的温度。</p><p>或许“石锅拌饭”之类的饭馆也有类似的特征，但请注意：胡椒厨房是铁盘而不是铁碗。在进食时，绝大部分的食材都能充分得到加热和保温。</p><p>要说菜品口味的不足，首先，它可能以咸口为主，对咸口不感冒的人可能不太喜欢；其次，它的菜品可能偏油腻。除此两点，它的口味大抵是令人满意的。</p><p>但是，味道好并不代表餐厅能活得好。我认为，至少有以下几点原因，让胡椒厨房变成现在这种局面。</p><p><strong>首先，也是最重要的，是价格问题。</strong> 胡椒厨房的人均50+，一言以蔽之，太贵了。一份「胡椒牛肉饭」需要49，还没鸡蛋，加个鸡蛋变成52。先不说一个鸡蛋三块钱的这个离谱问题，49，就一碗饭，一些牛肉还有一点胡椒，这个价格确实太贵了。</p><p>49，在呷哺呷哺我能买一整盘牛肉，再来个蔬菜双拼再点个锅底。这个量显然要比胡椒厨房足的多。有可能胡椒厨房的牛肉的来源更高级。但是，一言以蔽之，一般人吃不出来，<del>“感知不强”</del>。定价过高，注定了它不会受到太多欢迎。</p><p><strong>其次，胡椒厨房的定价引申出了第二个问题，就是品牌的定位不明。</strong> 笔者粗略地把线下餐饮业分成快餐和饭馆两种。从菜品上分析，胡椒厨房明显属于前者。胡椒厨房是一人一盘的一人食餐厅，这是几乎所有快餐店具有的共同特征。但是，人们对快餐的要求往往是廉价、快速。如果作为快餐店，它明显地太贵了。而且，它DIY的特性，也导致它并没有那么的“快速”。</p><p>但是，把胡椒厨房归类为“饭馆”又明显是不合适的。一人一盘的特点，让胡椒厨房不具备饭馆应有的社交功能。打个比方，如果约亲友聚会，胡椒厨房肯定不是备选项。此外，DIY的特性让它的进食过程显得有些紧张和狼狈，这不是饭馆应该有的。<em>（火锅店、烤肉店大概也具有DIY性质，但是首先，你不把食材放进去它就不会加热，所以至少还有喘息的机会；其次，它具有社交属性。）</em></p><p>它不甘于做廉价的快餐，它尝试做高端，它做50多的主食，做一百多的牛排；但是，它又没有高端餐饮应该具有的优雅和社交功能。不论从哪个角度看，胡椒厨房都是不合格的。</p><p><strong>此外，随着互联网的兴起，胡椒厨房DIY的性质又给它自身带来了第三重打击：无法外带</strong>。互联网改变了人们的饮食方式。现在，如果要吃快餐，人们往往会选择手机定外卖。因此，那些传统的“快餐店”，包括一些餐品不够高端的饭馆，都努力地做起了外卖的生意。但就在这样的时代，胡椒厨房无法外带，这就类似于宣告了自己的死亡。</p><p>目前这个时代，在繁忙的工作之余，人们大多靠定外卖草率解决；在周末休息的时候，人们大概会找一家优雅的餐馆给自己身心的享受。在这个时代，谁会专程出去吃一家看起来不那么高档，还需要自己忙活的DIY的餐厅呢？</p><p>现在的人，恐怕已经没有精力DIY了。</p><p>我祝愿我生活圈内的这唯一一家胡椒厨房还能长青。人们都时不时地希望自己能重温童年，我也希望能重温在我童年留下深刻印象的味道。我不希望当我脑海中闪过这种希望时，接踵而来的是无法释怀的空虚，即便这种希望可能与时代潮流相悖。</p>]]></content>
    
    
    <summary type="html">我喜欢，我仍然喜欢。我祝愿我生活圈内的这唯一一家胡椒厨房还能长青。人们都时不时地希望自己能重温童年，我也希望能重温在我童年留下深刻印象的味道。我不希望当我脑海中闪过这种希望时，接踵而来的是无法释怀的空虚，即便这种希望可能与时代潮流相悖。</summary>
    
    
    
    
    <category term="杂记" scheme="https://justaloli.cn/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计算概论A-不围棋</title>
    <link href="https://justaloli.cn/posts/300.html"/>
    <id>https://justaloli.cn/posts/300.html</id>
    <published>2023-02-22T13:27:38.000Z</published>
    <updated>2023-04-10T15:10:19.676Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>PDF文稿: <a href="/assets/pdf/%E5%9F%BA%E4%BA%8EC++%E7%9A%84%E4%B8%8D%E5%9B%B4%E6%A3%8B%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0.pdf">基于C++的不围棋游戏程序的实现.pdf</a></p><p>在下面嵌一个iframe以供浏览。不过手机端可能不支持这个功能。</p><iframe src="/assets/pdf/基于C++的不围棋游戏程序的实现.pdf" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="700px"> </iframe>]]></content>
    
    
    <summary type="html">不围棋的大作业报告。</summary>
    
    
    
    <category term="编程" scheme="https://justaloli.cn/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="编程" scheme="https://justaloli.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="计算概论" scheme="https://justaloli.cn/tags/%E8%AE%A1%E7%AE%97%E6%A6%82%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>流浪地球2一周目简评</title>
    <link href="https://justaloli.cn/posts/52568.html"/>
    <id>https://justaloli.cn/posts/52568.html</id>
    <published>2023-01-29T02:01:31.000Z</published>
    <updated>2023-04-10T13:44:50.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>看了流浪地球2. 电影总体的观感是很优秀的。接近三个小时的片长，对于这个内容的体量而言比较合适，不会让人觉得乏味。我特地看的IMAX版本，视听效果足够震撼。这部片子，完全对得起它目前在网络上获得的高分评价。</p><p>下面总结一下我一周目后想到的一些内容。</p><h2 id="相比第一部的优点"><a href="#相比第一部的优点" class="headerlink" title="相比第一部的优点"></a>相比第一部的优点</h2><h3 id="移除了“春节”元素"><a href="#移除了“春节”元素" class="headerlink" title="移除了“春节”元素"></a>移除了“春节”元素</h3><p>我不喜欢融入大量档期元素的特定档期电影。这种电影给人的印象是：它只为特定档期服务，只能靠着“蹭”特定档期的“流量”来获得票房，进而给人的印象是这种电影的质量不高。</p><p>优秀的导演和编剧应该有一种自信：我的电影不应该局限在某个特定的档期或者特定的上映时间。应该有一种自信：我拍的电影在全年任何一个时间上映，都将是一部优秀的电影。</p><p>显然，郭帆拍流浪地球1的时候没有这种自信；2的时候有了。</p><h3 id="角色身份的“提升”"><a href="#角色身份的“提升”" class="headerlink" title="角色身份的“提升”"></a>角色身份的“提升”</h3><p>（我流浪地球1也是一周目，记忆不太深刻）总的来说，流浪地球1是以一对兄妹的视角叙述的。这一对兄妹在玩闹似地跑出地下城后，偶遇了某个救援队，并展开了故事。这种视角，严厉的说，让人感觉当时的危机和救援宛如小孩子的儿戏。</p><p>流浪地球2的主要角色：李雪健饰演的高级政客；吴京饰演的军人；刘德华饰演的工程师。他们有专业的身份，肩负重大的责任。以他们的视角代入事件，更能体现危机之危，救援之难，也更匹配流浪地球系列的宏大叙事。</p><p>比起让两个无业小孩支招拯救世界，让真正的专业人士拯救世界大概更好一些。</p><h2 id="二的优点"><a href="#二的优点" class="headerlink" title="二的优点"></a>二的优点</h2><h3 id="“前传”式的剧情设计"><a href="#“前传”式的剧情设计" class="headerlink" title="“前传”式的剧情设计"></a>“前传”式的剧情设计</h3><p>流浪地球2选择在1的时间线之前做文章，是一个十分高明的决定。至少有以下几个好处：</p><ol><li>设定交代。</li></ol><p>2中丰富了许多关于“数字生命”和机器生命“MOSS&#x2F;550W”的设定，并且完善了流浪地球时代联合政府（UEG）的国际政治制度和物资配给制的经济制度。</p><p>这些内容很重要。</p><p>关于MOSS的设定让MOSS的重要性大幅度提升。事实上，流浪地球1中，MOSS是一个可有可无的存在。事实上，把1中的MOSS换成一个不太智能的，Siri一样的角色，甚至换成一个没有智能、纯机械的程序，整体的故事不会发生太大改变，可以正常推进。但是，有了2中的背景交代，MOSS一跃而成为重要势力。相当于通过“前传”的交代，让配角一跃成为主角。</p><p>对流浪地球时代政治经济的交代，让人们对这个时代的大局有了基本的把握。1可以说是以兄妹的“点”的视角描述这个时代，2是以“面”的视角描述这个时代。12相映，让人们对当时的整个世界已经建立了基本的感知。这有利于更多的故事在这个世界下展开。</p><ol start="2"><li>大量伏笔埋设</li></ol><p>流浪地球2选择“前传”叙事，为故事创造了大量未解开的谜团。无须多言。</p><ol start="3"><li>给续作留足空间</li></ol><p>前两点的好处，归根结底都是这一点。</p><p>我觉得流浪地球1没有给续作流出足够空间。想象一下，如果没有2，直接在流浪地球1的结尾之后做文章，能写的故事似乎不多。但是有了2，续作能写的内容一下子就丰富了：</p><ul><li>MOSS一跃成为主角，MOSS和图恒宇成为主线（而且，由于是数字生命，这条主线不会因为角色的衰老死亡而停止，有机会一直延续），有很多故事可以基于它展开</li><li>留下大量谜团，解开这些包袱基本就足够撑起一个续作了</li><li>介绍了这个时代的大观，如果要翻拍原著的剧情也会相对容易。</li></ul><h3 id="内涵丰富，有深度，有主旨"><a href="#内涵丰富，有深度，有主旨" class="headerlink" title="内涵丰富，有深度，有主旨"></a>内涵丰富，有深度，有主旨</h3><p>上文提到，相比于1，角色的身份有了“提升”。高阶层的人物角色更配合2的宏大主题。因此，2中设计的内涵也更加丰富。不论是强调“危难当前唯有责任”的责任感，还是歌颂敢于牺牲自我的英雄，还是强调人类团结所能迸发的巨大力量，电影中都有足够的内容来撑起这些主题。</p><p>此外，还有一些关于亲情、关于使命在一代代人间的传承，关于数字生命、生死概念的讨论等等话题可以从电影中引申。总之，丰富的情节和内涵让这部片可以从多个角度分析。</p><p><del>不过我是一周目，我暂且还不能仔细分析。</del></p><h3 id="（相对）中庸的政治立场"><a href="#（相对）中庸的政治立场" class="headerlink" title="（相对）中庸的政治立场"></a>（相对）中庸的政治立场</h3><p>价值导向应该中国优先还是世界优先的问题上，电影一方面强调了中国在计划中的重要作用，另一方面又时刻强调，这是全人类——各国——共同奋斗的结果，很中庸地回答了这个问题。</p><p>危难由少数英雄解决还是多数集体解决的问题上，一方面有吴京、刘德华这种个人英雄角色，一方面电影也时刻强调了团结、合作的重要性，很中庸地回答了这个问题。</p><p>总之，基本上不会让观众在电影的政治立场上产生反感。 <strong>这在一个国民普遍政治神经紧绷的时代，是很难得的。</strong></p><h2 id="我觉得不好的地方"><a href="#我觉得不好的地方" class="headerlink" title="我觉得不好的地方"></a>我觉得不好的地方</h2><h3 id="“老套”的剧情"><a href="#“老套”的剧情" class="headerlink" title="“老套”的剧情"></a>“老套”的剧情</h3><p>不得不说，电影很多地方体现了灾难片的典型套路。概括地说，电影无非是 <code>somehow出现危机 -&gt; 人类团结！！！黄金精神！！！ -&gt; somehow解决危机</code> 这个流程它甚至演了两次。</p><p>这样抽象的看，剧情是很无聊的（当然，抽象到这个程度，基本绝大多数电影都是无聊的）</p><p>还有啊，后面恢复全球互联网的时候，经典的“要卡到最后一秒才能解决问题”，说实话这种剧情很无聊诶 <code>-_-</code></p><h3 id="过于强调“刺激”“紧张”"><a href="#过于强调“刺激”“紧张”" class="headerlink" title="过于强调“刺激”“紧张”"></a>过于强调“刺激”“紧张”</h3><p>这点其实是我的个人看法。</p><p>流浪地球的故事设定，它本可以有更沉静，更压抑的表现手段。面对灭世的灾难，人类集体的背井离乡，牺牲人类社会原有的一切，压制享乐，压制文化艺术，步入集权和配给制，倾尽全力拯救危机只为苟且为生，走在茫然无光的漫漫长路上。</p><p>这种氛围，不仅是一种“危”，更是一种“悲”。除了拯救危机体现出的紧张、刺激的情节外，更应该有一种浓厚的悲凉。很遗憾，这种悲凉似乎没有得到很好的体现。</p><p>结尾的 <em>Goodbye, solar system[多语种]</em> 可以算是这种悲的一个体现。只能说，有，但是不多。</p><p>这局限了作品的深度。全片过于强调危难和应对，紧张刺激的大场面首尾相接，相当于不断地给观众打鸡血，让观众兴奋，而无法让观众静下来感受这种“悲”。</p><p>我觉得这是比较遗憾的。</p><h3 id="关于BGM的一些事"><a href="#关于BGM的一些事" class="headerlink" title="关于BGM的一些事"></a>关于BGM的一些事</h3><p>本片主要的氛围都是紧张的。紧张的部分，本片的BGM做的相当不错。</p><p>不过，就像上一部分所说的，片子的“悲”的部分有些少。仅有的那些“悲”的部分，我觉得BGM做的不够好。就以最后 <em>Goodbye, solar system[多语种]</em> 的部分为例。就我个人的理解，我觉得BGM应该体现出宇宙的空灵和肃杀。但是，此时的BGM，事实上只能起到“宏大”的感受，而无法体现出“空灵”的感受。这种BGM不太能体现宇宙的感觉。</p><p>总之，紧张部分的BGM很优秀；但是沉静部分的BGM，我觉得本片缺少一个类似 <em>Interstellar</em> 中 <em>Day One</em> 那样的优秀作品。</p><p>类似我在上一部分的观点，我觉得片尾曲不应该是那种紧张感十足的电音，而应该归于沉静，类似<em>Interstellar</em> 中的 <em>Day One</em>。尤其是到了片尾，我觉得更应该让观众的内心从紧张归于沉静，给观众时间反思这整个经历，而不是靠片尾曲尝试把情绪推向又一个高潮。</p><p>总之，我认为紧张和沉静应该是交替的，流浪地球2在这方面做的不够好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>足够优秀，并且写了一些我的想法。</p><p>就到这里。</p>]]></content>
    
    
    <summary type="html">看了流浪地球2. 电影总体的观感是很优秀的。接近三个小时的片长，对于这个内容的体量而言比较合适，不会让人觉得乏味。我特地看的IMAX版本，视听效果足够震撼。这部片子，完全对得起它目前在网络上获得的高分评价。</summary>
    
    
    
    
    <category term="流浪地球" scheme="https://justaloli.cn/tags/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83/"/>
    
    <category term="影评" scheme="https://justaloli.cn/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
</feed>
